#!/usr/bin/env bun
// @bun
import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/zod/v3/helpers/util.js
var util, objectUtil, ZodParsedType, getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var init_util = __esm(() => {
  (function(util2) {
    util2.assertEqual = (_) => {};
    function assertIs(_arg) {}
    util2.assertIs = assertIs;
    function assertNever(_x) {
      throw new Error;
    }
    util2.assertNever = assertNever;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
      const filtered = {};
      for (const k of validKeys) {
        filtered[k] = obj[k];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e) {
        return obj[e];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys = [];
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    util2.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
      };
    };
  })(objectUtil || (objectUtil = {}));
  ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
});

// node_modules/zod/v3/ZodError.js
var ZodIssueCode, quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
}, ZodError;
var init_ZodError = __esm(() => {
  init_util();
  ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  ZodError = class ZodError extends Error {
    get errors() {
      return this.issues;
    }
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue.path.length) {
              const el = issue.path[i];
              const terminal = i === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    static assert(value) {
      if (!(value instanceof ZodError)) {
        throw new Error(`Not a ZodError: ${value}`);
      }
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          const firstEl = sub.path[0];
          fieldErrors[firstEl] = fieldErrors[firstEl] || [];
          fieldErrors[firstEl].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
  };
});

// node_modules/zod/v3/locales/en.js
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "bigint")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
}, en_default;
var init_en = __esm(() => {
  init_ZodError();
  init_util();
  en_default = errorMap;
});

// node_modules/zod/v3/errors.js
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var overrideErrorMap;
var init_errors = __esm(() => {
  init_en();
  overrideErrorMap = en_default;
});

// node_modules/zod/v3/helpers/parseUtil.js
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === en_default ? undefined : en_default
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== undefined) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
}, EMPTY_PATH, INVALID, DIRTY = (value) => ({ status: "dirty", value }), OK = (value) => ({ status: "valid", value }), isAborted = (x) => x.status === "aborted", isDirty = (x) => x.status === "dirty", isValid = (x) => x.status === "valid", isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var init_parseUtil = __esm(() => {
  init_errors();
  init_en();
  EMPTY_PATH = [];
  INVALID = Object.freeze({
    status: "aborted"
  });
});

// node_modules/zod/v3/helpers/typeAliases.js
var init_typeAliases = () => {};

// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
var init_errorUtil = __esm(() => {
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
  })(errorUtil || (errorUtil = {}));
});

// node_modules/zod/v3/types.js
class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}

class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
}, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, nanoidRegex, jwtRegex, durationRegex, emailRegex, _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`, emojiRegex, ipv4Regex, ipv4CidrRegex, ipv6Regex, ipv6CidrRegex, base64Regex, base64urlRegex, dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`, dateRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [undefined, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
}, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, ZodReadonly, late, ZodFirstPartyTypeKind, instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params), stringType, numberType, nanType, bigIntType, booleanType, dateType, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType, ostring = () => stringType().optional(), onumber = () => numberType().optional(), oboolean = () => booleanType().optional(), coerce, NEVER;
var init_types = __esm(() => {
  init_ZodError();
  init_errors();
  init_errorUtil();
  init_parseUtil();
  init_util();
  cuidRegex = /^c[^\s-]{8,}$/i;
  cuid2Regex = /^[0-9a-z]+$/;
  ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
  uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  nanoidRegex = /^[a-z0-9_-]{21}$/i;
  jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
  durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
  ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
  ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
  dateRegex = new RegExp(`^${dateRegexSource}$`);
  ZodString = class ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const status = new ParseStatus;
      let ctx = undefined;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "nanoid") {
          if (!nanoidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "nanoid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "date") {
          const regex = dateRegex;
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "date",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "time") {
          const regex = timeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "time",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "duration") {
          if (!durationRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "duration",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "jwt") {
          if (!isValidJWT(input.data, check.alg)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "jwt",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cidr") {
          if (!isValidCidr(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cidr",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64") {
          if (!base64Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64url") {
          if (!base64urlRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
      return this.refinement((data) => regex.test(data), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    nanoid(message) {
      return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    base64(message) {
      return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
    }
    base64url(message) {
      return this._addCheck({
        kind: "base64url",
        ...errorUtil.errToObj(message)
      });
    }
    jwt(options) {
      return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    cidr(options) {
      return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          local: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        offset: options?.offset ?? false,
        local: options?.local ?? false,
        ...errorUtil.errToObj(options?.message)
      });
    }
    date(message) {
      return this._addCheck({ kind: "date", message });
    }
    time(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "time",
          precision: null,
          message: options
        });
      }
      return this._addCheck({
        kind: "time",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        ...errorUtil.errToObj(options?.message)
      });
    }
    duration(message) {
      return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options?.position,
        ...errorUtil.errToObj(options?.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message)
      });
    }
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodString.create = (params) => {
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  ZodNumber = class ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = undefined;
      const status = new ParseStatus;
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
    }
    get isFinite() {
      let max = null;
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        } else if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  };
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  ZodBigInt = class ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        try {
          input.data = BigInt(input.data);
        } catch {
          return this._getInvalidInput(input);
        }
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        return this._getInvalidInput(input);
      }
      let ctx = undefined;
      const status = new ParseStatus;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx.parsedType
      });
      return INVALID;
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodBigInt.create = (params) => {
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  ZodBoolean = class ZodBoolean extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  ZodDate = class ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (Number.isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus;
      let ctx = undefined;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  };
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: params?.coerce || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  ZodSymbol = class ZodSymbol extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  ZodUndefined = class ZodUndefined extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  ZodNull = class ZodNull extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  ZodAny = class ZodAny extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  ZodUnknown = class ZodUnknown extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  ZodNever = class ZodNever extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  };
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  ZodVoid = class ZodVoid extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  ZodArray = class ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : undefined,
            maximum: tooBig ? def.exactLength.value : undefined,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })).then((result2) => {
          return ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      });
      return ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodArray.create = (schema, params) => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  ZodObject = class ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util.objectKeys(shape);
      this._cached = { shape, keys };
      return this._cached;
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip") {} else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key,
              value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== undefined ? {
          errorMap: (issue, ctx) => {
            const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: errorUtil.errToObj(message).message ?? defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    extend(augmentation) {
      return new ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    merge(merging) {
      const merged = new ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    catchall(index) {
      return new ZodObject({
        ...this._def,
        catchall: index
      });
    }
    pick(mask) {
      const shape = {};
      for (const key of util.objectKeys(mask)) {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      for (const key of util.objectKeys(this.shape)) {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      for (const key of util.objectKeys(this.shape)) {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      for (const key of util.objectKeys(this.shape)) {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  };
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodUnion = class ZodUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = undefined;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  };
  ZodUnion.create = (types, params) => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  ZodDiscriminatedUnion = class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    static create(discriminator, options, params) {
      const optionsMap = new Map;
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues.length) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  };
  ZodIntersection = class ZodIntersection extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  };
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  ZodTuple = class ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x) => !!x);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new ZodTuple({
        ...this._def,
        rest
      });
    }
  };
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  ZodRecord = class ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  };
  ZodMap = class ZodMap extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = new Map;
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = new Map;
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  };
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  ZodSet = class ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = new Set;
        for (const element of elements2) {
          if (element.status === "aborted")
            return INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  ZodFunction = class ZodFunction extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.function) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.function,
          received: ctx.parsedType
        });
        return INVALID;
      }
      function makeArgsIssue(args, error) {
        return makeIssue({
          data: args,
          path: ctx.path,
          errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_arguments,
            argumentsError: error
          }
        });
      }
      function makeReturnsIssue(returns, error) {
        return makeIssue({
          data: returns,
          path: ctx.path,
          errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_return_type,
            returnTypeError: error
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        const me = this;
        return OK(async function(...args) {
          const error = new ZodError([]);
          const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
            error.addIssue(makeArgsIssue(args, e));
            throw error;
          });
          const result = await Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error.addIssue(makeReturnsIssue(result, e));
            throw error;
          });
          return parsedReturns;
        });
      } else {
        const me = this;
        return OK(function(...args) {
          const parsedArgs = me._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      });
    }
    returns(returnType) {
      return new ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params)
      });
    }
  };
  ZodLazy = class ZodLazy extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  };
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  ZodLiteral = class ZodLiteral extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  };
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  ZodEnum = class ZodEnum extends ZodType {
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(this._def.values);
      }
      if (!this._cache.has(input.data)) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values, newDef = this._def) {
      return ZodEnum.create(values, {
        ...this._def,
        ...newDef
      });
    }
    exclude(values, newDef = this._def) {
      return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
        ...this._def,
        ...newDef
      });
    }
  };
  ZodEnum.create = createZodEnum;
  ZodNativeEnum = class ZodNativeEnum extends ZodType {
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(util.getValidEnumValues(this._def.values));
      }
      if (!this._cache.has(input.data)) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  };
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  ZodPromise = class ZodPromise extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  };
  ZodPromise.create = (schema, params) => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  ZodEffects = class ZodEffects extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(processed).then(async (processed2) => {
            if (status.value === "aborted")
              return INVALID;
            const result = await this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          });
        } else {
          if (status.value === "aborted")
            return INVALID;
          const result = this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base))
            return INVALID;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
            if (!isValid(base))
              return INVALID;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
              status: status.value,
              value: result
            }));
          });
        }
      }
      util.assertNever(effect);
    }
  };
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  ZodOptional = class ZodOptional extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK(undefined);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  ZodNullable = class ZodNullable extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  ZodDefault = class ZodDefault extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  };
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  ZodCatch = class ZodCatch extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  };
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  ZodNaN = class ZodNaN extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  };
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  BRAND = Symbol("zod_brand");
  ZodBranded = class ZodBranded extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  };
  ZodPipeline = class ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b) {
      return new ZodPipeline({
        in: a,
        out: b,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  };
  ZodReadonly = class ZodReadonly extends ZodType {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      const freeze = (data) => {
        if (isValid(data)) {
          data.value = Object.freeze(data.value);
        }
        return data;
      };
      return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  late = {
    object: ZodObject.lazycreate
  };
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  stringType = ZodString.create;
  numberType = ZodNumber.create;
  nanType = ZodNaN.create;
  bigIntType = ZodBigInt.create;
  booleanType = ZodBoolean.create;
  dateType = ZodDate.create;
  symbolType = ZodSymbol.create;
  undefinedType = ZodUndefined.create;
  nullType = ZodNull.create;
  anyType = ZodAny.create;
  unknownType = ZodUnknown.create;
  neverType = ZodNever.create;
  voidType = ZodVoid.create;
  arrayType = ZodArray.create;
  objectType = ZodObject.create;
  strictObjectType = ZodObject.strictCreate;
  unionType = ZodUnion.create;
  discriminatedUnionType = ZodDiscriminatedUnion.create;
  intersectionType = ZodIntersection.create;
  tupleType = ZodTuple.create;
  recordType = ZodRecord.create;
  mapType = ZodMap.create;
  setType = ZodSet.create;
  functionType = ZodFunction.create;
  lazyType = ZodLazy.create;
  literalType = ZodLiteral.create;
  enumType = ZodEnum.create;
  nativeEnumType = ZodNativeEnum.create;
  promiseType = ZodPromise.create;
  effectsType = ZodEffects.create;
  optionalType = ZodOptional.create;
  nullableType = ZodNullable.create;
  preprocessType = ZodEffects.createWithPreprocess;
  pipelineType = ZodPipeline.create;
  coerce = {
    string: (arg) => ZodString.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
    boolean: (arg) => ZodBoolean.create({
      ...arg,
      coerce: true
    }),
    bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate.create({ ...arg, coerce: true })
  };
  NEVER = INVALID;
});

// node_modules/zod/v3/external.js
var exports_external = {};
__export(exports_external, {
  void: () => voidType,
  util: () => util,
  unknown: () => unknownType,
  union: () => unionType,
  undefined: () => undefinedType,
  tuple: () => tupleType,
  transformer: () => effectsType,
  symbol: () => symbolType,
  string: () => stringType,
  strictObject: () => strictObjectType,
  setErrorMap: () => setErrorMap,
  set: () => setType,
  record: () => recordType,
  quotelessJson: () => quotelessJson,
  promise: () => promiseType,
  preprocess: () => preprocessType,
  pipeline: () => pipelineType,
  ostring: () => ostring,
  optional: () => optionalType,
  onumber: () => onumber,
  oboolean: () => oboolean,
  objectUtil: () => objectUtil,
  object: () => objectType,
  number: () => numberType,
  nullable: () => nullableType,
  null: () => nullType,
  never: () => neverType,
  nativeEnum: () => nativeEnumType,
  nan: () => nanType,
  map: () => mapType,
  makeIssue: () => makeIssue,
  literal: () => literalType,
  lazy: () => lazyType,
  late: () => late,
  isValid: () => isValid,
  isDirty: () => isDirty,
  isAsync: () => isAsync,
  isAborted: () => isAborted,
  intersection: () => intersectionType,
  instanceof: () => instanceOfType,
  getParsedType: () => getParsedType,
  getErrorMap: () => getErrorMap,
  function: () => functionType,
  enum: () => enumType,
  effect: () => effectsType,
  discriminatedUnion: () => discriminatedUnionType,
  defaultErrorMap: () => en_default,
  datetimeRegex: () => datetimeRegex,
  date: () => dateType,
  custom: () => custom,
  coerce: () => coerce,
  boolean: () => booleanType,
  bigint: () => bigIntType,
  array: () => arrayType,
  any: () => anyType,
  addIssueToContext: () => addIssueToContext,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransformer: () => ZodEffects,
  ZodSymbol: () => ZodSymbol,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodSchema: () => ZodType,
  ZodRecord: () => ZodRecord,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPipeline: () => ZodPipeline,
  ZodParsedType: () => ZodParsedType,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNever: () => ZodNever,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodIssueCode: () => ZodIssueCode,
  ZodIntersection: () => ZodIntersection,
  ZodFunction: () => ZodFunction,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodError: () => ZodError,
  ZodEnum: () => ZodEnum,
  ZodEffects: () => ZodEffects,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCatch: () => ZodCatch,
  ZodBranded: () => ZodBranded,
  ZodBoolean: () => ZodBoolean,
  ZodBigInt: () => ZodBigInt,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny,
  Schema: () => ZodType,
  ParseStatus: () => ParseStatus,
  OK: () => OK,
  NEVER: () => NEVER,
  INVALID: () => INVALID,
  EMPTY_PATH: () => EMPTY_PATH,
  DIRTY: () => DIRTY,
  BRAND: () => BRAND
});
var init_external = __esm(() => {
  init_errors();
  init_parseUtil();
  init_typeAliases();
  init_util();
  init_types();
  init_ZodError();
});

// node_modules/zod/index.js
var init_zod = __esm(() => {
  init_external();
  init_external();
});

// node_modules/picocolors/picocolors.js
var require_picocolors = __commonJS((exports, module) => {
  var p = process || {};
  var argv = p.argv || [];
  var env = p.env || {};
  var isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
  var formatter = (open, close, replace = open) => (input) => {
    let string = "" + input, index = string.indexOf(close, open.length);
    return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
  };
  var replaceClose = (string, close, replace, index) => {
    let result = "", cursor = 0;
    do {
      result += string.substring(cursor, index) + replace;
      cursor = index + close.length;
      index = string.indexOf(close, cursor);
    } while (~index);
    return result + string.substring(cursor);
  };
  var createColors = (enabled = isColorSupported) => {
    let f = enabled ? formatter : () => String;
    return {
      isColorSupported: enabled,
      reset: f("\x1B[0m", "\x1B[0m"),
      bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
      dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
      italic: f("\x1B[3m", "\x1B[23m"),
      underline: f("\x1B[4m", "\x1B[24m"),
      inverse: f("\x1B[7m", "\x1B[27m"),
      hidden: f("\x1B[8m", "\x1B[28m"),
      strikethrough: f("\x1B[9m", "\x1B[29m"),
      black: f("\x1B[30m", "\x1B[39m"),
      red: f("\x1B[31m", "\x1B[39m"),
      green: f("\x1B[32m", "\x1B[39m"),
      yellow: f("\x1B[33m", "\x1B[39m"),
      blue: f("\x1B[34m", "\x1B[39m"),
      magenta: f("\x1B[35m", "\x1B[39m"),
      cyan: f("\x1B[36m", "\x1B[39m"),
      white: f("\x1B[37m", "\x1B[39m"),
      gray: f("\x1B[90m", "\x1B[39m"),
      bgBlack: f("\x1B[40m", "\x1B[49m"),
      bgRed: f("\x1B[41m", "\x1B[49m"),
      bgGreen: f("\x1B[42m", "\x1B[49m"),
      bgYellow: f("\x1B[43m", "\x1B[49m"),
      bgBlue: f("\x1B[44m", "\x1B[49m"),
      bgMagenta: f("\x1B[45m", "\x1B[49m"),
      bgCyan: f("\x1B[46m", "\x1B[49m"),
      bgWhite: f("\x1B[47m", "\x1B[49m"),
      blackBright: f("\x1B[90m", "\x1B[39m"),
      redBright: f("\x1B[91m", "\x1B[39m"),
      greenBright: f("\x1B[92m", "\x1B[39m"),
      yellowBright: f("\x1B[93m", "\x1B[39m"),
      blueBright: f("\x1B[94m", "\x1B[39m"),
      magentaBright: f("\x1B[95m", "\x1B[39m"),
      cyanBright: f("\x1B[96m", "\x1B[39m"),
      whiteBright: f("\x1B[97m", "\x1B[39m"),
      bgBlackBright: f("\x1B[100m", "\x1B[49m"),
      bgRedBright: f("\x1B[101m", "\x1B[49m"),
      bgGreenBright: f("\x1B[102m", "\x1B[49m"),
      bgYellowBright: f("\x1B[103m", "\x1B[49m"),
      bgBlueBright: f("\x1B[104m", "\x1B[49m"),
      bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
      bgCyanBright: f("\x1B[106m", "\x1B[49m"),
      bgWhiteBright: f("\x1B[107m", "\x1B[49m")
    };
  };
  module.exports = createColors();
  module.exports.createColors = createColors;
});

// src/shared/terminal-utils.ts
function supportsUnicode() {
  if (process.env.WT_SESSION)
    return true;
  if (process.env.TERM_PROGRAM === "iTerm.app")
    return true;
  if (process.env.TERM_PROGRAM === "Apple_Terminal")
    return true;
  if (process.env.TERM_PROGRAM === "vscode")
    return true;
  if (process.env.KONSOLE_VERSION)
    return true;
  if (process.env.CI)
    return true;
  if (process.env.TERM === "dumb")
    return false;
  if (!process.stdout.isTTY)
    return false;
  const locale = process.env.LANG || process.env.LC_ALL || "";
  if (locale.toLowerCase().includes("utf"))
    return true;
  if (process.platform === "win32")
    return false;
  return true;
}
function isTTY() {
  return process.stdout.isTTY === true;
}
var import_picocolors, COLOR_PALETTE;
var init_terminal_utils = __esm(() => {
  import_picocolors = __toESM(require_picocolors(), 1);
  init_output_manager();
  COLOR_PALETTE = {
    pass: import_picocolors.default.green,
    warn: import_picocolors.default.yellow,
    fail: import_picocolors.default.red,
    info: import_picocolors.default.blue,
    muted: import_picocolors.default.dim,
    heading: import_picocolors.default.bold
  };
});

// src/shared/output-manager.ts
function getStatusSymbols() {
  const symbolSet = supportsUnicode() ? SYMBOLS.unicode : SYMBOLS.ascii;
  return {
    pass: symbolSet.pass,
    warn: symbolSet.warn,
    fail: symbolSet.fail,
    info: symbolSet.infoStatus
  };
}

class OutputManager {
  config = {
    verbose: false,
    json: false,
    quiet: false
  };
  jsonBuffer = [];
  unicodeSupported;
  flushPromise = null;
  flushQueued = false;
  constructor() {
    this.unicodeSupported = supportsUnicode();
  }
  configure(config) {
    this.config = { ...this.config, ...config };
  }
  getConfig() {
    return { ...this.config };
  }
  isVerbose() {
    return this.config.verbose;
  }
  isJson() {
    return this.config.json;
  }
  isQuiet() {
    return this.config.quiet;
  }
  getSymbols() {
    return this.unicodeSupported ? SYMBOLS.unicode : SYMBOLS.ascii;
  }
  shouldShowProgress() {
    if (this.config.json)
      return false;
    if (!isTTY())
      return false;
    return true;
  }
  success(message, data) {
    if (this.config.json) {
      this.addJsonEntry({ type: "success", message, data });
      return;
    }
    if (this.config.quiet)
      return;
    const symbol = this.getSymbols().success;
    console.log(import_picocolors2.default.green(`${symbol} ${message}`));
  }
  error(message, data) {
    if (this.config.json) {
      this.addJsonEntry({ type: "error", message, data });
      return;
    }
    const symbol = this.getSymbols().error;
    console.error(import_picocolors2.default.red(`${symbol} ${message}`));
  }
  warning(message, data) {
    if (this.config.json) {
      this.addJsonEntry({ type: "warning", message, data });
      return;
    }
    if (this.config.quiet)
      return;
    const symbol = this.getSymbols().warning;
    console.log(import_picocolors2.default.yellow(`${symbol} ${message}`));
  }
  info(message, data) {
    if (this.config.json) {
      this.addJsonEntry({ type: "info", message, data });
      return;
    }
    if (this.config.quiet)
      return;
    const symbol = this.getSymbols().info;
    console.log(import_picocolors2.default.blue(`${symbol} ${message}`));
  }
  verbose(message, data) {
    if (!this.config.verbose)
      return;
    if (this.config.json) {
      this.addJsonEntry({ type: "info", message, data });
      return;
    }
    console.log(import_picocolors2.default.dim(`  ${message}`));
  }
  indent(message) {
    if (this.config.json)
      return;
    if (this.config.quiet)
      return;
    console.log(`  ${message}`);
  }
  newline() {
    if (this.config.json)
      return;
    if (this.config.quiet)
      return;
    console.log();
  }
  section(title) {
    if (this.config.json) {
      this.addJsonEntry({ type: "info", message: `[Section] ${title}` });
      return;
    }
    if (this.config.quiet)
      return;
    const symbols = this.getSymbols();
    console.log();
    console.log(import_picocolors2.default.bold(import_picocolors2.default.cyan(`${symbols.line} ${title}`)));
  }
  addJsonEntry(entry) {
    this.jsonBuffer.push({
      ...entry,
      timestamp: new Date().toISOString()
    });
    if (this.jsonBuffer.length >= 1000 && !this.flushPromise && !this.flushQueued) {
      this.flushQueued = true;
      queueMicrotask(() => {
        this.flushQueued = false;
        this.flushJson();
      });
    }
  }
  addJsonResult(data) {
    this.addJsonEntry({ type: "result", data });
  }
  async flushJson() {
    if (this.jsonBuffer.length === 0)
      return;
    if (this.flushPromise)
      return this.flushPromise;
    this.flushPromise = (async () => {
      const bufferCopy = [...this.jsonBuffer];
      this.jsonBuffer = [];
      console.log(JSON.stringify(bufferCopy, null, 2));
    })().finally(() => {
      this.flushPromise = null;
    });
    return this.flushPromise;
  }
  getJsonBuffer() {
    return [...this.jsonBuffer];
  }
  clearJsonBuffer() {
    this.jsonBuffer = [];
  }
  reset() {
    this.config = { verbose: false, json: false, quiet: false };
    this.jsonBuffer = [];
    this.flushPromise = null;
    this.flushQueued = false;
    this.unicodeSupported = supportsUnicode();
  }
}
var import_picocolors2, SYMBOLS, output;
var init_output_manager = __esm(() => {
  import_picocolors2 = __toESM(require_picocolors(), 1);
  init_terminal_utils();
  SYMBOLS = {
    unicode: {
      prompt: "",
      success: "",
      error: "",
      warning: "",
      info: "",
      line: "",
      selected: "",
      unselected: "",
      pointer: ">",
      pass: "",
      warn: "",
      fail: "",
      infoStatus: ""
    },
    ascii: {
      prompt: "?",
      success: "+",
      error: "x",
      warning: "!",
      info: "i",
      line: "|",
      selected: ">",
      unselected: " ",
      pointer: ">",
      pass: "[PASS]",
      warn: "[WARN]",
      fail: "[FAIL]",
      infoStatus: "[INFO]"
    }
  };
  output = new OutputManager;
});

// src/shared/logger.ts
import { createWriteStream } from "node:fs";

class Logger {
  verboseEnabled = false;
  logFileStream;
  exitHandlerRegistered = false;
  info(message) {
    const symbols = output.getSymbols();
    console.log(import_picocolors3.default.blue(symbols.info), message);
  }
  success(message) {
    const symbols = output.getSymbols();
    console.log(import_picocolors3.default.green(symbols.success), message);
  }
  warning(message) {
    const symbols = output.getSymbols();
    console.log(import_picocolors3.default.yellow(symbols.warning), message);
  }
  error(message) {
    const symbols = output.getSymbols();
    console.error(import_picocolors3.default.red(symbols.error), message);
  }
  debug(message) {
    if (process.env.DEBUG) {
      console.log(import_picocolors3.default.gray("[DEBUG]"), message);
    }
  }
  verbose(message, context) {
    if (!this.verboseEnabled)
      return;
    const timestamp = this.getTimestamp();
    const sanitizedMessage = this.sanitize(message);
    const formattedContext = context ? this.formatContext(context) : "";
    const logLine = `${timestamp} ${import_picocolors3.default.gray("[VERBOSE]")} ${sanitizedMessage}${formattedContext}`;
    console.error(logLine);
    if (this.logFileStream) {
      const plainLogLine = `${timestamp} [VERBOSE] ${sanitizedMessage}${formattedContext}`;
      this.logFileStream.write(`${plainLogLine}
`);
    }
  }
  setVerbose(enabled) {
    this.verboseEnabled = enabled;
    if (enabled) {
      this.verbose("Verbose logging enabled");
    }
  }
  isVerbose() {
    return this.verboseEnabled;
  }
  setLogFile(path) {
    if (this.logFileStream) {
      this.logFileStream.end();
      this.logFileStream = undefined;
    }
    if (path) {
      this.logFileStream = createWriteStream(path, {
        flags: "a",
        mode: 384
      });
      this.registerExitHandler();
      this.verbose(`Logging to file: ${path}`);
    }
  }
  close() {
    if (this.logFileStream) {
      this.logFileStream.end();
      this.logFileStream = undefined;
    }
  }
  registerExitHandler() {
    if (this.exitHandlerRegistered)
      return;
    this.exitHandlerRegistered = true;
    const cleanup = () => {
      if (this.logFileStream) {
        try {
          this.logFileStream.end();
        } catch {}
        this.logFileStream = undefined;
      }
    };
    process.on("exit", cleanup);
    process.on("SIGINT", () => {
      cleanup();
      process.exit(130);
    });
    process.on("SIGTERM", () => {
      cleanup();
      process.exit(143);
    });
    process.on("uncaughtException", (error) => {
      if (this.logFileStream) {
        const timestamp = new Date().toISOString();
        this.logFileStream.write(`${timestamp} [FATAL] Uncaught exception: ${error.message}
`);
        this.logFileStream.write(`${error.stack}
`);
      }
      cleanup();
      process.exit(1);
    });
  }
  sanitize(text) {
    return text.replace(/ghp_[a-zA-Z0-9]{36}/g, "ghp_***").replace(/github_pat_[a-zA-Z0-9_]{82}/g, "github_pat_***").replace(/gho_[a-zA-Z0-9]{36}/g, "gho_***").replace(/ghu_[a-zA-Z0-9]{36}/g, "ghu_***").replace(/ghs_[a-zA-Z0-9]{36}/g, "ghs_***").replace(/ghr_[a-zA-Z0-9]{36}/g, "ghr_***").replace(/Bearer [a-zA-Z0-9_-]+/g, "Bearer ***").replace(/token=[a-zA-Z0-9_-]+/g, "token=***");
  }
  getTimestamp() {
    return new Date().toISOString();
  }
  formatContext(context) {
    const sanitized = Object.entries(context).reduce((acc, [key, value]) => {
      if (typeof value === "string") {
        acc[key] = this.sanitize(value);
      } else if (value && typeof value === "object") {
        try {
          const stringified = JSON.stringify(value);
          const sanitizedStr = this.sanitize(stringified);
          acc[key] = JSON.parse(sanitizedStr);
        } catch {
          acc[key] = "[Object]";
        }
      } else {
        acc[key] = value;
      }
      return acc;
    }, {});
    return `
  ${JSON.stringify(sanitized, null, 2).split(`
`).join(`
  `)}`;
  }
}
var import_picocolors3, logger;
var init_logger = __esm(() => {
  import_picocolors3 = __toESM(require_picocolors(), 1);
  init_output_manager();
  logger = new Logger;
});

// src/shared/path-resolver.ts
import { existsSync as existsSync2, readFileSync as readFileSync3 } from "node:fs";
import { homedir, platform } from "node:os";
import { join, normalize } from "node:path";
function isWSL2() {
  try {
    return process.platform === "linux" && existsSync2("/proc/version") && readFileSync3("/proc/version", "utf8").toLowerCase().includes("microsoft");
  } catch {
    return false;
  }
}
function normalizeWSLPath(p) {
  if (!isWSL2())
    return p;
  const windowsMatch = p.match(/^([A-Za-z]):(.*)/);
  if (windowsMatch) {
    const drive = windowsMatch[1].toLowerCase();
    const rest = windowsMatch[2].replace(/\\/g, "/");
    return `/mnt/${drive}${rest}`;
  }
  return p;
}

class PathResolver {
  static getTestHomeDir() {
    return process.env.CK_TEST_HOME;
  }
  static isValidComponentName(name) {
    if (!name || typeof name !== "string") {
      return false;
    }
    const dangerousPatterns = [
      "..",
      "~"
    ];
    for (const pattern of dangerousPatterns) {
      if (name.includes(pattern)) {
        return false;
      }
    }
    const normalized = normalize(name);
    for (const pattern of dangerousPatterns) {
      if (normalized.includes(pattern)) {
        return false;
      }
    }
    if (name.startsWith("/") || normalized.startsWith("/") || /^[a-zA-Z]:/.test(name)) {
      return false;
    }
    return true;
  }
  static getConfigDir(global2 = false) {
    const testHome = PathResolver.getTestHomeDir();
    if (testHome) {
      return global2 ? join(testHome, ".config", "claude") : join(testHome, ".claudekit");
    }
    if (!global2) {
      return join(homedir(), ".claudekit");
    }
    const os = platform();
    if (os === "win32") {
      const localAppData = process.env.LOCALAPPDATA || join(homedir(), "AppData", "Local");
      return join(localAppData, "claude");
    }
    const xdgConfigHome = process.env.XDG_CONFIG_HOME;
    if (xdgConfigHome) {
      return join(xdgConfigHome, "claude");
    }
    return join(homedir(), ".config", "claude");
  }
  static getConfigFile(global2 = false) {
    return join(PathResolver.getConfigDir(global2), "config.json");
  }
  static getCacheDir(global2 = false) {
    const testHome = PathResolver.getTestHomeDir();
    if (testHome) {
      return global2 ? join(testHome, ".cache", "claude") : join(testHome, ".claudekit", "cache");
    }
    if (!global2) {
      return join(homedir(), ".claudekit", "cache");
    }
    const os = platform();
    if (os === "win32") {
      const localAppData = process.env.LOCALAPPDATA || join(homedir(), "AppData", "Local");
      return join(localAppData, "claude", "cache");
    }
    const xdgCacheHome = process.env.XDG_CACHE_HOME;
    if (xdgCacheHome) {
      return join(xdgCacheHome, "claude");
    }
    return join(homedir(), ".cache", "claude");
  }
  static getGlobalKitDir() {
    const testHome = PathResolver.getTestHomeDir();
    if (testHome) {
      return join(testHome, ".claude");
    }
    return join(homedir(), ".claude");
  }
  static getOpenCodeDir(global2, baseDir) {
    const testHome = PathResolver.getTestHomeDir();
    if (testHome) {
      return global2 ? join(testHome, ".config", "opencode") : join(baseDir || testHome, ".opencode");
    }
    if (!global2) {
      return join(baseDir || process.cwd(), ".opencode");
    }
    const xdgConfigHome = process.env.XDG_CONFIG_HOME;
    if (xdgConfigHome) {
      return join(xdgConfigHome, "opencode");
    }
    return join(homedir(), ".config", "opencode");
  }
  static getPathPrefix(global2) {
    return global2 ? "" : ".claude";
  }
  static buildSkillsPath(baseDir, global2) {
    const prefix = PathResolver.getPathPrefix(global2);
    if (prefix) {
      return join(baseDir, prefix, "skills");
    }
    return join(baseDir, "skills");
  }
  static buildComponentPath(baseDir, component, global2) {
    if (!PathResolver.isValidComponentName(component)) {
      throw new Error(`Invalid component name: "${component}" contains path traversal patterns. Valid names are simple directory names like "agents", "commands", "rules", "skills", or "hooks".`);
    }
    const prefix = PathResolver.getPathPrefix(global2);
    if (prefix) {
      return join(baseDir, prefix, component);
    }
    return join(baseDir, component);
  }
  static getBackupDir(timestamp) {
    const testHome = PathResolver.getTestHomeDir();
    const baseDir = testHome ? join(testHome, ".claudekit") : join(homedir(), ".claudekit");
    if (timestamp) {
      return join(baseDir, "backups", timestamp);
    }
    const now = new Date;
    const dateStr = now.toISOString().replace(/[:.]/g, "-").slice(0, 19);
    const ms = now.getMilliseconds().toString().padStart(3, "0");
    const random = Math.random().toString(36).slice(2, 6);
    const ts = `${dateStr}-${ms}-${random}`;
    return join(baseDir, "backups", ts);
  }
  static normalizeWSLPath(p) {
    return normalizeWSLPath(p);
  }
  static isWSL() {
    return isWSL2();
  }
  static isAtHomeDirectory(cwd) {
    const currentDir = normalize(cwd || process.cwd());
    const homeDir = normalize(homedir());
    return currentDir === homeDir;
  }
  static getLocalClaudeDir(baseDir) {
    const dir = baseDir || process.cwd();
    return join(dir, ".claude");
  }
  static isLocalSameAsGlobal(cwd) {
    const localPath = normalize(PathResolver.getLocalClaudeDir(cwd));
    const globalPath = normalize(PathResolver.getGlobalKitDir());
    return localPath === globalPath;
  }
}
var init_path_resolver = () => {};

// node_modules/universalify/index.js
var require_universalify = __commonJS((exports) => {
  exports.fromCallback = function(fn) {
    return Object.defineProperty(function(...args) {
      if (typeof args[args.length - 1] === "function")
        fn.apply(this, args);
      else {
        return new Promise((resolve, reject) => {
          args.push((err, res) => err != null ? reject(err) : resolve(res));
          fn.apply(this, args);
        });
      }
    }, "name", { value: fn.name });
  };
  exports.fromPromise = function(fn) {
    return Object.defineProperty(function(...args) {
      const cb = args[args.length - 1];
      if (typeof cb !== "function")
        return fn.apply(this, args);
      else {
        args.pop();
        fn.apply(this, args).then((r) => cb(null, r), cb);
      }
    }, "name", { value: fn.name });
  };
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS((exports, module) => {
  var constants = __require("constants");
  var origCwd = process.cwd;
  var cwd = null;
  var platform2 = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    if (!cwd)
      cwd = origCwd.call(process);
    return cwd;
  };
  try {
    process.cwd();
  } catch (er) {}
  if (typeof process.chdir === "function") {
    chdir = process.chdir;
    process.chdir = function(d) {
      cwd = null;
      chdir.call(process, d);
    };
    if (Object.setPrototypeOf)
      Object.setPrototypeOf(process.chdir, chdir);
  }
  var chdir;
  module.exports = patch;
  function patch(fs2) {
    if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
      patchLchmod(fs2);
    }
    if (!fs2.lutimes) {
      patchLutimes(fs2);
    }
    fs2.chown = chownFix(fs2.chown);
    fs2.fchown = chownFix(fs2.fchown);
    fs2.lchown = chownFix(fs2.lchown);
    fs2.chmod = chmodFix(fs2.chmod);
    fs2.fchmod = chmodFix(fs2.fchmod);
    fs2.lchmod = chmodFix(fs2.lchmod);
    fs2.chownSync = chownFixSync(fs2.chownSync);
    fs2.fchownSync = chownFixSync(fs2.fchownSync);
    fs2.lchownSync = chownFixSync(fs2.lchownSync);
    fs2.chmodSync = chmodFixSync(fs2.chmodSync);
    fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
    fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
    fs2.stat = statFix(fs2.stat);
    fs2.fstat = statFix(fs2.fstat);
    fs2.lstat = statFix(fs2.lstat);
    fs2.statSync = statFixSync(fs2.statSync);
    fs2.fstatSync = statFixSync(fs2.fstatSync);
    fs2.lstatSync = statFixSync(fs2.lstatSync);
    if (fs2.chmod && !fs2.lchmod) {
      fs2.lchmod = function(path, mode, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs2.lchmodSync = function() {};
    }
    if (fs2.chown && !fs2.lchown) {
      fs2.lchown = function(path, uid, gid, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs2.lchownSync = function() {};
    }
    if (platform2 === "win32") {
      fs2.rename = typeof fs2.rename !== "function" ? fs2.rename : function(fs$rename) {
        function rename(from, to, cb) {
          var start = Date.now();
          var backoff = 0;
          fs$rename(from, to, function CB(er) {
            if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 60000) {
              setTimeout(function() {
                fs2.stat(to, function(stater, st) {
                  if (stater && stater.code === "ENOENT")
                    fs$rename(from, to, CB);
                  else
                    cb(er);
                });
              }, backoff);
              if (backoff < 100)
                backoff += 10;
              return;
            }
            if (cb)
              cb(er);
          });
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(rename, fs$rename);
        return rename;
      }(fs2.rename);
    }
    fs2.read = typeof fs2.read !== "function" ? fs2.read : function(fs$read) {
      function read(fd, buffer, offset, length, position, callback_) {
        var callback;
        if (callback_ && typeof callback_ === "function") {
          var eagCounter = 0;
          callback = function(er, _, __) {
            if (er && er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
            }
            callback_.apply(this, arguments);
          };
        }
        return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
      }
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(read, fs$read);
      return read;
    }(fs2.read);
    fs2.readSync = typeof fs2.readSync !== "function" ? fs2.readSync : function(fs$readSync) {
      return function(fd, buffer, offset, length, position) {
        var eagCounter = 0;
        while (true) {
          try {
            return fs$readSync.call(fs2, fd, buffer, offset, length, position);
          } catch (er) {
            if (er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              continue;
            }
            throw er;
          }
        }
      };
    }(fs2.readSync);
    function patchLchmod(fs3) {
      fs3.lchmod = function(path, mode, callback) {
        fs3.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
          if (err) {
            if (callback)
              callback(err);
            return;
          }
          fs3.fchmod(fd, mode, function(err2) {
            fs3.close(fd, function(err22) {
              if (callback)
                callback(err2 || err22);
            });
          });
        });
      };
      fs3.lchmodSync = function(path, mode) {
        var fd = fs3.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
        var threw = true;
        var ret;
        try {
          ret = fs3.fchmodSync(fd, mode);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs3.closeSync(fd);
            } catch (er) {}
          } else {
            fs3.closeSync(fd);
          }
        }
        return ret;
      };
    }
    function patchLutimes(fs3) {
      if (constants.hasOwnProperty("O_SYMLINK") && fs3.futimes) {
        fs3.lutimes = function(path, at, mt, cb) {
          fs3.open(path, constants.O_SYMLINK, function(er, fd) {
            if (er) {
              if (cb)
                cb(er);
              return;
            }
            fs3.futimes(fd, at, mt, function(er2) {
              fs3.close(fd, function(er22) {
                if (cb)
                  cb(er2 || er22);
              });
            });
          });
        };
        fs3.lutimesSync = function(path, at, mt) {
          var fd = fs3.openSync(path, constants.O_SYMLINK);
          var ret;
          var threw = true;
          try {
            ret = fs3.futimesSync(fd, at, mt);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs3.closeSync(fd);
              } catch (er) {}
            } else {
              fs3.closeSync(fd);
            }
          }
          return ret;
        };
      } else if (fs3.futimes) {
        fs3.lutimes = function(_a, _b, _c, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs3.lutimesSync = function() {};
      }
    }
    function chmodFix(orig) {
      if (!orig)
        return orig;
      return function(target, mode, cb) {
        return orig.call(fs2, target, mode, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chmodFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, mode) {
        try {
          return orig.call(fs2, target, mode);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function chownFix(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid, cb) {
        return orig.call(fs2, target, uid, gid, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chownFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid) {
        try {
          return orig.call(fs2, target, uid, gid);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function statFix(orig) {
      if (!orig)
        return orig;
      return function(target, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = null;
        }
        function callback(er, stats) {
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          if (cb)
            cb.apply(this, arguments);
        }
        return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);
      };
    }
    function statFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, options) {
        var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);
        if (stats) {
          if (stats.uid < 0)
            stats.uid += 4294967296;
          if (stats.gid < 0)
            stats.gid += 4294967296;
        }
        return stats;
      };
    }
    function chownErOk(er) {
      if (!er)
        return true;
      if (er.code === "ENOSYS")
        return true;
      var nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (er.code === "EINVAL" || er.code === "EPERM")
          return true;
      }
      return false;
    }
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS((exports, module) => {
  var Stream = __require("stream").Stream;
  module.exports = legacy;
  function legacy(fs2) {
    return {
      ReadStream,
      WriteStream
    };
    function ReadStream(path, options) {
      if (!(this instanceof ReadStream))
        return new ReadStream(path, options);
      Stream.call(this);
      var self2 = this;
      this.path = path;
      this.fd = null;
      this.readable = true;
      this.paused = false;
      this.flags = "r";
      this.mode = 438;
      this.bufferSize = 64 * 1024;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length;index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.encoding)
        this.setEncoding(this.encoding);
      if (this.start !== undefined) {
        if (typeof this.start !== "number") {
          throw TypeError("start must be a Number");
        }
        if (this.end === undefined) {
          this.end = Infinity;
        } else if (typeof this.end !== "number") {
          throw TypeError("end must be a Number");
        }
        if (this.start > this.end) {
          throw new Error("start must be <= end");
        }
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          self2._read();
        });
        return;
      }
      fs2.open(this.path, this.flags, this.mode, function(err, fd) {
        if (err) {
          self2.emit("error", err);
          self2.readable = false;
          return;
        }
        self2.fd = fd;
        self2.emit("open", fd);
        self2._read();
      });
    }
    function WriteStream(path, options) {
      if (!(this instanceof WriteStream))
        return new WriteStream(path, options);
      Stream.call(this);
      this.path = path;
      this.fd = null;
      this.writable = true;
      this.flags = "w";
      this.encoding = "binary";
      this.mode = 438;
      this.bytesWritten = 0;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length;index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.start !== undefined) {
        if (typeof this.start !== "number") {
          throw TypeError("start must be a Number");
        }
        if (this.start < 0) {
          throw new Error("start must be >= zero");
        }
        this.pos = this.start;
      }
      this.busy = false;
      this._queue = [];
      if (this.fd === null) {
        this._open = fs2.open;
        this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
        this.flush();
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS((exports, module) => {
  module.exports = clone;
  var getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
  };
  function clone(obj) {
    if (obj === null || typeof obj !== "object")
      return obj;
    if (obj instanceof Object)
      var copy = { __proto__: getPrototypeOf(obj) };
    else
      var copy = Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function(key) {
      Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy;
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS((exports, module) => {
  var fs2 = __require("fs");
  var polyfills = require_polyfills();
  var legacy = require_legacy_streams();
  var clone = require_clone();
  var util3 = __require("util");
  var gracefulQueue;
  var previousSymbol;
  if (typeof Symbol === "function" && typeof Symbol.for === "function") {
    gracefulQueue = Symbol.for("graceful-fs.queue");
    previousSymbol = Symbol.for("graceful-fs.previous");
  } else {
    gracefulQueue = "___graceful-fs.queue";
    previousSymbol = "___graceful-fs.previous";
  }
  function noop() {}
  function publishQueue(context, queue2) {
    Object.defineProperty(context, gracefulQueue, {
      get: function() {
        return queue2;
      }
    });
  }
  var debug = noop;
  if (util3.debuglog)
    debug = util3.debuglog("gfs4");
  else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
    debug = function() {
      var m = util3.format.apply(util3, arguments);
      m = "GFS4: " + m.split(/\n/).join(`
GFS4: `);
      console.error(m);
    };
  if (!fs2[gracefulQueue]) {
    queue = global[gracefulQueue] || [];
    publishQueue(fs2, queue);
    fs2.close = function(fs$close) {
      function close(fd, cb) {
        return fs$close.call(fs2, fd, function(err) {
          if (!err) {
            resetQueue();
          }
          if (typeof cb === "function")
            cb.apply(this, arguments);
        });
      }
      Object.defineProperty(close, previousSymbol, {
        value: fs$close
      });
      return close;
    }(fs2.close);
    fs2.closeSync = function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs2, arguments);
        resetQueue();
      }
      Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      });
      return closeSync;
    }(fs2.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
      process.on("exit", function() {
        debug(fs2[gracefulQueue]);
        __require("assert").equal(fs2[gracefulQueue].length, 0);
      });
    }
  }
  var queue;
  if (!global[gracefulQueue]) {
    publishQueue(global, fs2[gracefulQueue]);
  }
  module.exports = patch(clone(fs2));
  if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs2.__patched) {
    module.exports = patch(fs2);
    fs2.__patched = true;
  }
  function patch(fs3) {
    polyfills(fs3);
    fs3.gracefulify = patch;
    fs3.createReadStream = createReadStream;
    fs3.createWriteStream = createWriteStream2;
    var fs$readFile = fs3.readFile;
    fs3.readFile = readFile;
    function readFile(path, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$readFile(path, options, cb);
      function go$readFile(path2, options2, cb2, startTime) {
        return fs$readFile(path2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$readFile, [path2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$writeFile = fs3.writeFile;
    fs3.writeFile = writeFile;
    function writeFile(path, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$writeFile(path, data, options, cb);
      function go$writeFile(path2, data2, options2, cb2, startTime) {
        return fs$writeFile(path2, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$writeFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$appendFile = fs3.appendFile;
    if (fs$appendFile)
      fs3.appendFile = appendFile;
    function appendFile(path, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$appendFile(path, data, options, cb);
      function go$appendFile(path2, data2, options2, cb2, startTime) {
        return fs$appendFile(path2, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$appendFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$copyFile = fs3.copyFile;
    if (fs$copyFile)
      fs3.copyFile = copyFile;
    function copyFile(src, dest, flags, cb) {
      if (typeof flags === "function") {
        cb = flags;
        flags = 0;
      }
      return go$copyFile(src, dest, flags, cb);
      function go$copyFile(src2, dest2, flags2, cb2, startTime) {
        return fs$copyFile(src2, dest2, flags2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$readdir = fs3.readdir;
    fs3.readdir = readdir;
    var noReaddirOptionVersions = /^v[0-5]\./;
    function readdir(path, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir(path2, options2, cb2, startTime) {
        return fs$readdir(path2, fs$readdirCallback(path2, options2, cb2, startTime));
      } : function go$readdir(path2, options2, cb2, startTime) {
        return fs$readdir(path2, options2, fs$readdirCallback(path2, options2, cb2, startTime));
      };
      return go$readdir(path, options, cb);
      function fs$readdirCallback(path2, options2, cb2, startTime) {
        return function(err, files) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([
              go$readdir,
              [path2, options2, cb2],
              err,
              startTime || Date.now(),
              Date.now()
            ]);
          else {
            if (files && files.sort)
              files.sort();
            if (typeof cb2 === "function")
              cb2.call(this, err, files);
          }
        };
      }
    }
    if (process.version.substr(0, 4) === "v0.8") {
      var legStreams = legacy(fs3);
      ReadStream = legStreams.ReadStream;
      WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs3.ReadStream;
    if (fs$ReadStream) {
      ReadStream.prototype = Object.create(fs$ReadStream.prototype);
      ReadStream.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs3.WriteStream;
    if (fs$WriteStream) {
      WriteStream.prototype = Object.create(fs$WriteStream.prototype);
      WriteStream.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs3, "ReadStream", {
      get: function() {
        return ReadStream;
      },
      set: function(val) {
        ReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(fs3, "WriteStream", {
      get: function() {
        return WriteStream;
      },
      set: function(val) {
        WriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileReadStream = ReadStream;
    Object.defineProperty(fs3, "FileReadStream", {
      get: function() {
        return FileReadStream;
      },
      set: function(val) {
        FileReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs3, "FileWriteStream", {
      get: function() {
        return FileWriteStream;
      },
      set: function(val) {
        FileWriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    function ReadStream(path, options) {
      if (this instanceof ReadStream)
        return fs$ReadStream.apply(this, arguments), this;
      else
        return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          if (that.autoClose)
            that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
          that.read();
        }
      });
    }
    function WriteStream(path, options) {
      if (this instanceof WriteStream)
        return fs$WriteStream.apply(this, arguments), this;
      else
        return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
        }
      });
    }
    function createReadStream(path, options) {
      return new fs3.ReadStream(path, options);
    }
    function createWriteStream2(path, options) {
      return new fs3.WriteStream(path, options);
    }
    var fs$open = fs3.open;
    fs3.open = open;
    function open(path, flags, mode, cb) {
      if (typeof mode === "function")
        cb = mode, mode = null;
      return go$open(path, flags, mode, cb);
      function go$open(path2, flags2, mode2, cb2, startTime) {
        return fs$open(path2, flags2, mode2, function(err, fd) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$open, [path2, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    return fs3;
  }
  function enqueue(elem) {
    debug("ENQUEUE", elem[0].name, elem[1]);
    fs2[gracefulQueue].push(elem);
    retry();
  }
  var retryTimer;
  function resetQueue() {
    var now = Date.now();
    for (var i = 0;i < fs2[gracefulQueue].length; ++i) {
      if (fs2[gracefulQueue][i].length > 2) {
        fs2[gracefulQueue][i][3] = now;
        fs2[gracefulQueue][i][4] = now;
      }
    }
    retry();
  }
  function retry() {
    clearTimeout(retryTimer);
    retryTimer = undefined;
    if (fs2[gracefulQueue].length === 0)
      return;
    var elem = fs2[gracefulQueue].shift();
    var fn = elem[0];
    var args = elem[1];
    var err = elem[2];
    var startTime = elem[3];
    var lastTime = elem[4];
    if (startTime === undefined) {
      debug("RETRY", fn.name, args);
      fn.apply(null, args);
    } else if (Date.now() - startTime >= 60000) {
      debug("TIMEOUT", fn.name, args);
      var cb = args.pop();
      if (typeof cb === "function")
        cb.call(null, err);
    } else {
      var sinceAttempt = Date.now() - lastTime;
      var sinceStart = Math.max(lastTime - startTime, 1);
      var desiredDelay = Math.min(sinceStart * 1.2, 100);
      if (sinceAttempt >= desiredDelay) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args.concat([startTime]));
      } else {
        fs2[gracefulQueue].push(elem);
      }
    }
    if (retryTimer === undefined) {
      retryTimer = setTimeout(retry, 0);
    }
  }
});

// node_modules/fs-extra/lib/fs/index.js
var require_fs = __commonJS((exports) => {
  var u = require_universalify().fromCallback;
  var fs2 = require_graceful_fs();
  var api = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "cp",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "glob",
    "lchmod",
    "lchown",
    "lutimes",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "statfs",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((key) => {
    return typeof fs2[key] === "function";
  });
  Object.assign(exports, fs2);
  api.forEach((method) => {
    exports[method] = u(fs2[method]);
  });
  exports.exists = function(filename, callback) {
    if (typeof callback === "function") {
      return fs2.exists(filename, callback);
    }
    return new Promise((resolve) => {
      return fs2.exists(filename, resolve);
    });
  };
  exports.read = function(fd, buffer, offset, length, position, callback) {
    if (typeof callback === "function") {
      return fs2.read(fd, buffer, offset, length, position, callback);
    }
    return new Promise((resolve, reject) => {
      fs2.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
        if (err)
          return reject(err);
        resolve({ bytesRead, buffer: buffer2 });
      });
    });
  };
  exports.write = function(fd, buffer, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs2.write(fd, buffer, ...args);
    }
    return new Promise((resolve, reject) => {
      fs2.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
        if (err)
          return reject(err);
        resolve({ bytesWritten, buffer: buffer2 });
      });
    });
  };
  exports.readv = function(fd, buffers, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs2.readv(fd, buffers, ...args);
    }
    return new Promise((resolve, reject) => {
      fs2.readv(fd, buffers, ...args, (err, bytesRead, buffers2) => {
        if (err)
          return reject(err);
        resolve({ bytesRead, buffers: buffers2 });
      });
    });
  };
  exports.writev = function(fd, buffers, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs2.writev(fd, buffers, ...args);
    }
    return new Promise((resolve, reject) => {
      fs2.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
        if (err)
          return reject(err);
        resolve({ bytesWritten, buffers: buffers2 });
      });
    });
  };
  if (typeof fs2.realpath.native === "function") {
    exports.realpath.native = u(fs2.realpath.native);
  } else {
    process.emitWarning("fs.realpath.native is not a function. Is fs being monkey-patched?", "Warning", "fs-extra-WARN0003");
  }
});

// node_modules/fs-extra/lib/mkdirs/utils.js
var require_utils = __commonJS((exports, module) => {
  var path = __require("path");
  exports.checkPath = function checkPath(pth) {
    if (process.platform === "win32") {
      const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ""));
      if (pathHasInvalidWinCharacters) {
        const error = new Error(`Path contains invalid characters: ${pth}`);
        error.code = "EINVAL";
        throw error;
      }
    }
  };
});

// node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS((exports, module) => {
  var fs2 = require_fs();
  var { checkPath } = require_utils();
  var getMode = (options) => {
    const defaults = { mode: 511 };
    if (typeof options === "number")
      return options;
    return { ...defaults, ...options }.mode;
  };
  exports.makeDir = async (dir, options) => {
    checkPath(dir);
    return fs2.mkdir(dir, {
      mode: getMode(options),
      recursive: true
    });
  };
  exports.makeDirSync = (dir, options) => {
    checkPath(dir);
    return fs2.mkdirSync(dir, {
      mode: getMode(options),
      recursive: true
    });
  };
});

// node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  var { makeDir: _makeDir, makeDirSync } = require_make_dir();
  var makeDir = u(_makeDir);
  module.exports = {
    mkdirs: makeDir,
    mkdirsSync: makeDirSync,
    mkdirp: makeDir,
    mkdirpSync: makeDirSync,
    ensureDir: makeDir,
    ensureDirSync: makeDirSync
  };
});

// node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  var fs2 = require_fs();
  function pathExists(path) {
    return fs2.access(path).then(() => true).catch(() => false);
  }
  module.exports = {
    pathExists: u(pathExists),
    pathExistsSync: fs2.existsSync
  };
});

// node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS((exports, module) => {
  var fs2 = require_fs();
  var u = require_universalify().fromPromise;
  async function utimesMillis(path, atime, mtime) {
    const fd = await fs2.open(path, "r+");
    let closeErr = null;
    try {
      await fs2.futimes(fd, atime, mtime);
    } finally {
      try {
        await fs2.close(fd);
      } catch (e) {
        closeErr = e;
      }
    }
    if (closeErr) {
      throw closeErr;
    }
  }
  function utimesMillisSync(path, atime, mtime) {
    const fd = fs2.openSync(path, "r+");
    fs2.futimesSync(fd, atime, mtime);
    return fs2.closeSync(fd);
  }
  module.exports = {
    utimesMillis: u(utimesMillis),
    utimesMillisSync
  };
});

// node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS((exports, module) => {
  var fs2 = require_fs();
  var path = __require("path");
  var u = require_universalify().fromPromise;
  function getStats(src, dest, opts) {
    const statFunc = opts.dereference ? (file) => fs2.stat(file, { bigint: true }) : (file) => fs2.lstat(file, { bigint: true });
    return Promise.all([
      statFunc(src),
      statFunc(dest).catch((err) => {
        if (err.code === "ENOENT")
          return null;
        throw err;
      })
    ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
  }
  function getStatsSync(src, dest, opts) {
    let destStat;
    const statFunc = opts.dereference ? (file) => fs2.statSync(file, { bigint: true }) : (file) => fs2.lstatSync(file, { bigint: true });
    const srcStat = statFunc(src);
    try {
      destStat = statFunc(dest);
    } catch (err) {
      if (err.code === "ENOENT")
        return { srcStat, destStat: null };
      throw err;
    }
    return { srcStat, destStat };
  }
  async function checkPaths(src, dest, funcName, opts) {
    const { srcStat, destStat } = await getStats(src, dest, opts);
    if (destStat) {
      if (areIdentical(srcStat, destStat)) {
        const srcBaseName = path.basename(src);
        const destBaseName = path.basename(dest);
        if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
          return { srcStat, destStat, isChangingCase: true };
        }
        throw new Error("Source and destination must not be the same.");
      }
      if (srcStat.isDirectory() && !destStat.isDirectory()) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
      }
      if (!srcStat.isDirectory() && destStat.isDirectory()) {
        throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
      }
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return { srcStat, destStat };
  }
  function checkPathsSync(src, dest, funcName, opts) {
    const { srcStat, destStat } = getStatsSync(src, dest, opts);
    if (destStat) {
      if (areIdentical(srcStat, destStat)) {
        const srcBaseName = path.basename(src);
        const destBaseName = path.basename(dest);
        if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
          return { srcStat, destStat, isChangingCase: true };
        }
        throw new Error("Source and destination must not be the same.");
      }
      if (srcStat.isDirectory() && !destStat.isDirectory()) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
      }
      if (!srcStat.isDirectory() && destStat.isDirectory()) {
        throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
      }
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return { srcStat, destStat };
  }
  async function checkParentPaths(src, srcStat, dest, funcName) {
    const srcParent = path.resolve(path.dirname(src));
    const destParent = path.resolve(path.dirname(dest));
    if (destParent === srcParent || destParent === path.parse(destParent).root)
      return;
    let destStat;
    try {
      destStat = await fs2.stat(destParent, { bigint: true });
    } catch (err) {
      if (err.code === "ENOENT")
        return;
      throw err;
    }
    if (areIdentical(srcStat, destStat)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return checkParentPaths(src, srcStat, destParent, funcName);
  }
  function checkParentPathsSync(src, srcStat, dest, funcName) {
    const srcParent = path.resolve(path.dirname(src));
    const destParent = path.resolve(path.dirname(dest));
    if (destParent === srcParent || destParent === path.parse(destParent).root)
      return;
    let destStat;
    try {
      destStat = fs2.statSync(destParent, { bigint: true });
    } catch (err) {
      if (err.code === "ENOENT")
        return;
      throw err;
    }
    if (areIdentical(srcStat, destStat)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return checkParentPathsSync(src, srcStat, destParent, funcName);
  }
  function areIdentical(srcStat, destStat) {
    return destStat.ino !== undefined && destStat.dev !== undefined && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
  }
  function isSrcSubdir(src, dest) {
    const srcArr = path.resolve(src).split(path.sep).filter((i) => i);
    const destArr = path.resolve(dest).split(path.sep).filter((i) => i);
    return srcArr.every((cur, i) => destArr[i] === cur);
  }
  function errMsg(src, dest, funcName) {
    return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
  }
  module.exports = {
    checkPaths: u(checkPaths),
    checkPathsSync,
    checkParentPaths: u(checkParentPaths),
    checkParentPathsSync,
    isSrcSubdir,
    areIdentical
  };
});

// node_modules/fs-extra/lib/util/async.js
var require_async = __commonJS((exports, module) => {
  async function asyncIteratorConcurrentProcess(iterator, fn) {
    const promises = [];
    for await (const item of iterator) {
      promises.push(fn(item).then(() => null, (err) => err ?? new Error("unknown error")));
    }
    await Promise.all(promises.map((promise) => promise.then((possibleErr) => {
      if (possibleErr !== null)
        throw possibleErr;
    })));
  }
  module.exports = {
    asyncIteratorConcurrentProcess
  };
});

// node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS((exports, module) => {
  var fs2 = require_fs();
  var path = __require("path");
  var { mkdirs } = require_mkdirs();
  var { pathExists } = require_path_exists();
  var { utimesMillis } = require_utimes();
  var stat = require_stat();
  var { asyncIteratorConcurrentProcess } = require_async();
  async function copy(src, dest, opts = {}) {
    if (typeof opts === "function") {
      opts = { filter: opts };
    }
    opts.clobber = "clobber" in opts ? !!opts.clobber : true;
    opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
    if (opts.preserveTimestamps && process.arch === "ia32") {
      process.emitWarning(`Using the preserveTimestamps option in 32-bit node is not recommended;

` + "\tsee https://github.com/jprichardson/node-fs-extra/issues/269", "Warning", "fs-extra-WARN0001");
    }
    const { srcStat, destStat } = await stat.checkPaths(src, dest, "copy", opts);
    await stat.checkParentPaths(src, srcStat, dest, "copy");
    const include = await runFilter(src, dest, opts);
    if (!include)
      return;
    const destParent = path.dirname(dest);
    const dirExists = await pathExists(destParent);
    if (!dirExists) {
      await mkdirs(destParent);
    }
    await getStatsAndPerformCopy(destStat, src, dest, opts);
  }
  async function runFilter(src, dest, opts) {
    if (!opts.filter)
      return true;
    return opts.filter(src, dest);
  }
  async function getStatsAndPerformCopy(destStat, src, dest, opts) {
    const statFn = opts.dereference ? fs2.stat : fs2.lstat;
    const srcStat = await statFn(src);
    if (srcStat.isDirectory())
      return onDir(srcStat, destStat, src, dest, opts);
    if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
      return onFile(srcStat, destStat, src, dest, opts);
    if (srcStat.isSymbolicLink())
      return onLink(destStat, src, dest, opts);
    if (srcStat.isSocket())
      throw new Error(`Cannot copy a socket file: ${src}`);
    if (srcStat.isFIFO())
      throw new Error(`Cannot copy a FIFO pipe: ${src}`);
    throw new Error(`Unknown file: ${src}`);
  }
  async function onFile(srcStat, destStat, src, dest, opts) {
    if (!destStat)
      return copyFile(srcStat, src, dest, opts);
    if (opts.overwrite) {
      await fs2.unlink(dest);
      return copyFile(srcStat, src, dest, opts);
    }
    if (opts.errorOnExist) {
      throw new Error(`'${dest}' already exists`);
    }
  }
  async function copyFile(srcStat, src, dest, opts) {
    await fs2.copyFile(src, dest);
    if (opts.preserveTimestamps) {
      if (fileIsNotWritable(srcStat.mode)) {
        await makeFileWritable(dest, srcStat.mode);
      }
      const updatedSrcStat = await fs2.stat(src);
      await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    return fs2.chmod(dest, srcStat.mode);
  }
  function fileIsNotWritable(srcMode) {
    return (srcMode & 128) === 0;
  }
  function makeFileWritable(dest, srcMode) {
    return fs2.chmod(dest, srcMode | 128);
  }
  async function onDir(srcStat, destStat, src, dest, opts) {
    if (!destStat) {
      await fs2.mkdir(dest);
    }
    await asyncIteratorConcurrentProcess(await fs2.opendir(src), async (item) => {
      const srcItem = path.join(src, item.name);
      const destItem = path.join(dest, item.name);
      const include = await runFilter(srcItem, destItem, opts);
      if (include) {
        const { destStat: destStat2 } = await stat.checkPaths(srcItem, destItem, "copy", opts);
        await getStatsAndPerformCopy(destStat2, srcItem, destItem, opts);
      }
    });
    if (!destStat) {
      await fs2.chmod(dest, srcStat.mode);
    }
  }
  async function onLink(destStat, src, dest, opts) {
    let resolvedSrc = await fs2.readlink(src);
    if (opts.dereference) {
      resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
    }
    if (!destStat) {
      return fs2.symlink(resolvedSrc, dest);
    }
    let resolvedDest = null;
    try {
      resolvedDest = await fs2.readlink(dest);
    } catch (e) {
      if (e.code === "EINVAL" || e.code === "UNKNOWN")
        return fs2.symlink(resolvedSrc, dest);
      throw e;
    }
    if (opts.dereference) {
      resolvedDest = path.resolve(process.cwd(), resolvedDest);
    }
    if (resolvedSrc !== resolvedDest) {
      if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
        throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
      }
      if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
        throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
      }
    }
    await fs2.unlink(dest);
    return fs2.symlink(resolvedSrc, dest);
  }
  module.exports = copy;
});

// node_modules/fs-extra/lib/copy/copy-sync.js
var require_copy_sync = __commonJS((exports, module) => {
  var fs2 = require_graceful_fs();
  var path = __require("path");
  var mkdirsSync = require_mkdirs().mkdirsSync;
  var utimesMillisSync = require_utimes().utimesMillisSync;
  var stat = require_stat();
  function copySync(src, dest, opts) {
    if (typeof opts === "function") {
      opts = { filter: opts };
    }
    opts = opts || {};
    opts.clobber = "clobber" in opts ? !!opts.clobber : true;
    opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
    if (opts.preserveTimestamps && process.arch === "ia32") {
      process.emitWarning(`Using the preserveTimestamps option in 32-bit node is not recommended;

` + "\tsee https://github.com/jprichardson/node-fs-extra/issues/269", "Warning", "fs-extra-WARN0002");
    }
    const { srcStat, destStat } = stat.checkPathsSync(src, dest, "copy", opts);
    stat.checkParentPathsSync(src, srcStat, dest, "copy");
    if (opts.filter && !opts.filter(src, dest))
      return;
    const destParent = path.dirname(dest);
    if (!fs2.existsSync(destParent))
      mkdirsSync(destParent);
    return getStats(destStat, src, dest, opts);
  }
  function getStats(destStat, src, dest, opts) {
    const statSync = opts.dereference ? fs2.statSync : fs2.lstatSync;
    const srcStat = statSync(src);
    if (srcStat.isDirectory())
      return onDir(srcStat, destStat, src, dest, opts);
    else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
      return onFile(srcStat, destStat, src, dest, opts);
    else if (srcStat.isSymbolicLink())
      return onLink(destStat, src, dest, opts);
    else if (srcStat.isSocket())
      throw new Error(`Cannot copy a socket file: ${src}`);
    else if (srcStat.isFIFO())
      throw new Error(`Cannot copy a FIFO pipe: ${src}`);
    throw new Error(`Unknown file: ${src}`);
  }
  function onFile(srcStat, destStat, src, dest, opts) {
    if (!destStat)
      return copyFile(srcStat, src, dest, opts);
    return mayCopyFile(srcStat, src, dest, opts);
  }
  function mayCopyFile(srcStat, src, dest, opts) {
    if (opts.overwrite) {
      fs2.unlinkSync(dest);
      return copyFile(srcStat, src, dest, opts);
    } else if (opts.errorOnExist) {
      throw new Error(`'${dest}' already exists`);
    }
  }
  function copyFile(srcStat, src, dest, opts) {
    fs2.copyFileSync(src, dest);
    if (opts.preserveTimestamps)
      handleTimestamps(srcStat.mode, src, dest);
    return setDestMode(dest, srcStat.mode);
  }
  function handleTimestamps(srcMode, src, dest) {
    if (fileIsNotWritable(srcMode))
      makeFileWritable(dest, srcMode);
    return setDestTimestamps(src, dest);
  }
  function fileIsNotWritable(srcMode) {
    return (srcMode & 128) === 0;
  }
  function makeFileWritable(dest, srcMode) {
    return setDestMode(dest, srcMode | 128);
  }
  function setDestMode(dest, srcMode) {
    return fs2.chmodSync(dest, srcMode);
  }
  function setDestTimestamps(src, dest) {
    const updatedSrcStat = fs2.statSync(src);
    return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
  }
  function onDir(srcStat, destStat, src, dest, opts) {
    if (!destStat)
      return mkDirAndCopy(srcStat.mode, src, dest, opts);
    return copyDir(src, dest, opts);
  }
  function mkDirAndCopy(srcMode, src, dest, opts) {
    fs2.mkdirSync(dest);
    copyDir(src, dest, opts);
    return setDestMode(dest, srcMode);
  }
  function copyDir(src, dest, opts) {
    const dir = fs2.opendirSync(src);
    try {
      let dirent;
      while ((dirent = dir.readSync()) !== null) {
        copyDirItem(dirent.name, src, dest, opts);
      }
    } finally {
      dir.closeSync();
    }
  }
  function copyDirItem(item, src, dest, opts) {
    const srcItem = path.join(src, item);
    const destItem = path.join(dest, item);
    if (opts.filter && !opts.filter(srcItem, destItem))
      return;
    const { destStat } = stat.checkPathsSync(srcItem, destItem, "copy", opts);
    return getStats(destStat, srcItem, destItem, opts);
  }
  function onLink(destStat, src, dest, opts) {
    let resolvedSrc = fs2.readlinkSync(src);
    if (opts.dereference) {
      resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
    }
    if (!destStat) {
      return fs2.symlinkSync(resolvedSrc, dest);
    } else {
      let resolvedDest;
      try {
        resolvedDest = fs2.readlinkSync(dest);
      } catch (err) {
        if (err.code === "EINVAL" || err.code === "UNKNOWN")
          return fs2.symlinkSync(resolvedSrc, dest);
        throw err;
      }
      if (opts.dereference) {
        resolvedDest = path.resolve(process.cwd(), resolvedDest);
      }
      if (resolvedSrc !== resolvedDest) {
        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
      }
      return copyLink(resolvedSrc, dest);
    }
  }
  function copyLink(resolvedSrc, dest) {
    fs2.unlinkSync(dest);
    return fs2.symlinkSync(resolvedSrc, dest);
  }
  module.exports = copySync;
});

// node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  module.exports = {
    copy: u(require_copy()),
    copySync: require_copy_sync()
  };
});

// node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS((exports, module) => {
  var fs2 = require_graceful_fs();
  var u = require_universalify().fromCallback;
  function remove(path, callback) {
    fs2.rm(path, { recursive: true, force: true }, callback);
  }
  function removeSync(path) {
    fs2.rmSync(path, { recursive: true, force: true });
  }
  module.exports = {
    remove: u(remove),
    removeSync
  };
});

// node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  var fs2 = require_fs();
  var path = __require("path");
  var mkdir = require_mkdirs();
  var remove = require_remove();
  var emptyDir = u(async function emptyDir(dir) {
    let items;
    try {
      items = await fs2.readdir(dir);
    } catch {
      return mkdir.mkdirs(dir);
    }
    return Promise.all(items.map((item) => remove.remove(path.join(dir, item))));
  });
  function emptyDirSync(dir) {
    let items;
    try {
      items = fs2.readdirSync(dir);
    } catch {
      return mkdir.mkdirsSync(dir);
    }
    items.forEach((item) => {
      item = path.join(dir, item);
      remove.removeSync(item);
    });
  }
  module.exports = {
    emptyDirSync,
    emptydirSync: emptyDirSync,
    emptyDir,
    emptydir: emptyDir
  };
});

// node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  var path = __require("path");
  var fs2 = require_fs();
  var mkdir = require_mkdirs();
  async function createFile(file) {
    let stats;
    try {
      stats = await fs2.stat(file);
    } catch {}
    if (stats && stats.isFile())
      return;
    const dir = path.dirname(file);
    let dirStats = null;
    try {
      dirStats = await fs2.stat(dir);
    } catch (err) {
      if (err.code === "ENOENT") {
        await mkdir.mkdirs(dir);
        await fs2.writeFile(file, "");
        return;
      } else {
        throw err;
      }
    }
    if (dirStats.isDirectory()) {
      await fs2.writeFile(file, "");
    } else {
      await fs2.readdir(dir);
    }
  }
  function createFileSync(file) {
    let stats;
    try {
      stats = fs2.statSync(file);
    } catch {}
    if (stats && stats.isFile())
      return;
    const dir = path.dirname(file);
    try {
      if (!fs2.statSync(dir).isDirectory()) {
        fs2.readdirSync(dir);
      }
    } catch (err) {
      if (err && err.code === "ENOENT")
        mkdir.mkdirsSync(dir);
      else
        throw err;
    }
    fs2.writeFileSync(file, "");
  }
  module.exports = {
    createFile: u(createFile),
    createFileSync
  };
});

// node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  var path = __require("path");
  var fs2 = require_fs();
  var mkdir = require_mkdirs();
  var { pathExists } = require_path_exists();
  var { areIdentical } = require_stat();
  async function createLink(srcpath, dstpath) {
    let dstStat;
    try {
      dstStat = await fs2.lstat(dstpath);
    } catch {}
    let srcStat;
    try {
      srcStat = await fs2.lstat(srcpath);
    } catch (err) {
      err.message = err.message.replace("lstat", "ensureLink");
      throw err;
    }
    if (dstStat && areIdentical(srcStat, dstStat))
      return;
    const dir = path.dirname(dstpath);
    const dirExists = await pathExists(dir);
    if (!dirExists) {
      await mkdir.mkdirs(dir);
    }
    await fs2.link(srcpath, dstpath);
  }
  function createLinkSync(srcpath, dstpath) {
    let dstStat;
    try {
      dstStat = fs2.lstatSync(dstpath);
    } catch {}
    try {
      const srcStat = fs2.lstatSync(srcpath);
      if (dstStat && areIdentical(srcStat, dstStat))
        return;
    } catch (err) {
      err.message = err.message.replace("lstat", "ensureLink");
      throw err;
    }
    const dir = path.dirname(dstpath);
    const dirExists = fs2.existsSync(dir);
    if (dirExists)
      return fs2.linkSync(srcpath, dstpath);
    mkdir.mkdirsSync(dir);
    return fs2.linkSync(srcpath, dstpath);
  }
  module.exports = {
    createLink: u(createLink),
    createLinkSync
  };
});

// node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS((exports, module) => {
  var path = __require("path");
  var fs2 = require_fs();
  var { pathExists } = require_path_exists();
  var u = require_universalify().fromPromise;
  async function symlinkPaths(srcpath, dstpath) {
    if (path.isAbsolute(srcpath)) {
      try {
        await fs2.lstat(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureSymlink");
        throw err;
      }
      return {
        toCwd: srcpath,
        toDst: srcpath
      };
    }
    const dstdir = path.dirname(dstpath);
    const relativeToDst = path.join(dstdir, srcpath);
    const exists = await pathExists(relativeToDst);
    if (exists) {
      return {
        toCwd: relativeToDst,
        toDst: srcpath
      };
    }
    try {
      await fs2.lstat(srcpath);
    } catch (err) {
      err.message = err.message.replace("lstat", "ensureSymlink");
      throw err;
    }
    return {
      toCwd: srcpath,
      toDst: path.relative(dstdir, srcpath)
    };
  }
  function symlinkPathsSync(srcpath, dstpath) {
    if (path.isAbsolute(srcpath)) {
      const exists2 = fs2.existsSync(srcpath);
      if (!exists2)
        throw new Error("absolute srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: srcpath
      };
    }
    const dstdir = path.dirname(dstpath);
    const relativeToDst = path.join(dstdir, srcpath);
    const exists = fs2.existsSync(relativeToDst);
    if (exists) {
      return {
        toCwd: relativeToDst,
        toDst: srcpath
      };
    }
    const srcExists = fs2.existsSync(srcpath);
    if (!srcExists)
      throw new Error("relative srcpath does not exist");
    return {
      toCwd: srcpath,
      toDst: path.relative(dstdir, srcpath)
    };
  }
  module.exports = {
    symlinkPaths: u(symlinkPaths),
    symlinkPathsSync
  };
});

// node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS((exports, module) => {
  var fs2 = require_fs();
  var u = require_universalify().fromPromise;
  async function symlinkType(srcpath, type) {
    if (type)
      return type;
    let stats;
    try {
      stats = await fs2.lstat(srcpath);
    } catch {
      return "file";
    }
    return stats && stats.isDirectory() ? "dir" : "file";
  }
  function symlinkTypeSync(srcpath, type) {
    if (type)
      return type;
    let stats;
    try {
      stats = fs2.lstatSync(srcpath);
    } catch {
      return "file";
    }
    return stats && stats.isDirectory() ? "dir" : "file";
  }
  module.exports = {
    symlinkType: u(symlinkType),
    symlinkTypeSync
  };
});

// node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  var path = __require("path");
  var fs2 = require_fs();
  var { mkdirs, mkdirsSync } = require_mkdirs();
  var { symlinkPaths, symlinkPathsSync } = require_symlink_paths();
  var { symlinkType, symlinkTypeSync } = require_symlink_type();
  var { pathExists } = require_path_exists();
  var { areIdentical } = require_stat();
  async function createSymlink(srcpath, dstpath, type) {
    let stats;
    try {
      stats = await fs2.lstat(dstpath);
    } catch {}
    if (stats && stats.isSymbolicLink()) {
      const [srcStat, dstStat] = await Promise.all([
        fs2.stat(srcpath),
        fs2.stat(dstpath)
      ]);
      if (areIdentical(srcStat, dstStat))
        return;
    }
    const relative = await symlinkPaths(srcpath, dstpath);
    srcpath = relative.toDst;
    const toType = await symlinkType(relative.toCwd, type);
    const dir = path.dirname(dstpath);
    if (!await pathExists(dir)) {
      await mkdirs(dir);
    }
    return fs2.symlink(srcpath, dstpath, toType);
  }
  function createSymlinkSync(srcpath, dstpath, type) {
    let stats;
    try {
      stats = fs2.lstatSync(dstpath);
    } catch {}
    if (stats && stats.isSymbolicLink()) {
      const srcStat = fs2.statSync(srcpath);
      const dstStat = fs2.statSync(dstpath);
      if (areIdentical(srcStat, dstStat))
        return;
    }
    const relative = symlinkPathsSync(srcpath, dstpath);
    srcpath = relative.toDst;
    type = symlinkTypeSync(relative.toCwd, type);
    const dir = path.dirname(dstpath);
    const exists = fs2.existsSync(dir);
    if (exists)
      return fs2.symlinkSync(srcpath, dstpath, type);
    mkdirsSync(dir);
    return fs2.symlinkSync(srcpath, dstpath, type);
  }
  module.exports = {
    createSymlink: u(createSymlink),
    createSymlinkSync
  };
});

// node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS((exports, module) => {
  var { createFile, createFileSync } = require_file();
  var { createLink, createLinkSync } = require_link();
  var { createSymlink, createSymlinkSync } = require_symlink();
  module.exports = {
    createFile,
    createFileSync,
    ensureFile: createFile,
    ensureFileSync: createFileSync,
    createLink,
    createLinkSync,
    ensureLink: createLink,
    ensureLinkSync: createLinkSync,
    createSymlink,
    createSymlinkSync,
    ensureSymlink: createSymlink,
    ensureSymlinkSync: createSymlinkSync
  };
});

// node_modules/jsonfile/utils.js
var require_utils2 = __commonJS((exports, module) => {
  function stringify(obj, { EOL = `
`, finalEOL = true, replacer = null, spaces } = {}) {
    const EOF = finalEOL ? EOL : "";
    const str = JSON.stringify(obj, replacer, spaces);
    return str.replace(/\n/g, EOL) + EOF;
  }
  function stripBom(content) {
    if (Buffer.isBuffer(content))
      content = content.toString("utf8");
    return content.replace(/^\uFEFF/, "");
  }
  module.exports = { stringify, stripBom };
});

// node_modules/jsonfile/index.js
var require_jsonfile = __commonJS((exports, module) => {
  var _fs;
  try {
    _fs = require_graceful_fs();
  } catch (_) {
    _fs = __require("fs");
  }
  var universalify = require_universalify();
  var { stringify, stripBom } = require_utils2();
  async function _readFile(file, options = {}) {
    if (typeof options === "string") {
      options = { encoding: options };
    }
    const fs2 = options.fs || _fs;
    const shouldThrow = "throws" in options ? options.throws : true;
    let data = await universalify.fromCallback(fs2.readFile)(file, options);
    data = stripBom(data);
    let obj;
    try {
      obj = JSON.parse(data, options ? options.reviver : null);
    } catch (err) {
      if (shouldThrow) {
        err.message = `${file}: ${err.message}`;
        throw err;
      } else {
        return null;
      }
    }
    return obj;
  }
  var readFile = universalify.fromPromise(_readFile);
  function readFileSync4(file, options = {}) {
    if (typeof options === "string") {
      options = { encoding: options };
    }
    const fs2 = options.fs || _fs;
    const shouldThrow = "throws" in options ? options.throws : true;
    try {
      let content = fs2.readFileSync(file, options);
      content = stripBom(content);
      return JSON.parse(content, options.reviver);
    } catch (err) {
      if (shouldThrow) {
        err.message = `${file}: ${err.message}`;
        throw err;
      } else {
        return null;
      }
    }
  }
  async function _writeFile(file, obj, options = {}) {
    const fs2 = options.fs || _fs;
    const str = stringify(obj, options);
    await universalify.fromCallback(fs2.writeFile)(file, str, options);
  }
  var writeFile = universalify.fromPromise(_writeFile);
  function writeFileSync(file, obj, options = {}) {
    const fs2 = options.fs || _fs;
    const str = stringify(obj, options);
    return fs2.writeFileSync(file, str, options);
  }
  module.exports = {
    readFile,
    readFileSync: readFileSync4,
    writeFile,
    writeFileSync
  };
});

// node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS((exports, module) => {
  var jsonFile = require_jsonfile();
  module.exports = {
    readJson: jsonFile.readFile,
    readJsonSync: jsonFile.readFileSync,
    writeJson: jsonFile.writeFile,
    writeJsonSync: jsonFile.writeFileSync
  };
});

// node_modules/fs-extra/lib/output-file/index.js
var require_output_file = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  var fs2 = require_fs();
  var path = __require("path");
  var mkdir = require_mkdirs();
  var pathExists = require_path_exists().pathExists;
  async function outputFile(file, data, encoding = "utf-8") {
    const dir = path.dirname(file);
    if (!await pathExists(dir)) {
      await mkdir.mkdirs(dir);
    }
    return fs2.writeFile(file, data, encoding);
  }
  function outputFileSync(file, ...args) {
    const dir = path.dirname(file);
    if (!fs2.existsSync(dir)) {
      mkdir.mkdirsSync(dir);
    }
    fs2.writeFileSync(file, ...args);
  }
  module.exports = {
    outputFile: u(outputFile),
    outputFileSync
  };
});

// node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS((exports, module) => {
  var { stringify } = require_utils2();
  var { outputFile } = require_output_file();
  async function outputJson(file, data, options = {}) {
    const str = stringify(data, options);
    await outputFile(file, str, options);
  }
  module.exports = outputJson;
});

// node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS((exports, module) => {
  var { stringify } = require_utils2();
  var { outputFileSync } = require_output_file();
  function outputJsonSync(file, data, options) {
    const str = stringify(data, options);
    outputFileSync(file, str, options);
  }
  module.exports = outputJsonSync;
});

// node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  var jsonFile = require_jsonfile2();
  jsonFile.outputJson = u(require_output_json());
  jsonFile.outputJsonSync = require_output_json_sync();
  jsonFile.outputJSON = jsonFile.outputJson;
  jsonFile.outputJSONSync = jsonFile.outputJsonSync;
  jsonFile.writeJSON = jsonFile.writeJson;
  jsonFile.writeJSONSync = jsonFile.writeJsonSync;
  jsonFile.readJSON = jsonFile.readJson;
  jsonFile.readJSONSync = jsonFile.readJsonSync;
  module.exports = jsonFile;
});

// node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS((exports, module) => {
  var fs2 = require_fs();
  var path = __require("path");
  var { copy } = require_copy2();
  var { remove } = require_remove();
  var { mkdirp } = require_mkdirs();
  var { pathExists } = require_path_exists();
  var stat = require_stat();
  async function move(src, dest, opts = {}) {
    const overwrite = opts.overwrite || opts.clobber || false;
    const { srcStat, isChangingCase = false } = await stat.checkPaths(src, dest, "move", opts);
    await stat.checkParentPaths(src, srcStat, dest, "move");
    const destParent = path.dirname(dest);
    const parsedParentPath = path.parse(destParent);
    if (parsedParentPath.root !== destParent) {
      await mkdirp(destParent);
    }
    return doRename(src, dest, overwrite, isChangingCase);
  }
  async function doRename(src, dest, overwrite, isChangingCase) {
    if (!isChangingCase) {
      if (overwrite) {
        await remove(dest);
      } else if (await pathExists(dest)) {
        throw new Error("dest already exists.");
      }
    }
    try {
      await fs2.rename(src, dest);
    } catch (err) {
      if (err.code !== "EXDEV") {
        throw err;
      }
      await moveAcrossDevice(src, dest, overwrite);
    }
  }
  async function moveAcrossDevice(src, dest, overwrite) {
    const opts = {
      overwrite,
      errorOnExist: true,
      preserveTimestamps: true
    };
    await copy(src, dest, opts);
    return remove(src);
  }
  module.exports = move;
});

// node_modules/fs-extra/lib/move/move-sync.js
var require_move_sync = __commonJS((exports, module) => {
  var fs2 = require_graceful_fs();
  var path = __require("path");
  var copySync = require_copy2().copySync;
  var removeSync = require_remove().removeSync;
  var mkdirpSync = require_mkdirs().mkdirpSync;
  var stat = require_stat();
  function moveSync(src, dest, opts) {
    opts = opts || {};
    const overwrite = opts.overwrite || opts.clobber || false;
    const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, "move", opts);
    stat.checkParentPathsSync(src, srcStat, dest, "move");
    if (!isParentRoot(dest))
      mkdirpSync(path.dirname(dest));
    return doRename(src, dest, overwrite, isChangingCase);
  }
  function isParentRoot(dest) {
    const parent = path.dirname(dest);
    const parsedPath = path.parse(parent);
    return parsedPath.root === parent;
  }
  function doRename(src, dest, overwrite, isChangingCase) {
    if (isChangingCase)
      return rename(src, dest, overwrite);
    if (overwrite) {
      removeSync(dest);
      return rename(src, dest, overwrite);
    }
    if (fs2.existsSync(dest))
      throw new Error("dest already exists.");
    return rename(src, dest, overwrite);
  }
  function rename(src, dest, overwrite) {
    try {
      fs2.renameSync(src, dest);
    } catch (err) {
      if (err.code !== "EXDEV")
        throw err;
      return moveAcrossDevice(src, dest, overwrite);
    }
  }
  function moveAcrossDevice(src, dest, overwrite) {
    const opts = {
      overwrite,
      errorOnExist: true,
      preserveTimestamps: true
    };
    copySync(src, dest, opts);
    return removeSync(src);
  }
  module.exports = moveSync;
});

// node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  module.exports = {
    move: u(require_move()),
    moveSync: require_move_sync()
  };
});

// node_modules/fs-extra/lib/index.js
var require_lib = __commonJS((exports, module) => {
  module.exports = {
    ...require_fs(),
    ...require_copy2(),
    ...require_empty(),
    ...require_ensure(),
    ...require_json(),
    ...require_mkdirs(),
    ...require_move2(),
    ...require_output_file(),
    ...require_path_exists(),
    ...require_remove()
  };
});

// src/shared/environment.ts
function isCIEnvironment() {
  return process.env.CI === "true" || process.env.CI_SAFE_MODE === "true";
}
function isNonInteractive() {
  return !process.stdin.isTTY || process.env.CI === "true" || process.env.NON_INTERACTIVE === "true";
}
function isMacOS() {
  return process.platform === "darwin";
}
function isWindows() {
  return process.platform === "win32";
}
function getOptimalConcurrency() {
  if (isMacOS())
    return PLATFORM_CONCURRENCY.MACOS;
  if (isWindows())
    return PLATFORM_CONCURRENCY.WINDOWS;
  return PLATFORM_CONCURRENCY.LINUX;
}
var PLATFORM_CONCURRENCY;
var init_environment = __esm(() => {
  PLATFORM_CONCURRENCY = {
    MACOS: 10,
    WINDOWS: 15,
    LINUX: 20
  };
});

// node_modules/sisteransi/src/index.js
var require_src = __commonJS((exports, module) => {
  var ESC = "\x1B";
  var CSI = `${ESC}[`;
  var beep = "\x07";
  var cursor = {
    to(x, y) {
      if (!y)
        return `${CSI}${x + 1}G`;
      return `${CSI}${y + 1};${x + 1}H`;
    },
    move(x, y) {
      let ret = "";
      if (x < 0)
        ret += `${CSI}${-x}D`;
      else if (x > 0)
        ret += `${CSI}${x}C`;
      if (y < 0)
        ret += `${CSI}${-y}A`;
      else if (y > 0)
        ret += `${CSI}${y}B`;
      return ret;
    },
    up: (count = 1) => `${CSI}${count}A`,
    down: (count = 1) => `${CSI}${count}B`,
    forward: (count = 1) => `${CSI}${count}C`,
    backward: (count = 1) => `${CSI}${count}D`,
    nextLine: (count = 1) => `${CSI}E`.repeat(count),
    prevLine: (count = 1) => `${CSI}F`.repeat(count),
    left: `${CSI}G`,
    hide: `${CSI}?25l`,
    show: `${CSI}?25h`,
    save: `${ESC}7`,
    restore: `${ESC}8`
  };
  var scroll = {
    up: (count = 1) => `${CSI}S`.repeat(count),
    down: (count = 1) => `${CSI}T`.repeat(count)
  };
  var erase = {
    screen: `${CSI}2J`,
    up: (count = 1) => `${CSI}1J`.repeat(count),
    down: (count = 1) => `${CSI}J`.repeat(count),
    line: `${CSI}2K`,
    lineEnd: `${CSI}K`,
    lineStart: `${CSI}1K`,
    lines(count) {
      let clear = "";
      for (let i = 0;i < count; i++)
        clear += this.line + (i < count - 1 ? cursor.up() : "");
      if (count)
        clear += cursor.left;
      return clear;
    }
  };
  module.exports = { cursor, scroll, erase, beep };
});

// node_modules/@clack/core/dist/index.mjs
import { stdin as $, stdout as k } from "node:process";
import * as f from "node:readline";
import _ from "node:readline";
import { WriteStream as U } from "node:tty";
function q({ onlyFirst: e = false } = {}) {
  const F = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?(?:\\u0007|\\u001B\\u005C|\\u009C))", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"].join("|");
  return new RegExp(F, e ? undefined : "g");
}
function S(e) {
  if (typeof e != "string")
    throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);
  return e.replace(J, "");
}
function T(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function A(e, u = {}) {
  if (typeof e != "string" || e.length === 0 || (u = { ambiguousIsNarrow: true, ...u }, e = S(e), e.length === 0))
    return 0;
  e = e.replace(uD(), "  ");
  const F = u.ambiguousIsNarrow ? 1 : 2;
  let t = 0;
  for (const s of e) {
    const C = s.codePointAt(0);
    if (C <= 31 || C >= 127 && C <= 159 || C >= 768 && C <= 879)
      continue;
    switch (X.eastAsianWidth(s)) {
      case "F":
      case "W":
        t += 2;
        break;
      case "A":
        t += F;
        break;
      default:
        t += 1;
    }
  }
  return t;
}
function tD() {
  const e = new Map;
  for (const [u, F] of Object.entries(r)) {
    for (const [t, s] of Object.entries(F))
      r[t] = { open: `\x1B[${s[0]}m`, close: `\x1B[${s[1]}m` }, F[t] = r[t], e.set(s[0], s[1]);
    Object.defineProperty(r, u, { value: F, enumerable: false });
  }
  return Object.defineProperty(r, "codes", { value: e, enumerable: false }), r.color.close = "\x1B[39m", r.bgColor.close = "\x1B[49m", r.color.ansi = M(), r.color.ansi256 = P(), r.color.ansi16m = W(), r.bgColor.ansi = M(d), r.bgColor.ansi256 = P(d), r.bgColor.ansi16m = W(d), Object.defineProperties(r, { rgbToAnsi256: { value: (u, F, t) => u === F && F === t ? u < 8 ? 16 : u > 248 ? 231 : Math.round((u - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(u / 255 * 5) + 6 * Math.round(F / 255 * 5) + Math.round(t / 255 * 5), enumerable: false }, hexToRgb: { value: (u) => {
    const F = /[a-f\d]{6}|[a-f\d]{3}/i.exec(u.toString(16));
    if (!F)
      return [0, 0, 0];
    let [t] = F;
    t.length === 3 && (t = [...t].map((C) => C + C).join(""));
    const s = Number.parseInt(t, 16);
    return [s >> 16 & 255, s >> 8 & 255, s & 255];
  }, enumerable: false }, hexToAnsi256: { value: (u) => r.rgbToAnsi256(...r.hexToRgb(u)), enumerable: false }, ansi256ToAnsi: { value: (u) => {
    if (u < 8)
      return 30 + u;
    if (u < 16)
      return 90 + (u - 8);
    let F, t, s;
    if (u >= 232)
      F = ((u - 232) * 10 + 8) / 255, t = F, s = F;
    else {
      u -= 16;
      const i = u % 36;
      F = Math.floor(u / 36) / 5, t = Math.floor(i / 6) / 5, s = i % 6 / 5;
    }
    const C = Math.max(F, t, s) * 2;
    if (C === 0)
      return 30;
    let D = 30 + (Math.round(s) << 2 | Math.round(t) << 1 | Math.round(F));
    return C === 2 && (D += 60), D;
  }, enumerable: false }, rgbToAnsi: { value: (u, F, t) => r.ansi256ToAnsi(r.rgbToAnsi256(u, F, t)), enumerable: false }, hexToAnsi: { value: (u) => r.ansi256ToAnsi(r.hexToAnsi256(u)), enumerable: false } }), r;
}
function R(e, u, F) {
  return String(e).normalize().replace(/\r\n/g, `
`).split(`
`).map((t) => oD(t, u, F)).join(`
`);
}
function hD(e, u) {
  if (e === u)
    return;
  const F = e.split(`
`), t = u.split(`
`), s = [];
  for (let C = 0;C < Math.max(F.length, t.length); C++)
    F[C] !== t[C] && s.push(C);
  return s;
}
function lD(e) {
  return e === V;
}
function v(e, u) {
  e.isTTY && e.setRawMode(u);
}

class x {
  constructor({ render: u, input: F = $, output: t = k, ...s }, C = true) {
    a(this, "input"), a(this, "output"), a(this, "rl"), a(this, "opts"), a(this, "_track", false), a(this, "_render"), a(this, "_cursor", 0), a(this, "state", "initial"), a(this, "value"), a(this, "error", ""), a(this, "subscribers", new Map), a(this, "_prevFrame", ""), this.opts = s, this.onKeypress = this.onKeypress.bind(this), this.close = this.close.bind(this), this.render = this.render.bind(this), this._render = u.bind(this), this._track = C, this.input = F, this.output = t;
  }
  prompt() {
    const u = new U(0);
    return u._write = (F, t, s) => {
      this._track && (this.value = this.rl.line.replace(/\t/g, ""), this._cursor = this.rl.cursor, this.emit("value", this.value)), s();
    }, this.input.pipe(u), this.rl = _.createInterface({ input: this.input, output: u, tabSize: 2, prompt: "", escapeCodeTimeout: 50 }), _.emitKeypressEvents(this.input, this.rl), this.rl.prompt(), this.opts.initialValue !== undefined && this._track && this.rl.write(this.opts.initialValue), this.input.on("keypress", this.onKeypress), v(this.input, true), this.output.on("resize", this.render), this.render(), new Promise((F, t) => {
      this.once("submit", () => {
        this.output.write(import_sisteransi.cursor.show), this.output.off("resize", this.render), v(this.input, false), F(this.value);
      }), this.once("cancel", () => {
        this.output.write(import_sisteransi.cursor.show), this.output.off("resize", this.render), v(this.input, false), F(V);
      });
    });
  }
  on(u, F) {
    const t = this.subscribers.get(u) ?? [];
    t.push({ cb: F }), this.subscribers.set(u, t);
  }
  once(u, F) {
    const t = this.subscribers.get(u) ?? [];
    t.push({ cb: F, once: true }), this.subscribers.set(u, t);
  }
  emit(u, ...F) {
    const t = this.subscribers.get(u) ?? [], s = [];
    for (const C of t)
      C.cb(...F), C.once && s.push(() => t.splice(t.indexOf(C), 1));
    for (const C of s)
      C();
  }
  unsubscribe() {
    this.subscribers.clear();
  }
  onKeypress(u, F) {
    if (this.state === "error" && (this.state = "active"), F?.name && !this._track && z.has(F.name) && this.emit("cursor", z.get(F.name)), F?.name && xD.has(F.name) && this.emit("cursor", F.name), u && (u.toLowerCase() === "y" || u.toLowerCase() === "n") && this.emit("confirm", u.toLowerCase() === "y"), u === "\t" && this.opts.placeholder && (this.value || (this.rl.write(this.opts.placeholder), this.emit("value", this.opts.placeholder))), u && this.emit("key", u.toLowerCase()), F?.name === "return") {
      if (this.opts.validate) {
        const t = this.opts.validate(this.value);
        t && (this.error = t, this.state = "error", this.rl.write(this.value));
      }
      this.state !== "error" && (this.state = "submit");
    }
    u === "\x03" && (this.state = "cancel"), (this.state === "submit" || this.state === "cancel") && this.emit("finalize"), this.render(), (this.state === "submit" || this.state === "cancel") && this.close();
  }
  close() {
    this.input.unpipe(), this.input.removeListener("keypress", this.onKeypress), this.output.write(`
`), v(this.input, false), this.rl.close(), this.emit(`${this.state}`, this.value), this.unsubscribe();
  }
  restoreCursor() {
    const u = R(this._prevFrame, process.stdout.columns, { hard: true }).split(`
`).length - 1;
    this.output.write(import_sisteransi.cursor.move(-999, u * -1));
  }
  render() {
    const u = R(this._render(this) ?? "", process.stdout.columns, { hard: true });
    if (u !== this._prevFrame) {
      if (this.state === "initial")
        this.output.write(import_sisteransi.cursor.hide);
      else {
        const F = hD(this._prevFrame, u);
        if (this.restoreCursor(), F && F?.length === 1) {
          const t = F[0];
          this.output.write(import_sisteransi.cursor.move(0, t)), this.output.write(import_sisteransi.erase.lines(1));
          const s = u.split(`
`);
          this.output.write(s[t]), this._prevFrame = u, this.output.write(import_sisteransi.cursor.move(0, s.length - t - 1));
          return;
        } else if (F && F?.length > 1) {
          const t = F[0];
          this.output.write(import_sisteransi.cursor.move(0, t)), this.output.write(import_sisteransi.erase.down());
          const s = u.split(`
`).slice(t);
          this.output.write(s.join(`
`)), this._prevFrame = u;
          return;
        }
        this.output.write(import_sisteransi.erase.down());
      }
      this.output.write(u), this.state === "initial" && (this.state = "active"), this._prevFrame = u;
    }
  }
}
function OD({ input: e = $, output: u = k, overwrite: F = true, hideCursor: t = true } = {}) {
  const s = f.createInterface({ input: e, output: u, prompt: "", tabSize: 1 });
  f.emitKeypressEvents(e, s), e.isTTY && e.setRawMode(true);
  const C = (D, { name: i }) => {
    if (String(D) === "\x03") {
      t && u.write(import_sisteransi.cursor.show), process.exit(0);
      return;
    }
    if (!F)
      return;
    let n = i === "return" ? 0 : -1, E = i === "return" ? -1 : 0;
    f.moveCursor(u, n, E, () => {
      f.clearLine(u, 1, () => {
        e.once("keypress", C);
      });
    });
  };
  return t && u.write(import_sisteransi.cursor.hide), e.once("keypress", C), () => {
    e.off("keypress", C), t && u.write(import_sisteransi.cursor.show), e.isTTY && !WD && e.setRawMode(false), s.terminal = false, s.close();
  };
}
var import_sisteransi, import_picocolors4, J, j, Q, X, DD = function() {
  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
}, uD, d = 10, M = (e = 0) => (u) => `\x1B[${u + e}m`, P = (e = 0) => (u) => `\x1B[${38 + e};5;${u}m`, W = (e = 0) => (u, F, t) => `\x1B[${38 + e};2;${u};${F};${t}m`, r, FD, eD, sD, g, CD = 39, b = "\x07", O = "[", iD = "]", I = "m", w, N = (e) => `${g.values().next().value}${O}${e}${I}`, L = (e) => `${g.values().next().value}${w}${e}${b}`, rD = (e) => e.split(" ").map((u) => A(u)), y = (e, u, F) => {
  const t = [...u];
  let s = false, C = false, D = A(S(e[e.length - 1]));
  for (const [i, n] of t.entries()) {
    const E = A(n);
    if (D + E <= F ? e[e.length - 1] += n : (e.push(n), D = 0), g.has(n) && (s = true, C = t.slice(i + 1).join("").startsWith(w)), s) {
      C ? n === b && (s = false, C = false) : n === I && (s = false);
      continue;
    }
    D += E, D === F && i < t.length - 1 && (e.push(""), D = 0);
  }
  !D && e[e.length - 1].length > 0 && e.length > 1 && (e[e.length - 2] += e.pop());
}, ED = (e) => {
  const u = e.split(" ");
  let F = u.length;
  for (;F > 0 && !(A(u[F - 1]) > 0); )
    F--;
  return F === u.length ? e : u.slice(0, F).join(" ") + u.slice(F).join("");
}, oD = (e, u, F = {}) => {
  if (F.trim !== false && e.trim() === "")
    return "";
  let t = "", s, C;
  const D = rD(e);
  let i = [""];
  for (const [E, h] of e.split(" ").entries()) {
    F.trim !== false && (i[i.length - 1] = i[i.length - 1].trimStart());
    let o = A(i[i.length - 1]);
    if (E !== 0 && (o >= u && (F.wordWrap === false || F.trim === false) && (i.push(""), o = 0), (o > 0 || F.trim === false) && (i[i.length - 1] += " ", o++)), F.hard && D[E] > u) {
      const B = u - o, p = 1 + Math.floor((D[E] - B - 1) / u);
      Math.floor((D[E] - 1) / u) < p && i.push(""), y(i, h, u);
      continue;
    }
    if (o + D[E] > u && o > 0 && D[E] > 0) {
      if (F.wordWrap === false && o < u) {
        y(i, h, u);
        continue;
      }
      i.push("");
    }
    if (o + D[E] > u && F.wordWrap === false) {
      y(i, h, u);
      continue;
    }
    i[i.length - 1] += h;
  }
  F.trim !== false && (i = i.map((E) => ED(E)));
  const n = [...i.join(`
`)];
  for (const [E, h] of n.entries()) {
    if (t += h, g.has(h)) {
      const { groups: B } = new RegExp(`(?:\\${O}(?<code>\\d+)m|\\${w}(?<uri>.*)${b})`).exec(n.slice(E).join("")) || { groups: {} };
      if (B.code !== undefined) {
        const p = Number.parseFloat(B.code);
        s = p === CD ? undefined : p;
      } else
        B.uri !== undefined && (C = B.uri.length === 0 ? undefined : B.uri);
    }
    const o = sD.codes.get(Number(s));
    n[E + 1] === `
` ? (C && (t += L("")), s && o && (t += N(o))) : h === `
` && (s && o && (t += N(s)), C && (t += L(C)));
  }
  return t;
}, nD, aD = (e, u, F) => (u in e) ? nD(e, u, { enumerable: true, configurable: true, writable: true, value: F }) : e[u] = F, a = (e, u, F) => (aD(e, typeof u != "symbol" ? u + "" : u, F), F), V, z, xD, BD, cD, AD = (e, u, F) => (u in e) ? cD(e, u, { enumerable: true, configurable: true, writable: true, value: F }) : e[u] = F, G = (e, u, F) => (AD(e, typeof u != "symbol" ? u + "" : u, F), F), pD, fD, gD = (e, u, F) => (u in e) ? fD(e, u, { enumerable: true, configurable: true, writable: true, value: F }) : e[u] = F, K = (e, u, F) => (gD(e, typeof u != "symbol" ? u + "" : u, F), F), vD, mD, dD = (e, u, F) => (u in e) ? mD(e, u, { enumerable: true, configurable: true, writable: true, value: F }) : e[u] = F, Y = (e, u, F) => (dD(e, typeof u != "symbol" ? u + "" : u, F), F), bD, wD, yD = (e, u, F) => (u in e) ? wD(e, u, { enumerable: true, configurable: true, writable: true, value: F }) : e[u] = F, Z = (e, u, F) => (yD(e, typeof u != "symbol" ? u + "" : u, F), F), $D, kD, _D = (e, u, F) => (u in e) ? kD(e, u, { enumerable: true, configurable: true, writable: true, value: F }) : e[u] = F, H = (e, u, F) => (_D(e, typeof u != "symbol" ? u + "" : u, F), F), SD, TD, jD = (e, u, F) => (u in e) ? TD(e, u, { enumerable: true, configurable: true, writable: true, value: F }) : e[u] = F, MD = (e, u, F) => (jD(e, typeof u != "symbol" ? u + "" : u, F), F), PD, WD;
var init_dist = __esm(() => {
  import_sisteransi = __toESM(require_src(), 1);
  import_picocolors4 = __toESM(require_picocolors(), 1);
  J = q();
  j = { exports: {} };
  (function(e) {
    var u = {};
    e.exports = u, u.eastAsianWidth = function(t) {
      var s = t.charCodeAt(0), C = t.length == 2 ? t.charCodeAt(1) : 0, D = s;
      return 55296 <= s && s <= 56319 && 56320 <= C && C <= 57343 && (s &= 1023, C &= 1023, D = s << 10 | C, D += 65536), D == 12288 || 65281 <= D && D <= 65376 || 65504 <= D && D <= 65510 ? "F" : D == 8361 || 65377 <= D && D <= 65470 || 65474 <= D && D <= 65479 || 65482 <= D && D <= 65487 || 65490 <= D && D <= 65495 || 65498 <= D && D <= 65500 || 65512 <= D && D <= 65518 ? "H" : 4352 <= D && D <= 4447 || 4515 <= D && D <= 4519 || 4602 <= D && D <= 4607 || 9001 <= D && D <= 9002 || 11904 <= D && D <= 11929 || 11931 <= D && D <= 12019 || 12032 <= D && D <= 12245 || 12272 <= D && D <= 12283 || 12289 <= D && D <= 12350 || 12353 <= D && D <= 12438 || 12441 <= D && D <= 12543 || 12549 <= D && D <= 12589 || 12593 <= D && D <= 12686 || 12688 <= D && D <= 12730 || 12736 <= D && D <= 12771 || 12784 <= D && D <= 12830 || 12832 <= D && D <= 12871 || 12880 <= D && D <= 13054 || 13056 <= D && D <= 19903 || 19968 <= D && D <= 42124 || 42128 <= D && D <= 42182 || 43360 <= D && D <= 43388 || 44032 <= D && D <= 55203 || 55216 <= D && D <= 55238 || 55243 <= D && D <= 55291 || 63744 <= D && D <= 64255 || 65040 <= D && D <= 65049 || 65072 <= D && D <= 65106 || 65108 <= D && D <= 65126 || 65128 <= D && D <= 65131 || 110592 <= D && D <= 110593 || 127488 <= D && D <= 127490 || 127504 <= D && D <= 127546 || 127552 <= D && D <= 127560 || 127568 <= D && D <= 127569 || 131072 <= D && D <= 194367 || 177984 <= D && D <= 196605 || 196608 <= D && D <= 262141 ? "W" : 32 <= D && D <= 126 || 162 <= D && D <= 163 || 165 <= D && D <= 166 || D == 172 || D == 175 || 10214 <= D && D <= 10221 || 10629 <= D && D <= 10630 ? "Na" : D == 161 || D == 164 || 167 <= D && D <= 168 || D == 170 || 173 <= D && D <= 174 || 176 <= D && D <= 180 || 182 <= D && D <= 186 || 188 <= D && D <= 191 || D == 198 || D == 208 || 215 <= D && D <= 216 || 222 <= D && D <= 225 || D == 230 || 232 <= D && D <= 234 || 236 <= D && D <= 237 || D == 240 || 242 <= D && D <= 243 || 247 <= D && D <= 250 || D == 252 || D == 254 || D == 257 || D == 273 || D == 275 || D == 283 || 294 <= D && D <= 295 || D == 299 || 305 <= D && D <= 307 || D == 312 || 319 <= D && D <= 322 || D == 324 || 328 <= D && D <= 331 || D == 333 || 338 <= D && D <= 339 || 358 <= D && D <= 359 || D == 363 || D == 462 || D == 464 || D == 466 || D == 468 || D == 470 || D == 472 || D == 474 || D == 476 || D == 593 || D == 609 || D == 708 || D == 711 || 713 <= D && D <= 715 || D == 717 || D == 720 || 728 <= D && D <= 731 || D == 733 || D == 735 || 768 <= D && D <= 879 || 913 <= D && D <= 929 || 931 <= D && D <= 937 || 945 <= D && D <= 961 || 963 <= D && D <= 969 || D == 1025 || 1040 <= D && D <= 1103 || D == 1105 || D == 8208 || 8211 <= D && D <= 8214 || 8216 <= D && D <= 8217 || 8220 <= D && D <= 8221 || 8224 <= D && D <= 8226 || 8228 <= D && D <= 8231 || D == 8240 || 8242 <= D && D <= 8243 || D == 8245 || D == 8251 || D == 8254 || D == 8308 || D == 8319 || 8321 <= D && D <= 8324 || D == 8364 || D == 8451 || D == 8453 || D == 8457 || D == 8467 || D == 8470 || 8481 <= D && D <= 8482 || D == 8486 || D == 8491 || 8531 <= D && D <= 8532 || 8539 <= D && D <= 8542 || 8544 <= D && D <= 8555 || 8560 <= D && D <= 8569 || D == 8585 || 8592 <= D && D <= 8601 || 8632 <= D && D <= 8633 || D == 8658 || D == 8660 || D == 8679 || D == 8704 || 8706 <= D && D <= 8707 || 8711 <= D && D <= 8712 || D == 8715 || D == 8719 || D == 8721 || D == 8725 || D == 8730 || 8733 <= D && D <= 8736 || D == 8739 || D == 8741 || 8743 <= D && D <= 8748 || D == 8750 || 8756 <= D && D <= 8759 || 8764 <= D && D <= 8765 || D == 8776 || D == 8780 || D == 8786 || 8800 <= D && D <= 8801 || 8804 <= D && D <= 8807 || 8810 <= D && D <= 8811 || 8814 <= D && D <= 8815 || 8834 <= D && D <= 8835 || 8838 <= D && D <= 8839 || D == 8853 || D == 8857 || D == 8869 || D == 8895 || D == 8978 || 9312 <= D && D <= 9449 || 9451 <= D && D <= 9547 || 9552 <= D && D <= 9587 || 9600 <= D && D <= 9615 || 9618 <= D && D <= 9621 || 9632 <= D && D <= 9633 || 9635 <= D && D <= 9641 || 9650 <= D && D <= 9651 || 9654 <= D && D <= 9655 || 9660 <= D && D <= 9661 || 9664 <= D && D <= 9665 || 9670 <= D && D <= 9672 || D == 9675 || 9678 <= D && D <= 9681 || 9698 <= D && D <= 9701 || D == 9711 || 9733 <= D && D <= 9734 || D == 9737 || 9742 <= D && D <= 9743 || 9748 <= D && D <= 9749 || D == 9756 || D == 9758 || D == 9792 || D == 9794 || 9824 <= D && D <= 9825 || 9827 <= D && D <= 9829 || 9831 <= D && D <= 9834 || 9836 <= D && D <= 9837 || D == 9839 || 9886 <= D && D <= 9887 || 9918 <= D && D <= 9919 || 9924 <= D && D <= 9933 || 9935 <= D && D <= 9953 || D == 9955 || 9960 <= D && D <= 9983 || D == 10045 || D == 10071 || 10102 <= D && D <= 10111 || 11093 <= D && D <= 11097 || 12872 <= D && D <= 12879 || 57344 <= D && D <= 63743 || 65024 <= D && D <= 65039 || D == 65533 || 127232 <= D && D <= 127242 || 127248 <= D && D <= 127277 || 127280 <= D && D <= 127337 || 127344 <= D && D <= 127386 || 917760 <= D && D <= 917999 || 983040 <= D && D <= 1048573 || 1048576 <= D && D <= 1114109 ? "A" : "N";
    }, u.characterLength = function(t) {
      var s = this.eastAsianWidth(t);
      return s == "F" || s == "W" || s == "A" ? 2 : 1;
    };
    function F(t) {
      return t.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g) || [];
    }
    u.length = function(t) {
      for (var s = F(t), C = 0, D = 0;D < s.length; D++)
        C = C + this.characterLength(s[D]);
      return C;
    }, u.slice = function(t, s, C) {
      textLen = u.length(t), s = s || 0, C = C || 1, s < 0 && (s = textLen + s), C < 0 && (C = textLen + C);
      for (var D = "", i = 0, n = F(t), E = 0;E < n.length; E++) {
        var h = n[E], o = u.length(h);
        if (i >= s - (o == 2 ? 1 : 0))
          if (i + o <= C)
            D += h;
          else
            break;
        i += o;
      }
      return D;
    };
  })(j);
  Q = j.exports;
  X = T(Q);
  uD = T(DD);
  r = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], overline: [53, 55], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], gray: [90, 39], grey: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgGray: [100, 49], bgGrey: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
  Object.keys(r.modifier);
  FD = Object.keys(r.color);
  eD = Object.keys(r.bgColor);
  [...FD];
  sD = tD();
  g = new Set(["\x1B", ""]);
  w = `${iD}8;;`;
  nD = Object.defineProperty;
  V = Symbol("clack:cancel");
  z = new Map([["k", "up"], ["j", "down"], ["h", "left"], ["l", "right"]]);
  xD = new Set(["up", "down", "left", "right", "space", "enter"]);
  BD = class BD extends x {
    get cursor() {
      return this.value ? 0 : 1;
    }
    get _value() {
      return this.cursor === 0;
    }
    constructor(u) {
      super(u, false), this.value = !!u.initialValue, this.on("value", () => {
        this.value = this._value;
      }), this.on("confirm", (F) => {
        this.output.write(import_sisteransi.cursor.move(0, -1)), this.value = F, this.state = "submit", this.close();
      }), this.on("cursor", () => {
        this.value = !this.value;
      });
    }
  };
  cD = Object.defineProperty;
  pD = class pD extends x {
    constructor(u) {
      super(u, false), G(this, "options"), G(this, "cursor", 0);
      const { options: F } = u;
      this.options = Object.entries(F).flatMap(([t, s]) => [{ value: t, group: true, label: t }, ...s.map((C) => ({ ...C, group: t }))]), this.value = [...u.initialValues ?? []], this.cursor = Math.max(this.options.findIndex(({ value: t }) => t === u.cursorAt), 0), this.on("cursor", (t) => {
        switch (t) {
          case "left":
          case "up":
            this.cursor = this.cursor === 0 ? this.options.length - 1 : this.cursor - 1;
            break;
          case "down":
          case "right":
            this.cursor = this.cursor === this.options.length - 1 ? 0 : this.cursor + 1;
            break;
          case "space":
            this.toggleValue();
            break;
        }
      });
    }
    getGroupItems(u) {
      return this.options.filter((F) => F.group === u);
    }
    isGroupSelected(u) {
      return this.getGroupItems(u).every((F) => this.value.includes(F.value));
    }
    toggleValue() {
      const u = this.options[this.cursor];
      if (u.group === true) {
        const F = u.value, t = this.getGroupItems(F);
        this.isGroupSelected(F) ? this.value = this.value.filter((s) => t.findIndex((C) => C.value === s) === -1) : this.value = [...this.value, ...t.map((s) => s.value)], this.value = Array.from(new Set(this.value));
      } else {
        const F = this.value.includes(u.value);
        this.value = F ? this.value.filter((t) => t !== u.value) : [...this.value, u.value];
      }
    }
  };
  fD = Object.defineProperty;
  vD = class extends x {
    constructor(u) {
      super(u, false), K(this, "options"), K(this, "cursor", 0), this.options = u.options, this.value = [...u.initialValues ?? []], this.cursor = Math.max(this.options.findIndex(({ value: F }) => F === u.cursorAt), 0), this.on("key", (F) => {
        F === "a" && this.toggleAll();
      }), this.on("cursor", (F) => {
        switch (F) {
          case "left":
          case "up":
            this.cursor = this.cursor === 0 ? this.options.length - 1 : this.cursor - 1;
            break;
          case "down":
          case "right":
            this.cursor = this.cursor === this.options.length - 1 ? 0 : this.cursor + 1;
            break;
          case "space":
            this.toggleValue();
            break;
        }
      });
    }
    get _value() {
      return this.options[this.cursor].value;
    }
    toggleAll() {
      const u = this.value.length === this.options.length;
      this.value = u ? [] : this.options.map((F) => F.value);
    }
    toggleValue() {
      const u = this.value.includes(this._value);
      this.value = u ? this.value.filter((F) => F !== this._value) : [...this.value, this._value];
    }
  };
  mD = Object.defineProperty;
  bD = class bD extends x {
    constructor({ mask: u, ...F }) {
      super(F), Y(this, "valueWithCursor", ""), Y(this, "_mask", ""), this._mask = u ?? "", this.on("finalize", () => {
        this.valueWithCursor = this.masked;
      }), this.on("value", () => {
        if (this.cursor >= this.value.length)
          this.valueWithCursor = `${this.masked}${import_picocolors4.default.inverse(import_picocolors4.default.hidden("_"))}`;
        else {
          const t = this.masked.slice(0, this.cursor), s = this.masked.slice(this.cursor);
          this.valueWithCursor = `${t}${import_picocolors4.default.inverse(s[0])}${s.slice(1)}`;
        }
      });
    }
    get cursor() {
      return this._cursor;
    }
    get masked() {
      return this.value.replaceAll(/./g, this._mask);
    }
  };
  wD = Object.defineProperty;
  $D = class extends x {
    constructor(u) {
      super(u, false), Z(this, "options"), Z(this, "cursor", 0), this.options = u.options, this.cursor = this.options.findIndex(({ value: F }) => F === u.initialValue), this.cursor === -1 && (this.cursor = 0), this.changeValue(), this.on("cursor", (F) => {
        switch (F) {
          case "left":
          case "up":
            this.cursor = this.cursor === 0 ? this.options.length - 1 : this.cursor - 1;
            break;
          case "down":
          case "right":
            this.cursor = this.cursor === this.options.length - 1 ? 0 : this.cursor + 1;
            break;
        }
        this.changeValue();
      });
    }
    get _value() {
      return this.options[this.cursor];
    }
    changeValue() {
      this.value = this._value.value;
    }
  };
  kD = Object.defineProperty;
  SD = class SD extends x {
    constructor(u) {
      super(u, false), H(this, "options"), H(this, "cursor", 0), this.options = u.options;
      const F = this.options.map(({ value: [t] }) => t?.toLowerCase());
      this.cursor = Math.max(F.indexOf(u.initialValue), 0), this.on("key", (t) => {
        if (!F.includes(t))
          return;
        const s = this.options.find(({ value: [C] }) => C?.toLowerCase() === t);
        s && (this.value = s.value, this.state = "submit", this.emit("submit"));
      });
    }
  };
  TD = Object.defineProperty;
  PD = class PD extends x {
    constructor(u) {
      super(u), MD(this, "valueWithCursor", ""), this.on("finalize", () => {
        this.value || (this.value = u.defaultValue), this.valueWithCursor = this.value;
      }), this.on("value", () => {
        if (this.cursor >= this.value.length)
          this.valueWithCursor = `${this.value}${import_picocolors4.default.inverse(import_picocolors4.default.hidden("_"))}`;
        else {
          const F = this.value.slice(0, this.cursor), t = this.value.slice(this.cursor);
          this.valueWithCursor = `${F}${import_picocolors4.default.inverse(t[0])}${t.slice(1)}`;
        }
      });
    }
    get cursor() {
      return this._cursor;
    }
  };
  WD = globalThis.process.platform.startsWith("win");
});

// node_modules/@clack/prompts/dist/index.mjs
var exports_dist = {};
__export(exports_dist, {
  text: () => te,
  spinner: () => de,
  selectKey: () => ne,
  select: () => ie,
  password: () => re,
  outro: () => $e,
  note: () => le,
  multiselect: () => ae,
  log: () => f2,
  isCancel: () => lD,
  intro: () => oe,
  groupMultiselect: () => ce,
  group: () => he,
  confirm: () => se,
  cancel: () => ue
});
import h from "node:process";
function q2() {
  return h.platform !== "win32" ? h.env.TERM !== "linux" : Boolean(h.env.CI) || Boolean(h.env.WT_SESSION) || Boolean(h.env.TERMINUS_SUBLIME) || h.env.ConEmuTask === "{cmd::Cmder}" || h.env.TERM_PROGRAM === "Terminus-Sublime" || h.env.TERM_PROGRAM === "vscode" || h.env.TERM === "xterm-256color" || h.env.TERM === "alacritty" || h.env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}
function me() {
  const r2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"].join("|");
  return new RegExp(r2, "g");
}
var import_picocolors5, import_sisteransi2, _2, o = (r2, n) => _2 ? r2 : n, H2, I2, x2, S2, K2, a2, d2, b2, E, C, w2, M2, U2, B, Z2, z2, X2, J2, Y2, Q2, ee, y2 = (r2) => {
  switch (r2) {
    case "initial":
    case "active":
      return import_picocolors5.default.cyan(H2);
    case "cancel":
      return import_picocolors5.default.red(I2);
    case "error":
      return import_picocolors5.default.yellow(x2);
    case "submit":
      return import_picocolors5.default.green(S2);
  }
}, te = (r2) => new PD({ validate: r2.validate, placeholder: r2.placeholder, defaultValue: r2.defaultValue, initialValue: r2.initialValue, render() {
  const n = `${import_picocolors5.default.gray(a2)}
${y2(this.state)}  ${r2.message}
`, i = r2.placeholder ? import_picocolors5.default.inverse(r2.placeholder[0]) + import_picocolors5.default.dim(r2.placeholder.slice(1)) : import_picocolors5.default.inverse(import_picocolors5.default.hidden("_")), t = this.value ? this.valueWithCursor : i;
  switch (this.state) {
    case "error":
      return `${n.trim()}
${import_picocolors5.default.yellow(a2)}  ${t}
${import_picocolors5.default.yellow(d2)}  ${import_picocolors5.default.yellow(this.error)}
`;
    case "submit":
      return `${n}${import_picocolors5.default.gray(a2)}  ${import_picocolors5.default.dim(this.value || r2.placeholder)}`;
    case "cancel":
      return `${n}${import_picocolors5.default.gray(a2)}  ${import_picocolors5.default.strikethrough(import_picocolors5.default.dim(this.value ?? ""))}${this.value?.trim() ? `
` + import_picocolors5.default.gray(a2) : ""}`;
    default:
      return `${n}${import_picocolors5.default.cyan(a2)}  ${t}
${import_picocolors5.default.cyan(d2)}
`;
  }
} }).prompt(), re = (r2) => new bD({ validate: r2.validate, mask: r2.mask ?? U2, render() {
  const n = `${import_picocolors5.default.gray(a2)}
${y2(this.state)}  ${r2.message}
`, i = this.valueWithCursor, t = this.masked;
  switch (this.state) {
    case "error":
      return `${n.trim()}
${import_picocolors5.default.yellow(a2)}  ${t}
${import_picocolors5.default.yellow(d2)}  ${import_picocolors5.default.yellow(this.error)}
`;
    case "submit":
      return `${n}${import_picocolors5.default.gray(a2)}  ${import_picocolors5.default.dim(t)}`;
    case "cancel":
      return `${n}${import_picocolors5.default.gray(a2)}  ${import_picocolors5.default.strikethrough(import_picocolors5.default.dim(t ?? ""))}${t ? `
` + import_picocolors5.default.gray(a2) : ""}`;
    default:
      return `${n}${import_picocolors5.default.cyan(a2)}  ${i}
${import_picocolors5.default.cyan(d2)}
`;
  }
} }).prompt(), se = (r2) => {
  const n = r2.active ?? "Yes", i = r2.inactive ?? "No";
  return new BD({ active: n, inactive: i, initialValue: r2.initialValue ?? true, render() {
    const t = `${import_picocolors5.default.gray(a2)}
${y2(this.state)}  ${r2.message}
`, s = this.value ? n : i;
    switch (this.state) {
      case "submit":
        return `${t}${import_picocolors5.default.gray(a2)}  ${import_picocolors5.default.dim(s)}`;
      case "cancel":
        return `${t}${import_picocolors5.default.gray(a2)}  ${import_picocolors5.default.strikethrough(import_picocolors5.default.dim(s))}
${import_picocolors5.default.gray(a2)}`;
      default:
        return `${t}${import_picocolors5.default.cyan(a2)}  ${this.value ? `${import_picocolors5.default.green(b2)} ${n}` : `${import_picocolors5.default.dim(E)} ${import_picocolors5.default.dim(n)}`} ${import_picocolors5.default.dim("/")} ${this.value ? `${import_picocolors5.default.dim(E)} ${import_picocolors5.default.dim(i)}` : `${import_picocolors5.default.green(b2)} ${i}`}
${import_picocolors5.default.cyan(d2)}
`;
    }
  } }).prompt();
}, ie = (r2) => {
  const n = (t, s) => {
    const c2 = t.label ?? String(t.value);
    return s === "active" ? `${import_picocolors5.default.green(b2)} ${c2} ${t.hint ? import_picocolors5.default.dim(`(${t.hint})`) : ""}` : s === "selected" ? `${import_picocolors5.default.dim(c2)}` : s === "cancelled" ? `${import_picocolors5.default.strikethrough(import_picocolors5.default.dim(c2))}` : `${import_picocolors5.default.dim(E)} ${import_picocolors5.default.dim(c2)}`;
  };
  let i = 0;
  return new $D({ options: r2.options, initialValue: r2.initialValue, render() {
    const t = `${import_picocolors5.default.gray(a2)}
${y2(this.state)}  ${r2.message}
`;
    switch (this.state) {
      case "submit":
        return `${t}${import_picocolors5.default.gray(a2)}  ${n(this.options[this.cursor], "selected")}`;
      case "cancel":
        return `${t}${import_picocolors5.default.gray(a2)}  ${n(this.options[this.cursor], "cancelled")}
${import_picocolors5.default.gray(a2)}`;
      default: {
        const s = r2.maxItems === undefined ? 1 / 0 : Math.max(r2.maxItems, 5);
        this.cursor >= i + s - 3 ? i = Math.max(Math.min(this.cursor - s + 3, this.options.length - s), 0) : this.cursor < i + 2 && (i = Math.max(this.cursor - 2, 0));
        const c2 = s < this.options.length && i > 0, l2 = s < this.options.length && i + s < this.options.length;
        return `${t}${import_picocolors5.default.cyan(a2)}  ${this.options.slice(i, i + s).map((u, m2, $2) => m2 === 0 && c2 ? import_picocolors5.default.dim("...") : m2 === $2.length - 1 && l2 ? import_picocolors5.default.dim("...") : n(u, m2 + i === this.cursor ? "active" : "inactive")).join(`
${import_picocolors5.default.cyan(a2)}  `)}
${import_picocolors5.default.cyan(d2)}
`;
      }
    }
  } }).prompt();
}, ne = (r2) => {
  const n = (i, t = "inactive") => {
    const s = i.label ?? String(i.value);
    return t === "selected" ? `${import_picocolors5.default.dim(s)}` : t === "cancelled" ? `${import_picocolors5.default.strikethrough(import_picocolors5.default.dim(s))}` : t === "active" ? `${import_picocolors5.default.bgCyan(import_picocolors5.default.gray(` ${i.value} `))} ${s} ${i.hint ? import_picocolors5.default.dim(`(${i.hint})`) : ""}` : `${import_picocolors5.default.gray(import_picocolors5.default.bgWhite(import_picocolors5.default.inverse(` ${i.value} `)))} ${s} ${i.hint ? import_picocolors5.default.dim(`(${i.hint})`) : ""}`;
  };
  return new SD({ options: r2.options, initialValue: r2.initialValue, render() {
    const i = `${import_picocolors5.default.gray(a2)}
${y2(this.state)}  ${r2.message}
`;
    switch (this.state) {
      case "submit":
        return `${i}${import_picocolors5.default.gray(a2)}  ${n(this.options.find((t) => t.value === this.value), "selected")}`;
      case "cancel":
        return `${i}${import_picocolors5.default.gray(a2)}  ${n(this.options[0], "cancelled")}
${import_picocolors5.default.gray(a2)}`;
      default:
        return `${i}${import_picocolors5.default.cyan(a2)}  ${this.options.map((t, s) => n(t, s === this.cursor ? "active" : "inactive")).join(`
${import_picocolors5.default.cyan(a2)}  `)}
${import_picocolors5.default.cyan(d2)}
`;
    }
  } }).prompt();
}, ae = (r2) => {
  const n = (i, t) => {
    const s = i.label ?? String(i.value);
    return t === "active" ? `${import_picocolors5.default.cyan(C)} ${s} ${i.hint ? import_picocolors5.default.dim(`(${i.hint})`) : ""}` : t === "selected" ? `${import_picocolors5.default.green(w2)} ${import_picocolors5.default.dim(s)}` : t === "cancelled" ? `${import_picocolors5.default.strikethrough(import_picocolors5.default.dim(s))}` : t === "active-selected" ? `${import_picocolors5.default.green(w2)} ${s} ${i.hint ? import_picocolors5.default.dim(`(${i.hint})`) : ""}` : t === "submitted" ? `${import_picocolors5.default.dim(s)}` : `${import_picocolors5.default.dim(M2)} ${import_picocolors5.default.dim(s)}`;
  };
  return new vD({ options: r2.options, initialValues: r2.initialValues, required: r2.required ?? true, cursorAt: r2.cursorAt, validate(i) {
    if (this.required && i.length === 0)
      return `Please select at least one option.
${import_picocolors5.default.reset(import_picocolors5.default.dim(`Press ${import_picocolors5.default.gray(import_picocolors5.default.bgWhite(import_picocolors5.default.inverse(" space ")))} to select, ${import_picocolors5.default.gray(import_picocolors5.default.bgWhite(import_picocolors5.default.inverse(" enter ")))} to submit`))}`;
  }, render() {
    let i = `${import_picocolors5.default.gray(a2)}
${y2(this.state)}  ${r2.message}
`;
    switch (this.state) {
      case "submit":
        return `${i}${import_picocolors5.default.gray(a2)}  ${this.options.filter(({ value: t }) => this.value.includes(t)).map((t) => n(t, "submitted")).join(import_picocolors5.default.dim(", ")) || import_picocolors5.default.dim("none")}`;
      case "cancel": {
        const t = this.options.filter(({ value: s }) => this.value.includes(s)).map((s) => n(s, "cancelled")).join(import_picocolors5.default.dim(", "));
        return `${i}${import_picocolors5.default.gray(a2)}  ${t.trim() ? `${t}
${import_picocolors5.default.gray(a2)}` : ""}`;
      }
      case "error": {
        const t = this.error.split(`
`).map((s, c2) => c2 === 0 ? `${import_picocolors5.default.yellow(d2)}  ${import_picocolors5.default.yellow(s)}` : `   ${s}`).join(`
`);
        return i + import_picocolors5.default.yellow(a2) + "  " + this.options.map((s, c2) => {
          const l2 = this.value.includes(s.value), u = c2 === this.cursor;
          return u && l2 ? n(s, "active-selected") : l2 ? n(s, "selected") : n(s, u ? "active" : "inactive");
        }).join(`
${import_picocolors5.default.yellow(a2)}  `) + `
` + t + `
`;
      }
      default:
        return `${i}${import_picocolors5.default.cyan(a2)}  ${this.options.map((t, s) => {
          const c2 = this.value.includes(t.value), l2 = s === this.cursor;
          return l2 && c2 ? n(t, "active-selected") : c2 ? n(t, "selected") : n(t, l2 ? "active" : "inactive");
        }).join(`
${import_picocolors5.default.cyan(a2)}  `)}
${import_picocolors5.default.cyan(d2)}
`;
    }
  } }).prompt();
}, ce = (r2) => {
  const n = (i, t, s = []) => {
    const c2 = i.label ?? String(i.value), l2 = typeof i.group == "string", u = l2 && (s[s.indexOf(i) + 1] ?? { group: true }), m2 = l2 && u.group === true, $2 = l2 ? `${m2 ? d2 : a2} ` : "";
    return t === "active" ? `${import_picocolors5.default.dim($2)}${import_picocolors5.default.cyan(C)} ${c2} ${i.hint ? import_picocolors5.default.dim(`(${i.hint})`) : ""}` : t === "group-active" ? `${$2}${import_picocolors5.default.cyan(C)} ${import_picocolors5.default.dim(c2)}` : t === "group-active-selected" ? `${$2}${import_picocolors5.default.green(w2)} ${import_picocolors5.default.dim(c2)}` : t === "selected" ? `${import_picocolors5.default.dim($2)}${import_picocolors5.default.green(w2)} ${import_picocolors5.default.dim(c2)}` : t === "cancelled" ? `${import_picocolors5.default.strikethrough(import_picocolors5.default.dim(c2))}` : t === "active-selected" ? `${import_picocolors5.default.dim($2)}${import_picocolors5.default.green(w2)} ${c2} ${i.hint ? import_picocolors5.default.dim(`(${i.hint})`) : ""}` : t === "submitted" ? `${import_picocolors5.default.dim(c2)}` : `${import_picocolors5.default.dim($2)}${import_picocolors5.default.dim(M2)} ${import_picocolors5.default.dim(c2)}`;
  };
  return new pD({ options: r2.options, initialValues: r2.initialValues, required: r2.required ?? true, cursorAt: r2.cursorAt, validate(i) {
    if (this.required && i.length === 0)
      return `Please select at least one option.
${import_picocolors5.default.reset(import_picocolors5.default.dim(`Press ${import_picocolors5.default.gray(import_picocolors5.default.bgWhite(import_picocolors5.default.inverse(" space ")))} to select, ${import_picocolors5.default.gray(import_picocolors5.default.bgWhite(import_picocolors5.default.inverse(" enter ")))} to submit`))}`;
  }, render() {
    let i = `${import_picocolors5.default.gray(a2)}
${y2(this.state)}  ${r2.message}
`;
    switch (this.state) {
      case "submit":
        return `${i}${import_picocolors5.default.gray(a2)}  ${this.options.filter(({ value: t }) => this.value.includes(t)).map((t) => n(t, "submitted")).join(import_picocolors5.default.dim(", "))}`;
      case "cancel": {
        const t = this.options.filter(({ value: s }) => this.value.includes(s)).map((s) => n(s, "cancelled")).join(import_picocolors5.default.dim(", "));
        return `${i}${import_picocolors5.default.gray(a2)}  ${t.trim() ? `${t}
${import_picocolors5.default.gray(a2)}` : ""}`;
      }
      case "error": {
        const t = this.error.split(`
`).map((s, c2) => c2 === 0 ? `${import_picocolors5.default.yellow(d2)}  ${import_picocolors5.default.yellow(s)}` : `   ${s}`).join(`
`);
        return `${i}${import_picocolors5.default.yellow(a2)}  ${this.options.map((s, c2, l2) => {
          const u = this.value.includes(s.value) || s.group === true && this.isGroupSelected(`${s.value}`), m2 = c2 === this.cursor;
          return !m2 && typeof s.group == "string" && this.options[this.cursor].value === s.group ? n(s, u ? "group-active-selected" : "group-active", l2) : m2 && u ? n(s, "active-selected", l2) : u ? n(s, "selected", l2) : n(s, m2 ? "active" : "inactive", l2);
        }).join(`
${import_picocolors5.default.yellow(a2)}  `)}
${t}
`;
      }
      default:
        return `${i}${import_picocolors5.default.cyan(a2)}  ${this.options.map((t, s, c2) => {
          const l2 = this.value.includes(t.value) || t.group === true && this.isGroupSelected(`${t.value}`), u = s === this.cursor;
          return !u && typeof t.group == "string" && this.options[this.cursor].value === t.group ? n(t, l2 ? "group-active-selected" : "group-active", c2) : u && l2 ? n(t, "active-selected", c2) : l2 ? n(t, "selected", c2) : n(t, u ? "active" : "inactive", c2);
        }).join(`
${import_picocolors5.default.cyan(a2)}  `)}
${import_picocolors5.default.cyan(d2)}
`;
    }
  } }).prompt();
}, R2 = (r2) => r2.replace(me(), ""), le = (r2 = "", n = "") => {
  const i = `
${r2}
`.split(`
`), t = R2(n).length, s = Math.max(i.reduce((l2, u) => (u = R2(u), u.length > l2 ? u.length : l2), 0), t) + 2, c2 = i.map((l2) => `${import_picocolors5.default.gray(a2)}  ${import_picocolors5.default.dim(l2)}${" ".repeat(s - R2(l2).length)}${import_picocolors5.default.gray(a2)}`).join(`
`);
  process.stdout.write(`${import_picocolors5.default.gray(a2)}
${import_picocolors5.default.green(S2)}  ${import_picocolors5.default.reset(n)} ${import_picocolors5.default.gray(B.repeat(Math.max(s - t - 1, 1)) + Z2)}
${c2}
${import_picocolors5.default.gray(z2 + B.repeat(s + 2) + X2)}
`);
}, ue = (r2 = "") => {
  process.stdout.write(`${import_picocolors5.default.gray(d2)}  ${import_picocolors5.default.red(r2)}

`);
}, oe = (r2 = "") => {
  process.stdout.write(`${import_picocolors5.default.gray(K2)}  ${r2}
`);
}, $e = (r2 = "") => {
  process.stdout.write(`${import_picocolors5.default.gray(a2)}
${import_picocolors5.default.gray(d2)}  ${r2}

`);
}, f2, de = () => {
  const r2 = _2 ? ["", "", "", ""] : ["", "o", "O", "0"], n = _2 ? 80 : 120;
  let i, t, s = false, c2 = "";
  const l2 = (v2 = "") => {
    s = true, i = OD(), c2 = v2.replace(/\.+$/, ""), process.stdout.write(`${import_picocolors5.default.gray(a2)}
`);
    let g2 = 0, p = 0;
    t = setInterval(() => {
      const O2 = import_picocolors5.default.magenta(r2[g2]), P2 = ".".repeat(Math.floor(p)).slice(0, 3);
      process.stdout.write(import_sisteransi2.cursor.move(-999, 0)), process.stdout.write(import_sisteransi2.erase.down(1)), process.stdout.write(`${O2}  ${c2}${P2}`), g2 = g2 + 1 < r2.length ? g2 + 1 : 0, p = p < r2.length ? p + 0.125 : 0;
    }, n);
  }, u = (v2 = "", g2 = 0) => {
    c2 = v2 ?? c2, s = false, clearInterval(t);
    const p = g2 === 0 ? import_picocolors5.default.green(S2) : g2 === 1 ? import_picocolors5.default.red(I2) : import_picocolors5.default.red(x2);
    process.stdout.write(import_sisteransi2.cursor.move(-999, 0)), process.stdout.write(import_sisteransi2.erase.down(1)), process.stdout.write(`${p}  ${c2}
`), i();
  }, m2 = (v2 = "") => {
    c2 = v2 ?? c2;
  }, $2 = (v2) => {
    const g2 = v2 > 1 ? "Something went wrong" : "Canceled";
    s && u(g2, v2);
  };
  return process.on("uncaughtExceptionMonitor", () => $2(2)), process.on("unhandledRejection", () => $2(2)), process.on("SIGINT", () => $2(1)), process.on("SIGTERM", () => $2(1)), process.on("exit", $2), { start: l2, stop: u, message: m2 };
}, he = async (r2, n) => {
  const i = {}, t = Object.keys(r2);
  for (const s of t) {
    const c2 = r2[s], l2 = await c2({ results: i })?.catch((u) => {
      throw u;
    });
    if (typeof n?.onCancel == "function" && lD(l2)) {
      i[s] = "canceled", n.onCancel({ results: i });
      continue;
    }
    i[s] = l2;
  }
  return i;
};
var init_dist2 = __esm(() => {
  init_dist();
  init_dist();
  import_picocolors5 = __toESM(require_picocolors(), 1);
  import_sisteransi2 = __toESM(require_src(), 1);
  _2 = q2();
  H2 = o("", "*");
  I2 = o("", "x");
  x2 = o("", "x");
  S2 = o("", "o");
  K2 = o("", "T");
  a2 = o("", "|");
  d2 = o("", "");
  b2 = o("", ">");
  E = o("", " ");
  C = o("", "[]");
  w2 = o("", "[+]");
  M2 = o("", "[ ]");
  U2 = o("", "");
  B = o("", "-");
  Z2 = o("", "+");
  z2 = o("", "+");
  X2 = o("", "+");
  J2 = o("", "");
  Y2 = o("", "*");
  Q2 = o("", "!");
  ee = o("", "x");
  f2 = { message: (r2 = "", { symbol: n = import_picocolors5.default.gray(a2) } = {}) => {
    const i = [`${import_picocolors5.default.gray(a2)}`];
    if (r2) {
      const [t, ...s] = r2.split(`
`);
      i.push(`${n}  ${t}`, ...s.map((c2) => `${import_picocolors5.default.gray(a2)}  ${c2}`));
    }
    process.stdout.write(`${i.join(`
`)}
`);
  }, info: (r2) => {
    f2.message(r2, { symbol: import_picocolors5.default.blue(J2) });
  }, success: (r2) => {
    f2.message(r2, { symbol: import_picocolors5.default.green(Y2) });
  }, step: (r2) => {
    f2.message(r2, { symbol: import_picocolors5.default.green(S2) });
  }, warn: (r2) => {
    f2.message(r2, { symbol: import_picocolors5.default.yellow(Q2) });
  }, warning: (r2) => {
    f2.warn(r2);
  }, error: (r2) => {
    f2.message(r2, { symbol: import_picocolors5.default.red(ee) });
  } };
});

// src/types/kit.ts
function isValidKitType(value) {
  return value === "engineer" || value === "marketing";
}
var KitType, KitConfigSchema, AVAILABLE_KITS, NEVER_COPY_PATTERNS, USER_CONFIG_PATTERNS, PROTECTED_PATTERNS;
var init_kit = __esm(() => {
  init_zod();
  KitType = exports_external.enum(["engineer", "marketing"]);
  KitConfigSchema = exports_external.object({
    name: exports_external.string(),
    repo: exports_external.string(),
    owner: exports_external.string(),
    description: exports_external.string()
  });
  AVAILABLE_KITS = {
    engineer: {
      name: "ClaudeKit Engineer",
      repo: "claudekit-engineer",
      owner: "hungtq-inisoft",
      description: "Engineering toolkit for building with Claude"
    },
    marketing: {
      name: "ClaudeKit Marketing",
      repo: "claudekit-marketing",
      owner: "hungtq-inisoft",
      description: "Marketing automation toolkit for Claude"
    }
  };
  NEVER_COPY_PATTERNS = [
    ".env",
    ".env.local",
    ".env.*.local",
    "*.key",
    "*.pem",
    "*.p12",
    "node_modules/**",
    ".git/**",
    "dist/**",
    "build/**",
    ".venv/**",
    "venv/**",
    "__pycache__/**",
    "**/.venv/**",
    "**/venv/**",
    "**/__pycache__/**"
  ];
  USER_CONFIG_PATTERNS = [
    ".gitignore",
    ".repomixignore",
    ".mcp.json",
    ".ckignore",
    ".ck.json",
    "CLAUDE.md"
  ];
  PROTECTED_PATTERNS = [...NEVER_COPY_PATTERNS, ...USER_CONFIG_PATTERNS];
});

// src/types/commands.ts
var GlobalOutputOptionsSchema, ExcludePatternSchema, FoldersConfigSchema, DEFAULT_FOLDERS, NewCommandOptionsSchema, UpdateCommandOptionsSchema, VersionCommandOptionsSchema, UninstallCommandOptionsSchema, UpdateCliOptionsSchema, DoctorCommandOptionsSchema;
var init_commands = __esm(() => {
  init_zod();
  init_kit();
  GlobalOutputOptionsSchema = exports_external.object({
    verbose: exports_external.boolean().default(false),
    json: exports_external.boolean().default(false)
  });
  ExcludePatternSchema = exports_external.string().trim().min(1, "Exclude pattern cannot be empty").max(500, "Exclude pattern too long").refine((val) => !val.startsWith("/"), "Absolute paths not allowed in exclude patterns").refine((val) => !val.includes(".."), "Path traversal not allowed in exclude patterns");
  FoldersConfigSchema = exports_external.object({
    docs: exports_external.string().optional(),
    plans: exports_external.string().optional()
  });
  DEFAULT_FOLDERS = {
    docs: "docs",
    plans: "plans"
  };
  NewCommandOptionsSchema = exports_external.object({
    dir: exports_external.string().default("."),
    kit: exports_external.string().optional(),
    release: exports_external.string().min(1, "Release tag cannot be empty").optional(),
    force: exports_external.boolean().default(false),
    exclude: exports_external.array(ExcludePatternSchema).optional().default([]),
    opencode: exports_external.boolean().default(false),
    gemini: exports_external.boolean().default(false),
    installSkills: exports_external.boolean().default(false),
    withSudo: exports_external.boolean().default(false),
    prefix: exports_external.boolean().default(false),
    beta: exports_external.boolean().default(false),
    dryRun: exports_external.boolean().default(false),
    refresh: exports_external.boolean().default(false),
    docsDir: exports_external.string().optional(),
    plansDir: exports_external.string().optional(),
    yes: exports_external.boolean().default(false),
    useGit: exports_external.boolean().default(false),
    archive: exports_external.string().optional(),
    kitPath: exports_external.string().optional()
  }).merge(GlobalOutputOptionsSchema);
  UpdateCommandOptionsSchema = exports_external.object({
    dir: exports_external.string().default("."),
    kit: exports_external.string().optional(),
    release: exports_external.string().min(1, "Release tag cannot be empty").optional(),
    exclude: exports_external.array(ExcludePatternSchema).optional().default([]),
    only: exports_external.array(ExcludePatternSchema).optional().default([]),
    global: exports_external.boolean().default(false),
    fresh: exports_external.boolean().default(false),
    installSkills: exports_external.boolean().default(false),
    withSudo: exports_external.boolean().default(false),
    prefix: exports_external.boolean().default(false),
    beta: exports_external.boolean().default(false),
    dryRun: exports_external.boolean().default(false),
    forceOverwrite: exports_external.boolean().default(false),
    forceOverwriteSettings: exports_external.boolean().default(false),
    skipSetup: exports_external.boolean().default(false),
    refresh: exports_external.boolean().default(false),
    docsDir: exports_external.string().optional(),
    plansDir: exports_external.string().optional(),
    yes: exports_external.boolean().default(false),
    sync: exports_external.boolean().default(false),
    useGit: exports_external.boolean().default(false),
    archive: exports_external.string().optional(),
    kitPath: exports_external.string().optional()
  }).merge(GlobalOutputOptionsSchema);
  VersionCommandOptionsSchema = exports_external.object({
    kit: KitType.optional(),
    limit: exports_external.number().optional(),
    all: exports_external.boolean().optional()
  }).merge(GlobalOutputOptionsSchema);
  UninstallCommandOptionsSchema = exports_external.object({
    yes: exports_external.boolean().default(false),
    local: exports_external.boolean().default(false),
    global: exports_external.boolean().default(false),
    all: exports_external.boolean().default(false),
    dryRun: exports_external.boolean().default(false),
    forceOverwrite: exports_external.boolean().default(false),
    kit: KitType.optional()
  }).merge(GlobalOutputOptionsSchema);
  UpdateCliOptionsSchema = exports_external.object({
    release: exports_external.string().optional(),
    check: exports_external.boolean().default(false),
    yes: exports_external.boolean().default(false),
    beta: exports_external.boolean().default(false),
    registry: exports_external.string().url().optional()
  }).merge(GlobalOutputOptionsSchema);
  DoctorCommandOptionsSchema = exports_external.object({
    report: exports_external.boolean().default(false),
    fix: exports_external.boolean().default(false),
    checkOnly: exports_external.boolean().default(false),
    full: exports_external.boolean().default(false)
  }).merge(GlobalOutputOptionsSchema);
});

// src/types/github.ts
var GitHubReleaseAssetSchema, GitHubReleaseSchema;
var init_github = __esm(() => {
  init_zod();
  GitHubReleaseAssetSchema = exports_external.object({
    id: exports_external.number(),
    name: exports_external.string(),
    url: exports_external.string().url(),
    browser_download_url: exports_external.string().url(),
    size: exports_external.number(),
    content_type: exports_external.string()
  });
  GitHubReleaseSchema = exports_external.object({
    id: exports_external.number(),
    tag_name: exports_external.string(),
    name: exports_external.string(),
    draft: exports_external.boolean(),
    prerelease: exports_external.boolean(),
    assets: exports_external.array(GitHubReleaseAssetSchema),
    published_at: exports_external.string().optional(),
    tarball_url: exports_external.string().url(),
    zipball_url: exports_external.string().url()
  });
});

// src/types/metadata.ts
var TrackedFileSchema, InstalledSettingsSchema, KitMetadataSchema, MultiKitMetadataSchema, LegacyMetadataSchema, MetadataSchema, DownloadMethodSchema, ConfigSchema;
var init_metadata = __esm(() => {
  init_zod();
  init_commands();
  init_kit();
  TrackedFileSchema = exports_external.object({
    path: exports_external.string(),
    checksum: exports_external.string().regex(/^[a-f0-9]{64}$/, "Invalid SHA-256 checksum"),
    ownership: exports_external.enum(["ck", "user", "ck-modified"]),
    installedVersion: exports_external.string(),
    baseChecksum: exports_external.string().regex(/^[a-f0-9]{64}$/, "Invalid SHA-256 checksum").optional(),
    sourceTimestamp: exports_external.string().datetime({ offset: true }).optional(),
    installedAt: exports_external.string().datetime({ offset: true }).optional()
  });
  InstalledSettingsSchema = exports_external.object({
    hooks: exports_external.array(exports_external.string()).optional(),
    mcpServers: exports_external.array(exports_external.string()).optional(),
    hookTimestamps: exports_external.record(exports_external.string()).optional(),
    mcpServerTimestamps: exports_external.record(exports_external.string()).optional()
  });
  KitMetadataSchema = exports_external.object({
    version: exports_external.string(),
    installedAt: exports_external.string(),
    files: exports_external.array(TrackedFileSchema).optional(),
    lastUpdateCheck: exports_external.string().optional(),
    dismissedVersion: exports_external.string().optional(),
    installedSettings: InstalledSettingsSchema.optional()
  });
  MultiKitMetadataSchema = exports_external.object({
    kits: exports_external.record(KitType, KitMetadataSchema).optional(),
    scope: exports_external.enum(["local", "global"]).optional(),
    name: exports_external.string().optional(),
    version: exports_external.string().optional(),
    installedAt: exports_external.string().optional(),
    installedFiles: exports_external.array(exports_external.string()).optional(),
    userConfigFiles: exports_external.array(exports_external.string()).optional(),
    files: exports_external.array(TrackedFileSchema).optional()
  });
  LegacyMetadataSchema = exports_external.object({
    name: exports_external.string().optional(),
    version: exports_external.string().optional(),
    installedAt: exports_external.string().optional(),
    scope: exports_external.enum(["local", "global"]).optional(),
    installedFiles: exports_external.array(exports_external.string()).optional(),
    userConfigFiles: exports_external.array(exports_external.string()).optional(),
    files: exports_external.array(TrackedFileSchema).optional()
  });
  MetadataSchema = MultiKitMetadataSchema;
  DownloadMethodSchema = exports_external.enum(["auto", "git", "api"]);
  ConfigSchema = exports_external.object({
    defaults: exports_external.object({
      kit: KitType.optional(),
      dir: exports_external.string().optional()
    }).optional(),
    folders: FoldersConfigSchema.optional(),
    downloadMethod: DownloadMethodSchema.optional()
  });
});

// src/types/skills.ts
var SkillsManifestSchema;
var init_skills = __esm(() => {
  init_zod();
  SkillsManifestSchema = exports_external.object({
    version: exports_external.string(),
    structure: exports_external.enum(["flat", "categorized"]),
    timestamp: exports_external.string(),
    skills: exports_external.array(exports_external.object({
      name: exports_external.string(),
      category: exports_external.string().optional(),
      hash: exports_external.string().optional()
    }))
  });
});

// src/types/errors.ts
var ClaudeKitError, AuthenticationError, GitHubError, DownloadError, ExtractionError, SkillsMigrationError;
var init_errors2 = __esm(() => {
  ClaudeKitError = class ClaudeKitError extends Error {
    code;
    statusCode;
    constructor(message, code, statusCode) {
      super(message);
      this.code = code;
      this.statusCode = statusCode;
      this.name = "ClaudeKitError";
    }
  };
  AuthenticationError = class AuthenticationError extends ClaudeKitError {
    constructor(message) {
      super(message, "AUTH_ERROR", 401);
      this.name = "AuthenticationError";
    }
  };
  GitHubError = class GitHubError extends ClaudeKitError {
    constructor(message, statusCode) {
      super(message, "GITHUB_ERROR", statusCode);
      this.name = "GitHubError";
    }
  };
  DownloadError = class DownloadError extends ClaudeKitError {
    constructor(message) {
      super(message, "DOWNLOAD_ERROR");
      this.name = "DownloadError";
    }
  };
  ExtractionError = class ExtractionError extends ClaudeKitError {
    constructor(message) {
      super(message, "EXTRACTION_ERROR");
      this.name = "ExtractionError";
    }
  };
  SkillsMigrationError = class SkillsMigrationError extends ClaudeKitError {
    constructor(message) {
      super(message, "SKILLS_MIGRATION_ERROR");
      this.name = "SkillsMigrationError";
    }
  };
});

// src/types/index.ts
var exports_types = {};
__export(exports_types, {
  isValidKitType: () => isValidKitType,
  VersionCommandOptionsSchema: () => VersionCommandOptionsSchema,
  UpdateCommandOptionsSchema: () => UpdateCommandOptionsSchema,
  UpdateCliOptionsSchema: () => UpdateCliOptionsSchema,
  UninstallCommandOptionsSchema: () => UninstallCommandOptionsSchema,
  USER_CONFIG_PATTERNS: () => USER_CONFIG_PATTERNS,
  TrackedFileSchema: () => TrackedFileSchema,
  SkillsMigrationError: () => SkillsMigrationError,
  SkillsManifestSchema: () => SkillsManifestSchema,
  PROTECTED_PATTERNS: () => PROTECTED_PATTERNS,
  NewCommandOptionsSchema: () => NewCommandOptionsSchema,
  NEVER_COPY_PATTERNS: () => NEVER_COPY_PATTERNS,
  MultiKitMetadataSchema: () => MultiKitMetadataSchema,
  MetadataSchema: () => MetadataSchema,
  LegacyMetadataSchema: () => LegacyMetadataSchema,
  KitType: () => KitType,
  KitMetadataSchema: () => KitMetadataSchema,
  KitConfigSchema: () => KitConfigSchema,
  InstalledSettingsSchema: () => InstalledSettingsSchema,
  GitHubReleaseSchema: () => GitHubReleaseSchema,
  GitHubReleaseAssetSchema: () => GitHubReleaseAssetSchema,
  GitHubError: () => GitHubError,
  FoldersConfigSchema: () => FoldersConfigSchema,
  ExtractionError: () => ExtractionError,
  ExcludePatternSchema: () => ExcludePatternSchema,
  DownloadError: () => DownloadError,
  DEFAULT_FOLDERS: () => DEFAULT_FOLDERS,
  ConfigSchema: () => ConfigSchema,
  ClaudeKitError: () => ClaudeKitError,
  AuthenticationError: () => AuthenticationError,
  AVAILABLE_KITS: () => AVAILABLE_KITS
});
var init_types2 = __esm(() => {
  init_kit();
  init_commands();
  init_github();
  init_metadata();
  init_skills();
  init_errors2();
});

// src/domains/github/github-auth.ts
import { execSync } from "node:child_process";

class AuthManager {
  static token = null;
  static tokenMethod = null;
  static ghCliInstalled = null;
  static tokenFetchPromise = null;
  static async getToken() {
    if (AuthManager.token && AuthManager.tokenMethod) {
      return { token: AuthManager.token, method: AuthManager.tokenMethod };
    }
    if (AuthManager.tokenFetchPromise) {
      return AuthManager.tokenFetchPromise;
    }
    AuthManager.tokenFetchPromise = AuthManager.fetchToken();
    try {
      return await AuthManager.tokenFetchPromise;
    } finally {
      AuthManager.tokenFetchPromise = null;
    }
  }
  static async fetchToken() {
    const envToken = AuthManager.getFromEnv();
    if (envToken) {
      AuthManager.token = envToken;
      AuthManager.tokenMethod = "env";
      logger.debug("Using environment variable authentication");
      return { token: envToken, method: "env" };
    }
    if (!AuthManager.isGhCliInstalled()) {
      throw new AuthenticationError(`No GitHub authentication found.

` + `ClaudeKit supports multiple authentication methods:

` + `Option 1: Set environment variable (recommended for CI/CD)
` + `  export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
` + `  Create token at: github.com/settings/tokens
` + `    Use Classic PAT with 'repo' scope (fine-grained PATs don't work for collaborator repos)

` + `Option 2: Use git clone with SSH (recommended for security)
` + `  ck new --use-git
` + `  Requires SSH key added to GitHub

` + `Option 3: Install GitHub CLI
` + `  macOS:   brew install gh
` + `  Windows: winget install GitHub.cli
` + `  Linux:   sudo apt install gh  (or see: gh.io/install)
` + "  Then run: gh auth login");
    }
    const token = AuthManager.getFromGhCli();
    if (token) {
      AuthManager.token = token;
      AuthManager.tokenMethod = "gh-cli";
      logger.debug("Using GitHub CLI authentication");
      return { token, method: "gh-cli" };
    }
    const diagnostic = AuthManager.runDiagnostic();
    throw new AuthenticationError(`Failed to retrieve GitHub token.

Diagnostic info:
${diagnostic}

Possible causes:
   GitHub CLI session expired or corrupted
   Multi-account configuration issue
   OAuth token needs refresh

Solution: Re-authenticate with GitHub CLI
  gh auth login -h github.com

Follow these steps:
  1. Select 'GitHub.com'
  2. Select 'HTTPS' (or SSH if preferred)
  3. Authenticate Git?  Yes
  4. Select 'Login with a web browser' (recommended)
  5. Copy the one-time code shown
  6. Press Enter to open browser and paste the code
  7. Authorize GitHub CLI

Note: Do NOT use 'Paste an authentication token' - use web browser login.`);
  }
  static runDiagnostic() {
    const info = [];
    try {
      const version = execSync("gh --version", {
        encoding: "utf-8",
        stdio: ["pipe", "pipe", "pipe"],
        timeout: 3000
      }).split(`
`)[0]?.trim();
      info.push(`  gh version: ${version || "unknown"}`);
    } catch {
      info.push("  gh version: failed to retrieve");
    }
    try {
      const status = execSync("gh auth status -h github.com", {
        encoding: "utf-8",
        stdio: ["pipe", "pipe", "pipe"],
        timeout: 5000
      }).trim();
      const activeMatch = status.match(/Active account: (true|false)/);
      const tokenMatch = status.match(/Token: (\S+)/);
      const scopesMatch = status.match(/Token scopes: '([^']+)'/);
      if (activeMatch)
        info.push(`  Active account: ${activeMatch[1]}`);
      if (tokenMatch)
        info.push(`  Token present: ${tokenMatch[1] !== "none" ? "yes" : "no"}`);
      if (scopesMatch)
        info.push(`  Token scopes: ${scopesMatch[1]}`);
    } catch (error) {
      const stderr = error?.stderr?.toString()?.trim() || error?.message || "unknown error";
      info.push(`  gh auth status: ${stderr}`);
    }
    return info.join(`
`);
  }
  static isGhCliInstalled() {
    if (AuthManager.ghCliInstalled !== null) {
      return AuthManager.ghCliInstalled;
    }
    try {
      execSync("gh --version", {
        stdio: "ignore",
        timeout: 5000
      });
      AuthManager.ghCliInstalled = true;
      return true;
    } catch {
      AuthManager.ghCliInstalled = false;
      return false;
    }
  }
  static getFromGhCli() {
    try {
      const token = execSync("gh auth token -h github.com", {
        encoding: "utf-8",
        stdio: ["pipe", "pipe", "pipe"],
        timeout: 5000
      }).trim();
      if (token && token.length > 0) {
        return token;
      }
      logger.debug("gh auth token returned empty result");
      return null;
    } catch (error) {
      if (error?.stderr) {
        logger.debug(`gh auth token stderr: ${error.stderr.toString().trim()}`);
      }
      try {
        const token = execSync("gh auth token", {
          encoding: "utf-8",
          stdio: ["pipe", "pipe", "pipe"],
          timeout: 5000
        }).trim();
        if (token && token.length > 0) {
          return token;
        }
      } catch (fallbackError) {
        if (fallbackError?.stderr) {
          logger.debug(`gh auth token fallback stderr: ${fallbackError.stderr.toString().trim()}`);
        }
      }
      return null;
    }
  }
  static getFromEnv() {
    const token = process.env.GITHUB_TOKEN || process.env.GH_TOKEN;
    if (token && token.trim().length > 0) {
      logger.debug("Found token in environment variable");
      return token.trim();
    }
    return null;
  }
  static hasEnvToken() {
    return !!(process.env.GITHUB_TOKEN || process.env.GH_TOKEN);
  }
  static async clearToken() {
    AuthManager.token = null;
    AuthManager.tokenMethod = null;
    AuthManager.ghCliInstalled = null;
    AuthManager.tokenFetchPromise = null;
    logger.debug("Cleared cached token and gh CLI status");
  }
}
var init_github_auth = __esm(() => {
  init_logger();
  init_types2();
});

// src/domains/error/error-classifier.ts
function calculateTimeUntilReset(resetTimestamp) {
  if (!resetTimestamp)
    return null;
  const parsed = Number.parseInt(resetTimestamp, 10);
  if (Number.isNaN(parsed))
    return null;
  const resetDate = new Date(parsed * 1000);
  const diffMs = resetDate.getTime() - Date.now();
  if (diffMs <= 0)
    return null;
  return Math.ceil(diffMs / MS_PER_MINUTE);
}
function classifyGitHubError(error, operation) {
  const status = error?.status;
  const message = error?.message ?? "";
  const messageLower = message.toLowerCase();
  if (status === 403 && (messageLower.includes("rate limit") || messageLower.includes("api rate"))) {
    const resetTime = error?.response?.headers?.["x-ratelimit-reset"];
    const timeUntilReset = calculateTimeUntilReset(resetTime);
    return {
      category: "RATE_LIMIT",
      message: "GitHub API rate limit exceeded",
      details: timeUntilReset !== null ? `Rate limit resets in ${timeUntilReset} minute${timeUntilReset === 1 ? "" : "s"}` : "Rate limit will reset soon",
      suggestion: "Wait for rate limit to reset or authenticate with a GitHub token for higher limits",
      httpStatus: 403
    };
  }
  if (status === 401) {
    return {
      category: "AUTH_MISSING",
      message: "Not authenticated with GitHub",
      details: "GitHub CLI session may have expired or token is invalid",
      suggestion: "Re-authenticate with GitHub CLI",
      httpStatus: 401
    };
  }
  if (status === 403) {
    return {
      category: "AUTH_SCOPE",
      message: "GitHub token missing required permissions",
      details: "Your token may be missing the 'repo' scope or other required permissions",
      suggestion: "Re-authenticate with full permissions",
      httpStatus: 403
    };
  }
  if (status === 404) {
    return {
      category: "REPO_NOT_FOUND",
      message: "Repository not found or access denied",
      details: "You may not have been invited to the repository yet",
      suggestion: "Check email for GitHub invitation and accept it",
      httpStatus: 404
    };
  }
  if (messageLower.includes("econnrefused") || messageLower.includes("etimedout") || messageLower.includes("enotfound") || messageLower.includes("enetunreach") || messageLower.includes("econnreset") || messageLower.includes("network") || messageLower.includes("socket hang up") || messageLower.includes("getaddrinfo")) {
    return {
      category: "NETWORK",
      message: "Network connection error",
      details: error?.message || "Unable to connect to GitHub API",
      suggestion: "Check your internet connection and try again"
    };
  }
  if (messageLower.includes("permission denied (publickey)") || messageLower.includes("host key verification failed") || messageLower.includes("no matching host key") || messageLower.includes("could not read from remote repository") || messageLower.includes("ssh") && messageLower.includes("denied")) {
    return {
      category: "SSH_KEY",
      message: "SSH authentication failed",
      details: "SSH keys may not be configured or not added to GitHub",
      suggestion: "Add your SSH key to GitHub or use HTTPS instead"
    };
  }
  return {
    category: "UNKNOWN",
    message: operation ? `Failed to ${operation}` : "An unexpected error occurred",
    details: error?.message || "Unknown error",
    suggestion: "Check the error details and try again with --verbose flag",
    httpStatus: status
  };
}
var RATE_LIMIT_WARNING_THRESHOLD = 100, MS_PER_MINUTE = 60000;

// src/domains/github/client/auth-api.ts
import { Octokit } from "@octokit/rest";
async function getAuthenticatedClient() {
  if (cachedOctokit) {
    return cachedOctokit;
  }
  const { token } = await AuthManager.getToken();
  cachedOctokit = new Octokit({
    auth: token,
    userAgent: "claudekit-cli",
    request: {
      timeout: 30000
    }
  });
  return cachedOctokit;
}
async function invalidateAuth() {
  await AuthManager.clearToken();
  cachedOctokit = null;
  logger.debug("Invalidated cached authentication due to 401 error");
}
var cachedOctokit = null;
var init_auth_api = __esm(() => {
  init_logger();
  init_github_auth();
});

// src/domains/error/action-suggester.ts
function suggestActions(category) {
  const actions = {
    RATE_LIMIT: [
      {
        title: "Wait for rate limit reset",
        commands: [],
        notes: ["Rate limits reset hourly", "Check GitHub rate limit status"]
      },
      {
        title: "Authenticate for higher limits",
        commands: ["gh auth login", "(Select 'Login with a web browser' when prompted)"],
        notes: [
          "Authenticated requests have higher rate limits (5,000/hour vs 60/hour)",
          "Use a GitHub token for CI/CD environments"
        ]
      }
    ],
    AUTH_MISSING: [
      {
        title: "Re-authenticate with GitHub CLI",
        commands: ["gh auth login", "(Select 'Login with a web browser' when prompted)"],
        notes: ["Use web browser authentication instead of personal access token"]
      }
    ],
    AUTH_SCOPE: [
      {
        title: "Re-authenticate with full permissions",
        commands: ["gh auth login", "(Select 'Login with a web browser' when prompted)"],
        notes: [
          "Make sure to grant 'repo' scope when authenticating",
          "Web browser login automatically grants required scopes"
        ]
      }
    ],
    REPO_NOT_FOUND: [
      {
        title: "Accept GitHub repository invitation",
        commands: [],
        notes: [
          "Check your email for a GitHub invitation",
          "Visit https://github.com/notifications to see pending invitations",
          "After accepting, wait 2-5 minutes for permissions to sync"
        ]
      },
      {
        title: "Verify repository access",
        commands: ["gh repo view OWNER/REPO"],
        notes: ["Replace OWNER/REPO with the actual repository name"]
      }
    ],
    REPO_ACCESS: [
      {
        title: "Accept repository invitation",
        commands: [],
        notes: ["Check email for GitHub invitation and accept it"]
      }
    ],
    NETWORK: [
      {
        title: "Check internet connection",
        commands: ["ping github.com", "curl -I https://api.github.com"],
        notes: ["Verify you can reach GitHub servers", "Check firewall/proxy settings"]
      }
    ],
    SSH_KEY: [
      {
        title: "Add SSH key to GitHub",
        commands: [
          "ssh-keygen -t ed25519 -C 'your_email@example.com'",
          "cat ~/.ssh/id_ed25519.pub",
          "# Copy the output and add to GitHub: https://github.com/settings/keys"
        ],
        notes: ["Alternative: Use HTTPS instead of SSH for git operations"]
      }
    ],
    UNKNOWN: [
      {
        title: "Get more details",
        commands: ["ck <command> --verbose"],
        notes: ["Run the command with --verbose flag to see detailed error information"]
      }
    ]
  };
  return actions[category] || actions.UNKNOWN;
}
function formatActions(actions) {
  const lines = [];
  for (const action of actions) {
    lines.push(`
${action.title}:`);
    if (action.commands.length > 0) {
      for (const cmd of action.commands) {
        lines.push(`  ${cmd}`);
      }
    }
    if (action.notes && action.notes.length > 0) {
      lines.push("");
      for (const note of action.notes) {
        lines.push(`  ${note}`);
      }
    }
  }
  return lines.join(`
`);
}

// src/domains/error/index.ts
var init_error = () => {};

// src/domains/github/client/error-handler.ts
async function handleHttpError(error, context) {
  const { kit, operation, verboseFlag = "ck new --verbose" } = context;
  if (error?.status === 401) {
    await invalidateAuth();
  }
  const classified = classifyGitHubError(error, operation);
  const actions = suggestActions(classified.category);
  const formattedActions = formatActions(actions);
  const messageParts = [];
  if (classified.category === "REPO_NOT_FOUND" && kit?.name) {
    messageParts.push(`Cannot access ${kit.name} repository.`);
  } else {
    messageParts.push(classified.message);
  }
  if (classified.details) {
    messageParts.push(`
${classified.details}`);
  }
  if (formattedActions) {
    messageParts.push(`
Solutions:${formattedActions}`);
  }
  messageParts.push(`
Need help? Run with: ${verboseFlag}`);
  throw new GitHubError(messageParts.join(`
`), classified.httpStatus);
}
var init_error_handler = __esm(() => {
  init_error();
  init_types2();
  init_auth_api();
});

// src/domains/versioning/release-cache.ts
import { existsSync as existsSync12 } from "node:fs";
import { mkdir as mkdir2, readFile as readFile6, unlink as unlink2, writeFile as writeFile4 } from "node:fs/promises";
import { join as join16 } from "node:path";
var ReleaseCacheEntrySchema, ReleaseCache;
var init_release_cache = __esm(() => {
  init_logger();
  init_path_resolver();
  init_zod();
  ReleaseCacheEntrySchema = exports_external.object({
    timestamp: exports_external.number(),
    releases: exports_external.array(exports_external.any())
  });
  ReleaseCache = class ReleaseCache {
    static CACHE_DIR = "releases";
    static CACHE_TTL_SECONDS = Number(process.env.CK_CACHE_TTL) || 3600;
    cacheDir;
    constructor() {
      this.cacheDir = join16(PathResolver.getCacheDir(false), ReleaseCache.CACHE_DIR);
    }
    async get(key) {
      const cacheFile = this.getCachePath(key);
      try {
        if (!existsSync12(cacheFile)) {
          logger.debug(`Release cache not found for key: ${key}`);
          return null;
        }
        const content = await readFile6(cacheFile, "utf-8");
        const parsed = JSON.parse(content);
        const cacheEntry = ReleaseCacheEntrySchema.parse(parsed);
        if (this.isExpired(cacheEntry.timestamp)) {
          logger.debug(`Release cache expired for key: ${key}`);
          await this.clear(key);
          return null;
        }
        const { GitHubReleaseSchema: GitHubReleaseSchema2 } = await Promise.resolve().then(() => (init_types2(), exports_types));
        const releases = cacheEntry.releases.map((release) => GitHubReleaseSchema2.parse(release));
        logger.debug(`Release cache hit for key: ${key}, found ${releases.length} releases`);
        return releases;
      } catch (error) {
        logger.debug(`Failed to load release cache for key ${key}: ${error}`);
        await this.clear(key);
        return null;
      }
    }
    async set(key, releases) {
      const cacheFile = this.getCachePath(key);
      try {
        await mkdir2(this.cacheDir, { recursive: true, mode: 448 });
        const cacheEntry = {
          timestamp: Date.now(),
          releases
        };
        await writeFile4(cacheFile, JSON.stringify(cacheEntry, null, 2), "utf-8");
        logger.debug(`Release cache set for key: ${key}, cached ${releases.length} releases`);
      } catch (error) {
        logger.debug(`Failed to set release cache for key ${key}: ${error}`);
      }
    }
    async clear(key) {
      if (key) {
        const cacheFile = this.getCachePath(key);
        try {
          if (existsSync12(cacheFile)) {
            await unlink2(cacheFile);
            logger.debug(`Release cache cleared for key: ${key}`);
          }
        } catch (error) {
          logger.debug(`Failed to clear release cache for key ${key}: ${error}`);
        }
      } else {
        try {
          const { readdir: readdir4 } = await import("node:fs/promises");
          const files = await readdir4(this.cacheDir);
          for (const file of files) {
            if (file.endsWith(".json")) {
              await unlink2(join16(this.cacheDir, file));
            }
          }
          logger.debug("All release cache cleared");
        } catch (error) {
          logger.debug(`Failed to clear all release cache: ${error}`);
        }
      }
    }
    getCachePath(key) {
      const safeKey = key.replace(/[^a-zA-Z0-9_-]/g, "_");
      return join16(this.cacheDir, `${safeKey}.json`);
    }
    isExpired(timestamp) {
      const now = Date.now();
      const age = now - timestamp;
      const ageSeconds = Math.floor(age / 1000);
      const isExpired = ageSeconds >= ReleaseCache.CACHE_TTL_SECONDS;
      const ageMinutes = Math.floor(ageSeconds / 60);
      logger.debug(`Cache age check: ${ageMinutes} minutes old, expired=${isExpired}`);
      return isExpired;
    }
  };
});

// node_modules/compare-versions/lib/umd/index.js
var require_umd = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.compareVersions = {}));
  })(exports, function(exports2) {
    const semver = /^[v^~<>=]*?(\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+))?(?:-([\da-z\-]+(?:\.[\da-z\-]+)*))?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i;
    const validateAndParse = (version) => {
      if (typeof version !== "string") {
        throw new TypeError("Invalid argument expected string");
      }
      const match = version.match(semver);
      if (!match) {
        throw new Error(`Invalid argument not valid semver ('${version}' received)`);
      }
      match.shift();
      return match;
    };
    const isWildcard = (s) => s === "*" || s === "x" || s === "X";
    const tryParse = (v2) => {
      const n = parseInt(v2, 10);
      return isNaN(n) ? v2 : n;
    };
    const forceType = (a3, b3) => typeof a3 !== typeof b3 ? [String(a3), String(b3)] : [a3, b3];
    const compareStrings = (a3, b3) => {
      if (isWildcard(a3) || isWildcard(b3))
        return 0;
      const [ap, bp] = forceType(tryParse(a3), tryParse(b3));
      if (ap > bp)
        return 1;
      if (ap < bp)
        return -1;
      return 0;
    };
    const compareSegments = (a3, b3) => {
      for (let i = 0;i < Math.max(a3.length, b3.length); i++) {
        const r2 = compareStrings(a3[i] || "0", b3[i] || "0");
        if (r2 !== 0)
          return r2;
      }
      return 0;
    };
    const compareVersions3 = (v1, v2) => {
      const n1 = validateAndParse(v1);
      const n2 = validateAndParse(v2);
      const p1 = n1.pop();
      const p2 = n2.pop();
      const r2 = compareSegments(n1, n2);
      if (r2 !== 0)
        return r2;
      if (p1 && p2) {
        return compareSegments(p1.split("."), p2.split("."));
      } else if (p1 || p2) {
        return p1 ? -1 : 1;
      }
      return 0;
    };
    const compare = (v1, v2, operator) => {
      assertValidOperator(operator);
      const res = compareVersions3(v1, v2);
      return operatorResMap[operator].includes(res);
    };
    const operatorResMap = {
      ">": [1],
      ">=": [0, 1],
      "=": [0],
      "<=": [-1, 0],
      "<": [-1],
      "!=": [-1, 1]
    };
    const allowedOperators = Object.keys(operatorResMap);
    const assertValidOperator = (op) => {
      if (typeof op !== "string") {
        throw new TypeError(`Invalid operator type, expected string but got ${typeof op}`);
      }
      if (allowedOperators.indexOf(op) === -1) {
        throw new Error(`Invalid operator, expected one of ${allowedOperators.join("|")}`);
      }
    };
    const satisfies = (version, range) => {
      range = range.replace(/([><=]+)\s+/g, "$1");
      if (range.includes("||")) {
        return range.split("||").some((r5) => satisfies(version, r5));
      } else if (range.includes(" - ")) {
        const [a3, b3] = range.split(" - ", 2);
        return satisfies(version, `>=${a3} <=${b3}`);
      } else if (range.includes(" ")) {
        return range.trim().replace(/\s{2,}/g, " ").split(" ").every((r5) => satisfies(version, r5));
      }
      const m2 = range.match(/^([<>=~^]+)/);
      const op = m2 ? m2[1] : "=";
      if (op !== "^" && op !== "~")
        return compare(version, range, op);
      const [v1, v2, v3, , vp] = validateAndParse(version);
      const [r1, r2, r3, , rp] = validateAndParse(range);
      const v4 = [v1, v2, v3];
      const r4 = [r1, r2 !== null && r2 !== undefined ? r2 : "x", r3 !== null && r3 !== undefined ? r3 : "x"];
      if (rp) {
        if (!vp)
          return false;
        if (compareSegments(v4, r4) !== 0)
          return false;
        if (compareSegments(vp.split("."), rp.split(".")) === -1)
          return false;
      }
      const nonZero = r4.findIndex((v5) => v5 !== "0") + 1;
      const i = op === "~" ? 2 : nonZero > 1 ? nonZero : 1;
      if (compareSegments(v4.slice(0, i), r4.slice(0, i)) !== 0)
        return false;
      if (compareSegments(v4.slice(i), r4.slice(i)) === -1)
        return false;
      return true;
    };
    const validate = (version) => typeof version === "string" && /^[v\d]/.test(version) && semver.test(version);
    const validateStrict = (version) => typeof version === "string" && /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/.test(version);
    exports2.compare = compare;
    exports2.compareVersions = compareVersions3;
    exports2.satisfies = satisfies;
    exports2.validate = validate;
    exports2.validateStrict = validateStrict;
  });
});

// src/domains/versioning/version-formatter.ts
class VersionFormatter {
  static normalize(version) {
    if (!version)
      return "";
    return version.replace(/^v/i, "");
  }
  static display(version) {
    if (!version)
      return "";
    return version.startsWith("v") ? version : `v${version}`;
  }
  static compare(v1, v2) {
    const normV1 = VersionFormatter.normalize(v1);
    const normV2 = VersionFormatter.normalize(v2);
    return import_compare_versions.compareVersions(normV1, normV2);
  }
  static formatRelativeTime(dateString) {
    if (!dateString)
      return "Unknown";
    try {
      const date = new Date(dateString);
      const now = new Date;
      if (Number.isNaN(date.getTime()))
        return "Unknown";
      const diffMs = now.getTime() - date.getTime();
      const diffSeconds = Math.floor(diffMs / 1000);
      const diffMinutes = Math.floor(diffSeconds / 60);
      const diffHours = Math.floor(diffMinutes / 60);
      const diffDays = Math.floor(diffHours / 24);
      if (diffSeconds < 60) {
        return "just now";
      }
      if (diffMinutes < 60) {
        return `${diffMinutes} minute${diffMinutes === 1 ? "" : "s"} ago`;
      }
      if (diffHours < 24) {
        return `${diffHours} hour${diffHours === 1 ? "" : "s"} ago`;
      }
      if (diffDays < 7) {
        return `${diffDays} day${diffDays === 1 ? "" : "s"} ago`;
      }
      if (diffDays < 30) {
        const weeks = Math.floor(diffDays / 7);
        return `${weeks} week${weeks === 1 ? "" : "s"} ago`;
      }
      if (diffDays < 365) {
        const months = Math.floor(diffDays / 30);
        return `${months} month${months === 1 ? "" : "s"} ago`;
      }
      const years = Math.floor(diffDays / 365);
      return `${years} year${years === 1 ? "" : "s"} ago`;
    } catch (error) {
      logger.debug(`Failed to format relative time for ${dateString}: ${error}`);
      return "Unknown";
    }
  }
  static enrichRelease(release) {
    const normalizedVersion = VersionFormatter.normalize(release.tag_name);
    const displayVersion = VersionFormatter.display(normalizedVersion);
    return {
      ...release,
      displayVersion,
      normalizedVersion,
      relativeTime: VersionFormatter.formatRelativeTime(release.published_at),
      isLatestStable: false,
      isLatestBeta: false,
      assetCount: release.assets.length
    };
  }
  static enrichReleases(releases) {
    return releases.map((release) => VersionFormatter.enrichRelease(release));
  }
  static isValidVersion(version) {
    if (!version)
      return false;
    const normalized = VersionFormatter.normalize(version);
    const versionPattern = /^\d+\.\d+\.\d+(?:-[a-zA-Z0-9.-]+)?$/;
    return versionPattern.test(normalized);
  }
  static parseVersion(version) {
    const normalized = VersionFormatter.normalize(version);
    const match = normalized.match(/^(\d+)\.(\d+)\.(\d+)(?:-(.+))?$/);
    if (!match)
      return null;
    return {
      major: Number.parseInt(match[1], 10),
      minor: Number.parseInt(match[2], 10),
      patch: Number.parseInt(match[3], 10),
      prerelease: match[4]
    };
  }
  static isPrerelease(version) {
    const parsed = VersionFormatter.parseVersion(version);
    return parsed ? Boolean(parsed.prerelease) : false;
  }
  static sortVersions(versions) {
    return [...versions].sort((a3, b3) => {
      const normA = VersionFormatter.normalize(a3);
      const normB = VersionFormatter.normalize(b3);
      const majorA = Number.parseInt(normA.split(".")[0], 10);
      const majorB = Number.parseInt(normB.split(".")[0], 10);
      if (majorA === 0 && majorB === 0) {
        return import_compare_versions.compareVersions(normB, normA);
      }
      if (majorA === 0)
        return 1;
      if (majorB === 0)
        return -1;
      return import_compare_versions.compareVersions(normB, normA);
    });
  }
}
var import_compare_versions;
var init_version_formatter = __esm(() => {
  init_logger();
  import_compare_versions = __toESM(require_umd(), 1);
});

// src/domains/versioning/release-filter.ts
class ReleaseFilter {
  static filterByType(releases, options = {}) {
    return releases.filter((release) => {
      if (!options.includeDrafts && release.draft) {
        return false;
      }
      if (!options.includePrereleases && release.prerelease) {
        return false;
      }
      return true;
    });
  }
  static sortByDate(releases, order = "desc") {
    return [...releases].sort((a3, b3) => {
      if (!a3.published_at && !b3.published_at)
        return 0;
      if (!a3.published_at)
        return order === "desc" ? 1 : -1;
      if (!b3.published_at)
        return order === "desc" ? -1 : 1;
      const dateA = new Date(a3.published_at).getTime();
      const dateB = new Date(b3.published_at).getTime();
      return order === "desc" ? dateB - dateA : dateA - dateB;
    });
  }
  static sortByVersion(releases, order = "desc") {
    return [...releases].sort((a3, b3) => {
      const comparison = VersionFormatter.compare(a3.tag_name, b3.tag_name);
      return order === "desc" ? -comparison : comparison;
    });
  }
  static tagLatest(releases) {
    const enriched = releases.map((release) => ({ ...release }));
    const stableReleases = enriched.filter((release) => !release.prerelease && !release.draft).sort((a3, b3) => -VersionFormatter.compare(a3.tag_name, b3.tag_name));
    const latestStable = stableReleases.length > 0 ? stableReleases[0] : null;
    const betaReleases = enriched.filter((release) => release.prerelease && !release.draft).sort((a3, b3) => -VersionFormatter.compare(a3.tag_name, b3.tag_name));
    const latestBeta = betaReleases.length > 0 ? betaReleases[0] : null;
    for (const release of enriched) {
      if (latestStable && release.id === latestStable.id) {
        release.isLatestStable = true;
      }
      if (latestBeta && release.id === latestBeta.id) {
        release.isLatestBeta = true;
      }
    }
    return enriched;
  }
  static processReleases(releases, options = {}) {
    let filtered = ReleaseFilter.filterByType(releases, options);
    if (options.sortBy === "version") {
      filtered = ReleaseFilter.sortByVersion(filtered, options.order);
    } else {
      filtered = ReleaseFilter.sortByDate(filtered, options.order);
    }
    if (options.limit && options.limit > 0) {
      filtered = filtered.slice(0, options.limit);
    }
    let enriched = VersionFormatter.enrichReleases(filtered);
    enriched = ReleaseFilter.tagLatest(enriched);
    return enriched;
  }
  static filterByVersionPattern(releases, pattern) {
    return releases.filter((release) => {
      const version = VersionFormatter.normalize(release.tag_name);
      const parsed = VersionFormatter.parseVersion(version);
      if (!parsed)
        return false;
      if (pattern.includes("*")) {
        const patternParts = pattern.split(".");
        const versionParts = version.split(".");
        return patternParts.every((part, index) => {
          if (part === "*")
            return true;
          return part === versionParts[index];
        });
      }
      if (pattern.startsWith("^")) {
        const baseVersion = pattern.slice(1);
        const baseParsed = VersionFormatter.parseVersion(baseVersion);
        if (!baseParsed)
          return false;
        return parsed.major === baseParsed.major && VersionFormatter.compare(version, baseVersion) >= 0;
      }
      if (pattern.startsWith("~")) {
        const baseVersion = pattern.slice(1);
        const baseParsed = VersionFormatter.parseVersion(baseVersion);
        if (!baseParsed)
          return false;
        return parsed.major === baseParsed.major && parsed.minor === baseParsed.minor && VersionFormatter.compare(version, baseVersion) >= 0;
      }
      return VersionFormatter.normalize(pattern) === version;
    });
  }
  static getStableReleases(releases) {
    return ReleaseFilter.filterByType(releases, {
      includeDrafts: false,
      includePrereleases: false
    });
  }
  static getPrereleaseReleases(releases) {
    return ReleaseFilter.filterByType(releases, {
      includeDrafts: false,
      includePrereleases: true
    }).filter((release) => release.prerelease);
  }
  static getRecentReleases(releases, days = 30) {
    const cutoffDate = new Date;
    cutoffDate.setDate(cutoffDate.getDate() - days);
    return releases.filter((release) => {
      if (!release.published_at)
        return false;
      const releaseDate = new Date(release.published_at);
      return releaseDate >= cutoffDate;
    });
  }
  static getLatestStable(releases) {
    const stableReleases = releases.filter((r2) => !r2.prerelease && !r2.draft).sort((a3, b3) => -VersionFormatter.compare(a3.tag_name, b3.tag_name));
    return stableReleases.length > 0 ? stableReleases[0] : null;
  }
  static getLatestPrerelease(releases) {
    const prereleases = releases.filter((r2) => r2.prerelease && !r2.draft).sort((a3, b3) => -VersionFormatter.compare(a3.tag_name, b3.tag_name));
    return prereleases.length > 0 ? prereleases[0] : null;
  }
}
var init_release_filter = __esm(() => {
  init_version_formatter();
});

// src/domains/github/client/releases-api.ts
async function withAuthRetry(fn) {
  try {
    return await fn();
  } catch (e2) {
    const status = e2.status || e2.response?.status;
    if (status === 401) {
      await AuthManager.clearToken();
      logger.debug("Token expired, retrying with fresh auth...");
      return await fn();
    }
    throw e2;
  }
}

class ReleasesApi {
  getClient;
  releaseCache = new ReleaseCache;
  constructor(getClient) {
    this.getClient = getClient;
  }
  applyPrereleasesFallback(processed, releases, limit, includePrereleases) {
    if (processed.length === 0 && !includePrereleases) {
      logger.debug("No stable releases found, falling back to prereleases");
      const withPrereleases = ReleaseFilter.processReleases(releases, {
        includeDrafts: false,
        includePrereleases: true,
        limit,
        sortBy: "date",
        order: "desc"
      });
      if (withPrereleases.length > 0) {
        logger.warning("No stable releases available. Showing prereleases instead.");
      }
      return withPrereleases;
    }
    return processed;
  }
  async getLatestRelease(kit, includePrereleases = false) {
    return withAuthRetry(async () => {
      try {
        logger.debug(`Fetching releases for ${kit.owner}/${kit.repo}`);
        const releases = await this.listReleases(kit, 100);
        if (includePrereleases) {
          const latestPrerelease = ReleaseFilter.getLatestPrerelease(releases);
          if (latestPrerelease) {
            logger.debug(`Found latest prerelease (by semver): ${latestPrerelease.tag_name}`);
            return latestPrerelease;
          }
          logger.warning("No prerelease versions found, falling back to latest stable release");
        }
        const latestStable = ReleaseFilter.getLatestStable(releases);
        if (latestStable) {
          logger.debug(`Found latest stable (by semver): ${latestStable.tag_name}`);
          return latestStable;
        }
        const anyPrerelease = ReleaseFilter.getLatestPrerelease(releases);
        if (anyPrerelease) {
          logger.warning(`No stable release available. Using latest prerelease: ${anyPrerelease.tag_name}`);
          return anyPrerelease;
        }
        throw new GitHubError(`No releases found for ${kit.name}`, 404);
      } catch (error) {
        if (error instanceof GitHubError)
          throw error;
        return handleHttpError(error, {
          kit,
          operation: "fetch release",
          verboseFlag: "ck new --verbose"
        });
      }
    });
  }
  async getReleaseByTag(kit, tag) {
    return withAuthRetry(async () => {
      try {
        const client = await this.getClient();
        logger.debug(`Fetching release ${tag} for ${kit.owner}/${kit.repo}`);
        const { data } = await client.repos.getReleaseByTag({
          owner: kit.owner,
          repo: kit.repo,
          tag
        });
        return GitHubReleaseSchema.parse(data);
      } catch (error) {
        if (error?.status === 404) {
          throw new GitHubError(`Release '${tag}' not found for ${kit.name}.

Possible causes:
   Release version doesn't exist (check: ck versions --kit ${kit.name.toLowerCase()})
   You don't have repository access

Solutions:
  1. List available versions: ck versions --kit ${kit.name.toLowerCase()}
  2. Check email for GitHub invitation and accept it
  3. Re-authenticate: gh auth login (select 'Login with a web browser')

Need help? Run with: ck new --verbose`, 404);
        }
        return handleHttpError(error, {
          kit,
          operation: "fetch release",
          verboseFlag: "ck new --verbose"
        });
      }
    });
  }
  async listReleases(kit, limit = 100, stopWhenStableFound = false) {
    return withAuthRetry(async () => {
      try {
        const client = await this.getClient();
        const allReleases = [];
        let page = 1;
        const perPage = Math.min(limit, 100);
        logger.debug(`Listing releases for ${kit.owner}/${kit.repo}`);
        while (allReleases.length < limit) {
          const { data } = await client.repos.listReleases({
            owner: kit.owner,
            repo: kit.repo,
            per_page: perPage,
            page
          });
          if (data.length === 0)
            break;
          const parsed = data.map((release) => GitHubReleaseSchema.parse(release));
          allReleases.push(...parsed);
          if (stopWhenStableFound) {
            const hasStable = allReleases.some((r2) => !r2.prerelease && !r2.draft);
            if (hasStable) {
              logger.debug(`Found stable release on page ${page}, stopping pagination`);
              break;
            }
          }
          if (data.length < perPage)
            break;
          page++;
          if (page > 5) {
            logger.debug("Reached pagination limit (5 pages)");
            break;
          }
        }
        return allReleases.slice(0, limit);
      } catch (error) {
        return handleHttpError(error, {
          kit,
          operation: "list releases",
          verboseFlag: "ck versions --verbose"
        });
      }
    });
  }
  async listReleasesWithCache(kit, options = {}) {
    const { limit = 10, includePrereleases = false, forceRefresh = false } = options;
    const fetchLimit = Math.min(limit * 3, 100);
    const cacheKey = `${kit.repo}-${fetchLimit}-${includePrereleases}`;
    try {
      if (forceRefresh) {
        logger.debug("Bypassing cache (--refresh flag) - fetching from GitHub API");
      }
      if (!forceRefresh) {
        const cachedReleases = await this.releaseCache.get(cacheKey);
        if (cachedReleases) {
          logger.debug(`Using cached releases for ${kit.name}`);
          const processed2 = ReleaseFilter.processReleases(cachedReleases, {
            includeDrafts: false,
            includePrereleases,
            limit,
            sortBy: "date",
            order: "desc"
          });
          return this.applyPrereleasesFallback(processed2, cachedReleases, limit, includePrereleases);
        }
      }
      logger.debug(`Fetching releases from API for ${kit.name}`);
      const stopWhenStableFound = !includePrereleases;
      const releases = await this.listReleases(kit, fetchLimit, stopWhenStableFound);
      await this.releaseCache.set(cacheKey, releases);
      const processed = ReleaseFilter.processReleases(releases, {
        includeDrafts: false,
        includePrereleases,
        limit,
        sortBy: "date",
        order: "desc"
      });
      return this.applyPrereleasesFallback(processed, releases, limit, includePrereleases);
    } catch (error) {
      logger.error(`Failed to list releases with cache for ${kit.name}: ${error.message}`);
      throw error;
    }
  }
  async getVersionsByPattern(kit, pattern, options = {}) {
    const { limit = 10, includePrereleases = false } = options;
    try {
      const allReleases = await this.listReleasesWithCache(kit, {
        limit: limit * 3,
        includePrereleases,
        forceRefresh: false
      });
      const patternReleases = ReleaseFilter.filterByVersionPattern(allReleases, pattern);
      const filteredReleases = ReleaseFilter.processReleases(patternReleases, {
        includeDrafts: false,
        includePrereleases,
        limit,
        sortBy: "version",
        order: "desc"
      });
      return filteredReleases;
    } catch (error) {
      logger.error(`Failed to get versions by pattern ${pattern} for ${kit.name}: ${error.message}`);
      throw error;
    }
  }
  async clearReleaseCache(kit) {
    try {
      if (kit) {
        await this.releaseCache.clear();
        logger.debug(`Cleared release cache for ${kit.name}`);
      } else {
        await this.releaseCache.clear();
        logger.debug("Cleared all release caches");
      }
    } catch (error) {
      logger.error(`Failed to clear release cache: ${error.message}`);
      throw error;
    }
  }
}
var init_releases_api = __esm(() => {
  init_release_cache();
  init_release_filter();
  init_logger();
  init_types2();
  init_github_auth();
  init_error_handler();
});

// src/domains/github/client/repo-api.ts
class RepoApi {
  getClient;
  constructor(getClient) {
    this.getClient = getClient;
  }
  async checkAccess(kit) {
    try {
      const client = await this.getClient();
      await client.repos.get({
        owner: kit.owner,
        repo: kit.repo
      });
      return true;
    } catch (error) {
      if (error?.status === 404) {
        throw new GitHubError(`Cannot access ${kit.name} repository.

Possible causes:
   You haven't accepted the GitHub repository invitation
   You're not added as a collaborator yet
   You're logged into a different GitHub account

Solutions:
  1. Check email for GitHub invitation and accept it
  2. Re-authenticate: gh auth login (select 'Login with a web browser')
  3. Verify you're using the correct GitHub account
  4. Wait 2-5 minutes after accepting invitation for permissions to sync

Need help? Run with: ck new --verbose`, 404);
      }
      return handleHttpError(error, {
        kit,
        operation: "check repository access",
        verboseFlag: "ck new --verbose"
      });
    }
  }
}
var init_repo_api = __esm(() => {
  init_types2();
  init_error_handler();
});

// src/domains/github/client/asset-utils.ts
function getDownloadableAsset(release) {
  logger.debug(`Available assets for ${release.tag_name}:`);
  if (release.assets.length === 0) {
    logger.debug("  No custom assets found");
  } else {
    release.assets.forEach((asset, index) => {
      logger.debug(`  ${index + 1}. ${asset.name} (${(asset.size / 1024 / 1024).toFixed(2)} MB)`);
    });
  }
  const packageAsset = release.assets.find((a3) => {
    const nameLower = a3.name.toLowerCase();
    return nameLower.includes("claudekit") && nameLower.includes("package") && nameLower.endsWith(".zip");
  });
  if (packageAsset) {
    logger.debug(`Selected ClaudeKit package asset: ${packageAsset.name}`);
    return {
      type: "asset",
      url: packageAsset.url,
      name: packageAsset.name,
      size: packageAsset.size
    };
  }
  logger.debug("No ClaudeKit package asset found, checking for other custom assets...");
  const customAsset = release.assets.find((a3) => (a3.name.endsWith(".tar.gz") || a3.name.endsWith(".tgz") || a3.name.endsWith(".zip")) && !a3.name.toLowerCase().startsWith("source") && !a3.name.toLowerCase().includes("source code"));
  if (customAsset) {
    logger.debug(`Selected custom asset: ${customAsset.name}`);
    return {
      type: "asset",
      url: customAsset.url,
      name: customAsset.name,
      size: customAsset.size
    };
  }
  logger.debug("No custom assets found, falling back to GitHub automatic tarball");
  return {
    type: "tarball",
    url: release.tarball_url,
    name: `${release.tag_name}.tar.gz`,
    size: undefined
  };
}
var init_asset_utils = __esm(() => {
  init_logger();
});

// src/domains/github/client/index.ts
var init_client = __esm(() => {
  init_auth_api();
  init_error_handler();
  init_releases_api();
  init_repo_api();
  init_asset_utils();
});

// src/domains/github/github-client.ts
class GitHubClient {
  releasesApi;
  repoApi;
  constructor() {
    this.releasesApi = new ReleasesApi(getAuthenticatedClient);
    this.repoApi = new RepoApi(getAuthenticatedClient);
  }
  async getLatestRelease(kit, includePrereleases = false) {
    return this.releasesApi.getLatestRelease(kit, includePrereleases);
  }
  async getReleaseByTag(kit, tag) {
    return this.releasesApi.getReleaseByTag(kit, tag);
  }
  async listReleases(kit, limit = 10) {
    return this.releasesApi.listReleases(kit, limit);
  }
  async checkAccess(kit) {
    return this.repoApi.checkAccess(kit);
  }
  async listReleasesWithCache(kit, options = {}) {
    return this.releasesApi.listReleasesWithCache(kit, options);
  }
  async getVersionsByPattern(kit, pattern, options = {}) {
    return this.releasesApi.getVersionsByPattern(kit, pattern, options);
  }
  async clearReleaseCache(kit) {
    return this.releasesApi.clearReleaseCache(kit);
  }
  static getDownloadableAsset(release) {
    return getDownloadableAsset(release);
  }
}
var init_github_client = __esm(() => {
  init_client();
});

// src/domains/health-checks/checkers/github-api-checker.ts
var exports_github_api_checker = {};
__export(exports_github_api_checker, {
  checkTokenScopes: () => checkTokenScopes,
  checkRepositoryAccess: () => checkRepositoryAccess,
  checkRateLimit: () => checkRateLimit
});
import { spawnSync } from "node:child_process";
async function checkRateLimit() {
  if (false) {}
  try {
    const { token } = await AuthManager.getToken();
    const response = await fetch("https://api.github.com/rate_limit", {
      headers: {
        Authorization: `Bearer ${token}`,
        Accept: "application/vnd.github.v3+json"
      }
    });
    if (!response.ok) {
      return {
        id: "github-rate-limit",
        name: "GitHub Rate Limit",
        group: "auth",
        status: "warn",
        message: "Failed to check rate limit",
        details: `HTTP ${response.status}`,
        autoFixable: false
      };
    }
    const data = await response.json();
    const core = data.resources?.core;
    if (!core) {
      return {
        id: "github-rate-limit",
        name: "GitHub Rate Limit",
        group: "auth",
        status: "warn",
        message: "Rate limit data not available",
        autoFixable: false
      };
    }
    const remaining = core.remaining ?? 0;
    const total = core.limit ?? 0;
    const resetTime = new Date(core.reset * 1000);
    const diffMs = resetTime.getTime() - Date.now();
    const resetInMinutes = diffMs > 0 ? Math.ceil(diffMs / MS_PER_MINUTE2) : 0;
    const percentUsed = total > 0 ? Math.round((total - remaining) / total * 100) : 0;
    if (remaining === 0) {
      return {
        id: "github-rate-limit",
        name: "GitHub Rate Limit",
        group: "auth",
        status: "fail",
        message: "Rate limit exhausted",
        details: `Resets in ${resetInMinutes} minutes`,
        suggestion: "Wait for rate limit reset or use a different GitHub token",
        autoFixable: false
      };
    }
    if (remaining < RATE_LIMIT_WARNING_THRESHOLD) {
      return {
        id: "github-rate-limit",
        name: "GitHub Rate Limit",
        group: "auth",
        status: "warn",
        message: `${remaining}/${total} requests remaining (${percentUsed}% used)`,
        details: `Resets in ${resetInMinutes} minutes`,
        autoFixable: false
      };
    }
    return {
      id: "github-rate-limit",
      name: "GitHub Rate Limit",
      group: "auth",
      status: "pass",
      message: `${remaining}/${total} requests remaining`,
      details: `Resets in ${resetInMinutes} minutes`,
      autoFixable: false
    };
  } catch (error) {
    return {
      id: "github-rate-limit",
      name: "GitHub Rate Limit",
      group: "auth",
      status: "warn",
      message: "Unable to check rate limit",
      details: error instanceof Error ? error.message : "Unknown error",
      autoFixable: false
    };
  }
}
async function checkTokenScopes() {
  if (false) {}
  try {
    const result = spawnSync("gh", ["auth", "status", "-h", "github.com"], {
      encoding: "utf8",
      timeout: COMMAND_TIMEOUT_MS
    });
    const output2 = result.stdout || result.stderr || "";
    if (result.error) {
      throw result.error;
    }
    const scopeMatch = output2.match(/Token scopes:\s*([^\n]+)/i);
    const scopesStr = scopeMatch?.[1]?.trim() || "";
    const scopes = scopesStr.split(",").map((s) => s.trim()).filter((s) => s.length > 0);
    const hasRepoScope = scopes.includes("repo");
    if (!hasRepoScope) {
      return {
        id: "github-token-scopes",
        name: "GitHub Token Scopes",
        group: "auth",
        status: "warn",
        message: "Missing 'repo' scope",
        details: `Current scopes: ${scopes.join(", ") || "none"}`,
        suggestion: "Re-authenticate: gh auth login -h github.com (select 'Login with a web browser')",
        autoFixable: false
      };
    }
    const details = scopes.length > 0 ? `Scopes: ${scopes.join(", ")}` : "No scopes found";
    return {
      id: "github-token-scopes",
      name: "GitHub Token Scopes",
      group: "auth",
      status: "pass",
      message: "Token has required scopes",
      details,
      autoFixable: false
    };
  } catch (error) {
    return {
      id: "github-token-scopes",
      name: "GitHub Token Scopes",
      group: "auth",
      status: "warn",
      message: "Unable to check token scopes",
      details: error instanceof Error ? error.message : "Unknown error",
      suggestion: "Run: gh auth status -h github.com",
      autoFixable: false
    };
  }
}
async function checkRepositoryAccess(kitType = "engineer") {
  if (process.env.CI === "true") {
    return {
      id: `github-repo-access-${kitType}`,
      name: `Repository Access (${kitType})`,
      group: "auth",
      status: "info",
      message: "Skipped in test/CI environment",
      autoFixable: false
    };
  }
  const kitConfig = AVAILABLE_KITS[kitType];
  if (!kitConfig) {
    return {
      id: `github-repo-access-${kitType}`,
      name: `Repository Access (${kitType})`,
      group: "auth",
      status: "fail",
      message: `Unknown kit type: ${kitType}`,
      suggestion: `Available kits: ${Object.keys(AVAILABLE_KITS).join(", ")}`,
      autoFixable: false
    };
  }
  try {
    const client = new GitHubClient;
    logger.verbose(`Testing access to ${kitConfig.owner}/${kitConfig.repo}`);
    const hasAccess = await client.checkAccess(kitConfig);
    if (hasAccess) {
      return {
        id: `github-repo-access-${kitType}`,
        name: `Repository Access (${kitType})`,
        group: "auth",
        status: "pass",
        message: `Access to ${kitConfig.owner}/${kitConfig.repo}`,
        autoFixable: false
      };
    }
    return {
      id: `github-repo-access-${kitType}`,
      name: `Repository Access (${kitType})`,
      group: "auth",
      status: "fail",
      message: `No access to ${kitConfig.owner}/${kitConfig.repo}`,
      suggestion: "Check email for GitHub invitation and accept it",
      autoFixable: false
    };
  } catch (error) {
    return {
      id: `github-repo-access-${kitType}`,
      name: `Repository Access (${kitType})`,
      group: "auth",
      status: "fail",
      message: "Failed to test repository access",
      details: error instanceof Error ? error.message : "Unknown error",
      suggestion: "Re-authenticate: gh auth login -h github.com",
      autoFixable: false
    };
  }
}
var MS_PER_MINUTE2 = 60000, COMMAND_TIMEOUT_MS = 5000;
var init_github_api_checker = __esm(() => {
  init_github_auth();
  init_github_client();
  init_logger();
  init_types2();
});

// src/services/package-installer/process-executor.ts
import { exec as exec6, execFile, spawn } from "node:child_process";
import { promisify as promisify6 } from "node:util";
function executeInteractiveScript(command, args, options) {
  return new Promise((resolve2, reject) => {
    const child = spawn(command, args, {
      stdio: ["ignore", "inherit", "inherit"],
      cwd: options?.cwd,
      env: options?.env || process.env
    });
    let timeoutId;
    if (options?.timeout) {
      timeoutId = setTimeout(() => {
        child.kill("SIGTERM");
        reject(new Error(`Command timed out after ${options.timeout}ms`));
      }, options.timeout);
    }
    child.on("exit", (code, signal) => {
      if (timeoutId)
        clearTimeout(timeoutId);
      if (signal) {
        reject(new Error(`Command terminated by signal ${signal}`));
      } else if (code !== 0) {
        reject(new Error(`Command exited with code ${code}`));
      } else {
        resolve2();
      }
    });
    child.on("error", (error) => {
      if (timeoutId)
        clearTimeout(timeoutId);
      reject(error);
    });
  });
}
function getNpmCommand() {
  const platform5 = process.platform;
  return platform5 === "win32" ? "npm.cmd" : "npm";
}
var execAsync6, execFileAsync;
var init_process_executor = __esm(() => {
  execAsync6 = promisify6(exec6);
  execFileAsync = promisify6(execFile);
});

// src/services/package-installer/validators.ts
import { resolve as resolve2 } from "node:path";
function validatePackageName(packageName) {
  if (!packageName || typeof packageName !== "string") {
    throw new Error("Package name must be a non-empty string");
  }
  if (packageName.length > 214) {
    throw new Error("Package name too long");
  }
  if (!NPM_PACKAGE_REGEX.test(packageName)) {
    throw new Error("Invalid package name");
  }
}
function validateScriptPath(skillsDir, scriptPath) {
  const skillsDirResolved = resolve2(skillsDir);
  const scriptPathResolved = resolve2(scriptPath);
  const skillsDirNormalized = isWindows() ? skillsDirResolved.toLowerCase() : skillsDirResolved;
  const scriptPathNormalized = isWindows() ? scriptPathResolved.toLowerCase() : scriptPathResolved;
  if (!scriptPathNormalized.startsWith(skillsDirNormalized)) {
    throw new Error(`Script path outside skills directory: ${scriptPath}`);
  }
  const dangerousChars = ['"', "'", "`", "$", ";", "&", "|", `
`, "\r", "\x00"];
  for (const char of dangerousChars) {
    if (scriptPath.includes(char)) {
      throw new Error(`Script path contains unsafe character: ${char}`);
    }
  }
  logger.debug(`Script path validated: ${scriptPath}`);
}
var NPM_PACKAGE_REGEX;
var init_validators = __esm(() => {
  init_environment();
  init_logger();
  NPM_PACKAGE_REGEX = /^(@[a-z0-9-~][a-z0-9-._~]*\/)?[a-z0-9-~][a-z0-9-._~]*$/;
});

// src/services/package-installer/npm-package-manager.ts
async function isPackageInstalled(packageName) {
  validatePackageName(packageName);
  if (isCIEnvironment()) {
    logger.info(`CI environment detected: skipping network check for ${packageName}`);
    return false;
  }
  if (packageName === "npm") {
    try {
      await execAsync6(`${getNpmCommand()} --version`, { timeout: 3000 });
      return true;
    } catch {
      return false;
    }
  }
  try {
    await execAsync6(`${getNpmCommand()} view ${packageName} version`, { timeout: 3000 });
    try {
      const { stdout: stdout2 } = await execAsync6(`${getNpmCommand()} list -g ${packageName} --depth=0`, {
        timeout: 3000
      });
      const caseInsensitiveMatch = stdout2.toLowerCase().includes(packageName.toLowerCase());
      if (caseInsensitiveMatch) {
        return true;
      }
      const { stdout: jsonOutput } = await execAsync6(`${getNpmCommand()} list -g ${packageName} --depth=0 --json`, {
        timeout: 3000
      });
      const packageList = JSON.parse(jsonOutput);
      return packageList.dependencies?.[packageName] || false;
    } catch {
      return false;
    }
  } catch {
    return false;
  }
}
async function getPackageVersion(packageName) {
  validatePackageName(packageName);
  if (isCIEnvironment()) {
    logger.info(`CI environment detected: skipping version check for ${packageName}`);
    return null;
  }
  if (packageName === "npm") {
    try {
      const { stdout: stdout2 } = await execAsync6(`${getNpmCommand()} --version`, { timeout: 3000 });
      return stdout2.trim();
    } catch {
      return null;
    }
  }
  try {
    await execAsync6(`${getNpmCommand()} view ${packageName} version`, { timeout: 3000 });
  } catch {
    return null;
  }
  try {
    const { stdout: jsonOutput } = await execAsync6(`${getNpmCommand()} list -g ${packageName} --depth=0 --json`, {
      timeout: 3000
    });
    const packageList = JSON.parse(jsonOutput);
    if (packageList.dependencies?.[packageName]) {
      return packageList.dependencies[packageName].version || null;
    }
  } catch {}
  try {
    const { stdout: stdout2 } = await execAsync6(`${getNpmCommand()} list -g ${packageName} --depth=0`, {
      timeout: 3000
    });
    const patterns = [
      new RegExp(`${packageName.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}@([^\\s\\n]+)`),
      new RegExp(`${packageName.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}@([0-9]+\\.[0-9]+\\.[0-9]+(?:-[\\w.-]+)?)`)
    ];
    for (const pattern of patterns) {
      const match = stdout2.match(pattern);
      if (match?.[1]) {
        return match[1].trim();
      }
    }
    return null;
  } catch {
    return null;
  }
}
async function installPackageGlobally(packageName, packageDisplayName) {
  const displayName = packageDisplayName || packageName;
  validatePackageName(packageName);
  try {
    logger.info(`Installing ${displayName} globally...`);
    await execAsync6(`${getNpmCommand()} install -g ${packageName}`, {
      timeout: 120000
    });
    const isInstalled = await isPackageInstalled(packageName);
    if (!isInstalled) {
      return {
        success: false,
        package: displayName,
        error: "Installation completed but package not found"
      };
    }
    const version = await getPackageVersion(packageName);
    logger.success(`${displayName} ${version ? `v${version} ` : ""}installed successfully`);
    return {
      success: true,
      package: displayName,
      version: version || undefined
    };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    logger.error(`Failed to install ${displayName}: ${errorMessage}`);
    return {
      success: false,
      package: displayName,
      error: errorMessage
    };
  }
}
var init_npm_package_manager = __esm(() => {
  init_environment();
  init_logger();
  init_process_executor();
  init_validators();
});

// src/services/package-installer/gemini-installer.ts
async function isGeminiInstalled() {
  try {
    await execAsync6("gemini --version", { timeout: 1e4 });
    return true;
  } catch {
    return false;
  }
}
async function installGemini() {
  return installPackageGlobally("@google/gemini-cli", "Google Gemini CLI");
}
var init_gemini_installer = __esm(() => {
  init_npm_package_manager();
  init_process_executor();
});

// src/services/package-installer/opencode-installer.ts
import { join as join23 } from "node:path";
async function isOpenCodeInstalled() {
  try {
    await execAsync6("opencode --version", { timeout: 5000 });
    return true;
  } catch {
    return false;
  }
}
async function installOpenCode() {
  const displayName = "OpenCode CLI";
  if (isCIEnvironment()) {
    logger.info("CI environment detected: skipping OpenCode installation");
    return {
      success: false,
      package: displayName,
      error: "Installation skipped in CI environment"
    };
  }
  try {
    logger.info(`Installing ${displayName}...`);
    const { unlink: unlink6 } = await import("node:fs/promises");
    const { tmpdir: tmpdir3 } = await import("node:os");
    const tempScriptPath = join23(tmpdir3(), "opencode-install.sh");
    try {
      logger.info("Downloading OpenCode installation script...");
      await execFileAsync("curl", ["-fsSL", "https://opencode.ai/install", "-o", tempScriptPath], {
        timeout: 30000
      });
      await execFileAsync("chmod", ["+x", tempScriptPath], {
        timeout: 5000
      });
      logger.info("Executing OpenCode installation script...");
      await execFileAsync("bash", [tempScriptPath], {
        timeout: 120000
      });
    } finally {
      try {
        await unlink6(tempScriptPath);
      } catch {}
    }
    const installed = await isOpenCodeInstalled();
    if (installed) {
      logger.success(`${displayName} installed successfully`);
      return {
        success: true,
        package: displayName
      };
    }
    return {
      success: false,
      package: displayName,
      error: "Installation completed but opencode command not found in PATH"
    };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    logger.error(`Failed to install ${displayName}: ${errorMessage}`);
    return {
      success: false,
      package: displayName,
      error: errorMessage
    };
  }
}
var init_opencode_installer = __esm(() => {
  init_environment();
  init_logger();
  init_process_executor();
});

// src/services/package-installer/types.ts
var PARTIAL_INSTALL_VERSION = "partial", EXIT_CODE_CRITICAL_FAILURE = 1, EXIT_CODE_PARTIAL_SUCCESS = 2;

// src/services/package-installer/install-error-handler.ts
import { existsSync as existsSync13, readFileSync as readFileSync6, unlinkSync as unlinkSync2 } from "node:fs";
import { join as join24 } from "node:path";
function parseNameReason(str) {
  const colonIndex = str.indexOf(":");
  if (colonIndex === -1) {
    return [str.trim(), undefined];
  }
  return [str.slice(0, colonIndex).trim(), str.slice(colonIndex + 1).trim()];
}
function displayInstallErrors(skillsDir) {
  const summaryPath = join24(skillsDir, ".install-error-summary.json");
  if (!existsSync13(summaryPath)) {
    logger.error("Skills installation failed. Run with --verbose for details.");
    return;
  }
  let summary;
  try {
    summary = JSON.parse(readFileSync6(summaryPath, "utf-8"));
  } catch (parseError) {
    logger.error("Failed to parse error summary. File may be corrupted.");
    logger.debug(`Parse error: ${parseError instanceof Error ? parseError.message : String(parseError)}`);
    return;
  }
  try {
    if (summary.critical_failures.length > 0) {
      logger.error("");
      logger.error(" Critical Failures ");
      for (const failure of summary.critical_failures) {
        const [name, reason] = parseNameReason(failure);
        logger.error(`   ${name}`);
        if (reason)
          logger.error(`    Reason: ${reason}`);
      }
      logger.error("");
      logger.error("These must be fixed before skills can work.");
    }
    if (summary.optional_failures.length > 0) {
      logger.warning("");
      logger.warning(" Optional Package Failures ");
      for (const failure of summary.optional_failures) {
        const [name, reason] = parseNameReason(failure);
        logger.warning(`  ! ${name}`);
        if (reason)
          logger.info(`    Reason: ${reason}`);
      }
    }
    if (summary.skipped.length > 0) {
      logger.info("");
      logger.info(" Skipped (No sudo) ");
      for (const skipped of summary.skipped) {
        const [name] = parseNameReason(skipped);
        logger.info(`  ~ ${name}`);
      }
    }
    logger.info("");
    logger.info(" How to Fix ");
    logger.info("");
    if (summary.optional_failures.some((f3) => f3.includes("no wheel") || f3.includes("build tools") || f3.includes("build failed")) && summary.remediation.build_tools) {
      logger.info("Install build tools (one-time):");
      logger.info(`  ${summary.remediation.build_tools}`);
      logger.info("");
    }
    if (summary.skipped.length > 0 && summary.remediation.sudo_packages) {
      logger.info("Install system packages:");
      logger.info(`  ${summary.remediation.sudo_packages}`);
      logger.info("");
    }
    if (summary.optional_failures.length > 0 && summary.remediation.pip_retry) {
      logger.info("Then retry failed packages manually:");
      logger.info(`  ${summary.remediation.pip_retry}`);
    }
    try {
      unlinkSync2(summaryPath);
    } catch (cleanupError) {
      if (cleanupError.code !== "ENOENT") {
        logger.debug(`Failed to cleanup summary file: ${cleanupError instanceof Error ? cleanupError.message : String(cleanupError)}`);
      }
    }
  } catch (displayError) {
    logger.error("Failed to display error summary.");
    logger.debug(`Display error: ${displayError instanceof Error ? displayError.message : String(displayError)}`);
  }
}
async function checkNeedsSudoPackages() {
  if (process.platform !== "linux") {
    return false;
  }
  const { exec: exec7 } = await import("node:child_process");
  const { promisify: promisify7 } = await import("node:util");
  const execAsync7 = promisify7(exec7);
  try {
    await Promise.all([
      execAsync7("which ffmpeg", { timeout: WHICH_COMMAND_TIMEOUT_MS }),
      execAsync7("which convert", { timeout: WHICH_COMMAND_TIMEOUT_MS })
    ]);
    return false;
  } catch {
    return true;
  }
}
function hasInstallState(skillsDir) {
  const stateFilePath = join24(skillsDir, ".install-state.json");
  return existsSync13(stateFilePath);
}
var WHICH_COMMAND_TIMEOUT_MS = 5000;
var init_install_error_handler = __esm(() => {
  init_logger();
});

// src/services/package-installer/skills-installer.ts
import { join as join25 } from "node:path";
async function installSkillsDependencies(skillsDir, options = {}) {
  const { skipConfirm = false, withSudo = false } = options;
  const displayName = "Skills Dependencies";
  if (isCIEnvironment()) {
    logger.info("CI environment detected: skipping skills installation");
    return {
      success: false,
      package: displayName,
      error: "Installation skipped in CI environment"
    };
  }
  if (isNonInteractive() && !skipConfirm) {
    logger.info("Running in non-interactive mode. Skipping skills installation.");
    logger.info("See INSTALLATION.md for manual installation instructions.");
    return {
      success: false,
      package: displayName,
      error: "Skipped in non-interactive mode"
    };
  }
  try {
    const { existsSync: existsSync14 } = await import("node:fs");
    const clack = await Promise.resolve().then(() => (init_dist2(), exports_dist));
    const platform5 = process.platform;
    const scriptName = platform5 === "win32" ? "install.ps1" : "install.sh";
    const scriptPath = join25(skillsDir, scriptName);
    try {
      validateScriptPath(skillsDir, scriptPath);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      logger.error(`Invalid script path: ${errorMessage}`);
      return {
        success: false,
        package: displayName,
        error: `Path validation failed: ${errorMessage}`
      };
    }
    if (!existsSync14(scriptPath)) {
      logger.warning(`Skills installation script not found: ${scriptPath}`);
      logger.info("");
      logger.info("\uD83D\uDCD6 Manual Installation Instructions:");
      logger.info(`  See: ${join25(skillsDir, "INSTALLATION.md")}`);
      logger.info("");
      logger.info("Quick start:");
      logger.info("  cd .claude/skills/ai-multimodal/scripts");
      logger.info("  pip install -r requirements.txt");
      return {
        success: false,
        package: displayName,
        error: "Installation script not found"
      };
    }
    logger.warning("Installation script will execute with user privileges");
    logger.info(`  Script: ${scriptPath}`);
    logger.info(`  Platform: ${platform5 === "win32" ? "Windows (PowerShell)" : "Unix (bash)"}`);
    if (logger.isVerbose()) {
      try {
        const { readFile: readFile11 } = await import("node:fs/promises");
        const scriptContent = await readFile11(scriptPath, "utf-8");
        const previewLines = scriptContent.split(`
`).slice(0, 20);
        logger.verbose("Script preview (first 20 lines):");
        for (const line of previewLines) {
          logger.verbose(`  ${line}`);
        }
        if (scriptContent.split(`
`).length > 20) {
          logger.verbose("  ... (script continues)");
        }
      } catch {
        logger.verbose("Could not preview script contents");
      }
    }
    let shouldProceed = skipConfirm;
    if (!skipConfirm) {
      const userChoice = await clack.confirm({
        message: "Execute this installation script?",
        initialValue: false
      });
      shouldProceed = !clack.isCancel(userChoice) && userChoice;
    }
    if (!shouldProceed) {
      logger.info("Installation cancelled by user");
      logger.info("");
      logger.info("\uD83D\uDCD6 Manual Installation Instructions:");
      logger.info(`  ${platform5 === "win32" ? `powershell -File "${scriptPath}"` : `bash ${scriptPath}`}`);
      logger.info("");
      logger.info("Or see complete guide:");
      logger.info(`  ${join25(skillsDir, "INSTALLATION.md")}`);
      return {
        success: false,
        package: displayName,
        error: "Cancelled by user"
      };
    }
    logger.info(`Installing ${displayName}...`);
    logger.info(`Running: ${scriptPath}`);
    const scriptArgs = ["--yes"];
    if (hasInstallState(skillsDir)) {
      if (skipConfirm || isNonInteractive()) {
        logger.info("Resuming previous installation...");
        scriptArgs.push("--resume");
      } else {
        const shouldResume = await clack.confirm({
          message: "Previous installation was interrupted. Resume?",
          initialValue: true
        });
        if (!clack.isCancel(shouldResume) && shouldResume) {
          scriptArgs.push("--resume");
          logger.info("Resuming previous installation...");
        }
      }
    }
    if (platform5 === "linux") {
      const needsSudo = await checkNeedsSudoPackages();
      if (needsSudo) {
        if (withSudo) {
          logger.info("");
          logger.warning("Installing system packages with sudo:");
          logger.info("   ffmpeg - Video/audio processing");
          logger.info("   imagemagick - Image editing & conversion");
          logger.info("");
          logger.info("sudo will run: apt-get install -y ffmpeg imagemagick");
          logger.info("");
          scriptArgs.push("--with-sudo");
        } else if (skipConfirm || isNonInteractive()) {
          logger.info("");
          logger.warning("System packages skipped (not included without --with-sudo):");
          logger.info("   ffmpeg - Video/audio processing");
          logger.info("   imagemagick - Image editing & conversion");
          logger.info("");
          logger.info("To include system packages, run with --with-sudo flag:");
          logger.info("  ck init -g -y --install-skills --with-sudo");
          logger.info("");
          logger.info("Or install manually:");
          logger.info("  sudo apt-get install -y ffmpeg imagemagick");
          logger.info("");
        } else {
          logger.info("");
          logger.info("System packages (requires sudo):");
          logger.info("   ffmpeg - Video/audio processing");
          logger.info("   imagemagick - Image editing & conversion");
          logger.info("");
          const shouldInstallSudo = await clack.confirm({
            message: "Install these packages? (requires sudo password)",
            initialValue: true
          });
          if (!clack.isCancel(shouldInstallSudo) && shouldInstallSudo) {
            logger.info("");
            logger.info("sudo will run: apt-get install -y ffmpeg imagemagick");
            scriptArgs.push("--with-sudo");
          } else {
            logger.info("Skipping system packages. Install manually later:");
            logger.info("  sudo apt-get install -y ffmpeg imagemagick");
          }
        }
      }
    }
    const scriptEnv = {
      ...process.env,
      NON_INTERACTIVE: "1"
    };
    if (platform5 === "win32") {
      await executeInteractiveScript("powershell.exe", ["-NoLogo", "-ExecutionPolicy", "Bypass", "-File", scriptPath, "-Y"], {
        timeout: 600000,
        cwd: skillsDir,
        env: scriptEnv
      });
    } else {
      await executeInteractiveScript("bash", [scriptPath, ...scriptArgs], {
        timeout: 600000,
        cwd: skillsDir,
        env: scriptEnv
      });
    }
    logger.success(`${displayName} installed successfully`);
    return {
      success: true,
      package: displayName
    };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    const exitCodeMatch = errorMessage.match(/exited with code (\d+)/);
    const exitCode = exitCodeMatch ? Number.parseInt(exitCodeMatch[1], 10) : 1;
    if (exitCode === EXIT_CODE_PARTIAL_SUCCESS) {
      displayInstallErrors(skillsDir);
      logger.info("");
      logger.success("Core functionality is available despite some package failures.");
      return {
        success: true,
        package: displayName,
        version: PARTIAL_INSTALL_VERSION
      };
    }
    if (exitCode === EXIT_CODE_CRITICAL_FAILURE) {
      displayInstallErrors(skillsDir);
      logger.error("");
      logger.error("Skills installation failed. See above for details.");
      return {
        success: false,
        package: displayName,
        error: "Critical dependencies missing"
      };
    }
    logger.error(`Unexpected error: ${errorMessage}`);
    logger.info("");
    logger.info("\uD83D\uDCD6 Manual Installation Instructions:");
    logger.info("");
    logger.info("See complete guide:");
    logger.info(`  cat ${join25(skillsDir, "INSTALLATION.md")}`);
    logger.info("");
    logger.info("Quick start:");
    logger.info("  cd .claude/skills/ai-multimodal/scripts");
    logger.info("  pip install -r requirements.txt");
    logger.info("");
    logger.info("System tools (optional):");
    logger.info("  macOS: brew install ffmpeg imagemagick");
    logger.info("  Linux: sudo apt-get install ffmpeg imagemagick");
    logger.info("  Node.js: npm install -g pnpm wrangler repomix");
    return {
      success: false,
      package: displayName,
      error: errorMessage
    };
  }
}
async function handleSkillsInstallation(skillsDir, options = {}) {
  try {
    const skillsResult = await installSkillsDependencies(skillsDir, options);
    if (skillsResult.success) {
      if (skillsResult.version === PARTIAL_INSTALL_VERSION) {
        logger.success("Skills core dependencies installed (some optional packages skipped)");
      } else {
        logger.success("Skills dependencies installed successfully");
      }
    } else {
      logger.warning(`Skills installation incomplete: ${skillsResult.error || "Unknown error"}`);
      logger.info("You can install skills dependencies manually. See INSTALLATION.md");
    }
  } catch {
    logger.warning("Skills installation failed");
    logger.info("You can install skills dependencies manually later");
  }
}
var init_skills_installer = __esm(() => {
  init_environment();
  init_logger();
  init_install_error_handler();
  init_process_executor();
  init_validators();
});

// src/services/package-installer/gemini-mcp/config-manager.ts
import { existsSync as existsSync14 } from "node:fs";
import { mkdir as mkdir6, readFile as readFile11, writeFile as writeFile9 } from "node:fs/promises";
import { dirname as dirname3, join as join26 } from "node:path";
async function readJsonFile(filePath) {
  try {
    const content = await readFile11(filePath, "utf-8");
    return JSON.parse(content);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    logger.debug(`Failed to read/parse JSON file ${filePath}: ${errorMessage}`);
    return null;
  }
}
async function addGeminiToGitignore(projectDir) {
  const gitignorePath = join26(projectDir, ".gitignore");
  const geminiPattern = ".gemini/";
  try {
    let content = "";
    if (existsSync14(gitignorePath)) {
      content = await readFile11(gitignorePath, "utf-8");
      const lines = content.split(`
`).map((line) => line.trim()).filter((line) => !line.startsWith("#"));
      const geminiPatterns = [".gemini/", ".gemini", "/.gemini/", "/.gemini"];
      if (lines.some((line) => geminiPatterns.includes(line))) {
        logger.debug(".gemini/ already in .gitignore");
        return;
      }
    }
    const newLine = content.endsWith(`
`) || content === "" ? "" : `
`;
    const comment = "# Gemini CLI settings (contains user-specific config)";
    await writeFile9(gitignorePath, `${content}${newLine}${comment}
${geminiPattern}
`, "utf-8");
    logger.debug(`Added ${geminiPattern} to .gitignore`);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    logger.warning(`Failed to update .gitignore: ${errorMessage}`);
  }
}
async function createNewSettingsWithMerge(geminiSettingsPath, mcpConfigPath) {
  const linkDir = dirname3(geminiSettingsPath);
  if (!existsSync14(linkDir)) {
    await mkdir6(linkDir, { recursive: true });
    logger.debug(`Created directory: ${linkDir}`);
  }
  const mcpConfig = await readJsonFile(mcpConfigPath);
  if (!mcpConfig) {
    return { success: false, method: "merge", error: "Failed to read MCP config" };
  }
  const mcpServers = mcpConfig.mcpServers;
  if (!mcpServers || typeof mcpServers !== "object" || Array.isArray(mcpServers)) {
    return { success: false, method: "merge", error: "MCP config has no valid mcpServers object" };
  }
  const newSettings = { mcpServers };
  try {
    await writeFile9(geminiSettingsPath, JSON.stringify(newSettings, null, 2), "utf-8");
    logger.debug(`Created new Gemini settings with mcpServers: ${geminiSettingsPath}`);
    return { success: true, method: "merge", targetPath: mcpConfigPath };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    return {
      success: false,
      method: "merge",
      error: `Failed to write settings: ${errorMessage}`
    };
  }
}
async function mergeGeminiSettings(geminiSettingsPath, mcpConfigPath) {
  const geminiSettings = await readJsonFile(geminiSettingsPath);
  if (!geminiSettings) {
    return { success: false, method: "merge", error: "Failed to read existing Gemini settings" };
  }
  const mcpConfig = await readJsonFile(mcpConfigPath);
  if (!mcpConfig) {
    return { success: false, method: "merge", error: "Failed to read MCP config" };
  }
  const mcpServers = mcpConfig.mcpServers;
  if (!mcpServers || typeof mcpServers !== "object" || Array.isArray(mcpServers)) {
    return { success: false, method: "merge", error: "MCP config has no valid mcpServers object" };
  }
  const mergedSettings = {
    ...geminiSettings,
    mcpServers
  };
  try {
    await writeFile9(geminiSettingsPath, JSON.stringify(mergedSettings, null, 2), "utf-8");
    logger.debug(`Merged mcpServers into: ${geminiSettingsPath}`);
    return { success: true, method: "merge", targetPath: mcpConfigPath };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    return {
      success: false,
      method: "merge",
      error: `Failed to write merged settings: ${errorMessage}`
    };
  }
}
var init_config_manager = __esm(() => {
  init_logger();
});

// src/services/package-installer/gemini-mcp/validation.ts
import { existsSync as existsSync15, lstatSync, readlinkSync } from "node:fs";
import { homedir as homedir4 } from "node:os";
import { join as join27 } from "node:path";
function getGlobalMcpConfigPath() {
  return join27(homedir4(), ".claude", ".mcp.json");
}
function getLocalMcpConfigPath(projectDir) {
  return join27(projectDir, ".mcp.json");
}
function findMcpConfigPath(projectDir) {
  const localPath = getLocalMcpConfigPath(projectDir);
  if (existsSync15(localPath)) {
    logger.debug(`Found local MCP config: ${localPath}`);
    return localPath;
  }
  const globalPath = getGlobalMcpConfigPath();
  if (existsSync15(globalPath)) {
    logger.debug(`Found global MCP config: ${globalPath}`);
    return globalPath;
  }
  logger.debug("No MCP config found (local or global)");
  return null;
}
function getGeminiSettingsPath(projectDir, isGlobal) {
  if (isGlobal) {
    return join27(homedir4(), ".gemini", "settings.json");
  }
  return join27(projectDir, ".gemini", "settings.json");
}
function checkExistingGeminiConfig(projectDir, isGlobal = false) {
  const geminiSettingsPath = getGeminiSettingsPath(projectDir, isGlobal);
  if (!existsSync15(geminiSettingsPath)) {
    return { exists: false, isSymlink: false, settingsPath: geminiSettingsPath };
  }
  try {
    const stats = lstatSync(geminiSettingsPath);
    if (stats.isSymbolicLink()) {
      const target = readlinkSync(geminiSettingsPath);
      return {
        exists: true,
        isSymlink: true,
        currentTarget: target,
        settingsPath: geminiSettingsPath
      };
    }
    return { exists: true, isSymlink: false, settingsPath: geminiSettingsPath };
  } catch {
    return { exists: true, isSymlink: false, settingsPath: geminiSettingsPath };
  }
}
var init_validation = __esm(() => {
  init_logger();
});

// src/services/package-installer/gemini-mcp/linker-core.ts
import { existsSync as existsSync16 } from "node:fs";
import { mkdir as mkdir7, symlink as symlink2 } from "node:fs/promises";
import { dirname as dirname4, join as join28 } from "node:path";
async function createSymlink(targetPath, linkPath, projectDir, isGlobal) {
  const linkDir = dirname4(linkPath);
  if (!existsSync16(linkDir)) {
    await mkdir7(linkDir, { recursive: true });
    logger.debug(`Created directory: ${linkDir}`);
  }
  let symlinkTarget;
  if (isGlobal) {
    symlinkTarget = getGlobalMcpConfigPath();
  } else {
    const localMcpPath = join28(projectDir, ".mcp.json");
    const isLocalConfig = targetPath === localMcpPath;
    symlinkTarget = isLocalConfig ? "../.mcp.json" : targetPath;
  }
  try {
    await symlink2(symlinkTarget, linkPath, isWindows() ? "file" : undefined);
    logger.debug(`Created symlink: ${linkPath}  ${symlinkTarget}`);
    return { success: true, method: "symlink", targetPath, geminiSettingsPath: linkPath };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    return {
      success: false,
      method: "symlink",
      error: `Failed to create symlink: ${errorMessage}`
    };
  }
}
var init_linker_core = __esm(() => {
  init_environment();
  init_logger();
  init_validation();
});

// src/services/package-installer/gemini-mcp-linker.ts
var exports_gemini_mcp_linker = {};
__export(exports_gemini_mcp_linker, {
  processGeminiMcpLinking: () => processGeminiMcpLinking,
  linkGeminiMcpConfig: () => linkGeminiMcpConfig,
  getGeminiSettingsPath: () => getGeminiSettingsPath,
  findMcpConfigPath: () => findMcpConfigPath,
  checkExistingGeminiConfig: () => checkExistingGeminiConfig,
  addGeminiToGitignore: () => addGeminiToGitignore
});
import { resolve as resolve3 } from "node:path";
async function linkGeminiMcpConfig(projectDir, options = {}) {
  const { skipGitignore = false, isGlobal = false } = options;
  const resolvedProjectDir = resolve3(projectDir);
  const geminiSettingsPath = getGeminiSettingsPath(resolvedProjectDir, isGlobal);
  const mcpConfigPath = findMcpConfigPath(resolvedProjectDir);
  if (!mcpConfigPath) {
    return {
      success: false,
      method: "symlink",
      error: "No MCP config found. Create .mcp.json or ~/.claude/.mcp.json first."
    };
  }
  const existing = checkExistingGeminiConfig(resolvedProjectDir, isGlobal);
  let result;
  if (!existing.exists) {
    result = await createSymlink(mcpConfigPath, geminiSettingsPath, resolvedProjectDir, isGlobal);
    if (!result.success && process.platform === "win32") {
      logger.debug("Symlink failed on Windows, falling back to merge");
      result = await createNewSettingsWithMerge(geminiSettingsPath, mcpConfigPath);
    }
  } else if (existing.isSymlink) {
    result = {
      success: true,
      method: "skipped",
      targetPath: existing.currentTarget,
      geminiSettingsPath
    };
  } else {
    result = await mergeGeminiSettings(geminiSettingsPath, mcpConfigPath);
  }
  if (result.success && !skipGitignore && !isGlobal) {
    await addGeminiToGitignore(resolvedProjectDir);
  }
  return result;
}
async function processGeminiMcpLinking(projectDir, options = {}) {
  logger.info("Setting up Gemini CLI MCP integration...");
  const result = await linkGeminiMcpConfig(projectDir, options);
  const settingsPath = result.geminiSettingsPath || (options.isGlobal ? "~/.gemini/settings.json" : ".gemini/settings.json");
  if (result.success) {
    if (result.method === "symlink") {
      logger.success(`Gemini MCP linked: ${settingsPath}  ${result.targetPath}`);
      logger.info("MCP servers will auto-sync with your Claude config.");
    } else if (result.method === "merge") {
      logger.success("Gemini MCP config updated (merged mcpServers, preserved your settings)");
      logger.info("Note: Run 'ck init' again to sync MCP config changes.");
    } else {
      logger.info("Gemini MCP config already configured.");
    }
  } else {
    logger.warning(`Gemini MCP setup incomplete: ${result.error}`);
    const cmd = options.isGlobal ? "mkdir -p ~/.gemini && ln -sf ~/.claude/.mcp.json ~/.gemini/settings.json" : "mkdir -p .gemini && ln -sf ../.mcp.json .gemini/settings.json";
    logger.info(`Manual setup: ${cmd}`);
  }
}
var init_gemini_mcp_linker = __esm(() => {
  init_logger();
  init_config_manager();
  init_linker_core();
  init_validation();
  init_config_manager();
  init_validation();
});

// src/services/package-installer/package-installer.ts
var exports_package_installer = {};
__export(exports_package_installer, {
  validateScriptPath: () => validateScriptPath,
  validatePackageName: () => validatePackageName,
  processPackageInstallations: () => processPackageInstallations,
  isPackageInstalled: () => isPackageInstalled,
  isOpenCodeInstalled: () => isOpenCodeInstalled,
  isGeminiInstalled: () => isGeminiInstalled,
  installSkillsDependencies: () => installSkillsDependencies,
  installPackageGlobally: () => installPackageGlobally,
  installOpenCode: () => installOpenCode,
  installGemini: () => installGemini,
  handleSkillsInstallation: () => handleSkillsInstallation,
  getPackageVersion: () => getPackageVersion,
  getNpmCommand: () => getNpmCommand,
  executeInteractiveScript: () => executeInteractiveScript,
  execFileAsync: () => execFileAsync,
  execAsync: () => execAsync6,
  PARTIAL_INSTALL_VERSION: () => PARTIAL_INSTALL_VERSION,
  EXIT_CODE_PARTIAL_SUCCESS: () => EXIT_CODE_PARTIAL_SUCCESS,
  EXIT_CODE_CRITICAL_FAILURE: () => EXIT_CODE_CRITICAL_FAILURE
});
async function processPackageInstallations(shouldInstallOpenCode, shouldInstallGemini, projectDir) {
  const results = {};
  if (shouldInstallOpenCode) {
    const alreadyInstalled = await isOpenCodeInstalled();
    if (alreadyInstalled) {
      logger.info("OpenCode CLI already installed");
      results.opencode = {
        success: true,
        package: "OpenCode CLI"
      };
    } else {
      results.opencode = await installOpenCode();
    }
  }
  if (shouldInstallGemini) {
    const alreadyInstalled = await isGeminiInstalled();
    if (alreadyInstalled) {
      logger.info("Google Gemini CLI already installed");
      results.gemini = {
        success: true,
        package: "Google Gemini CLI"
      };
    } else {
      results.gemini = await installGemini();
    }
    const geminiAvailable = alreadyInstalled || results.gemini?.success;
    if (projectDir && geminiAvailable) {
      const { processGeminiMcpLinking: processGeminiMcpLinking2 } = await Promise.resolve().then(() => (init_gemini_mcp_linker(), exports_gemini_mcp_linker));
      await processGeminiMcpLinking2(projectDir);
    }
  }
  return results;
}
var init_package_installer = __esm(() => {
  init_logger();
  init_gemini_installer();
  init_opencode_installer();
  init_validators();
  init_process_executor();
  init_npm_package_manager();
  init_opencode_installer();
  init_gemini_installer();
  init_skills_installer();
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS((exports, module) => {
  function RetryOperation(timeouts, options) {
    if (typeof options === "boolean") {
      options = { forever: options };
    }
    this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
    this._timeouts = timeouts;
    this._options = options || {};
    this._maxRetryTime = options && options.maxRetryTime || Infinity;
    this._fn = null;
    this._errors = [];
    this._attempts = 1;
    this._operationTimeout = null;
    this._operationTimeoutCb = null;
    this._timeout = null;
    this._operationStart = null;
    if (this._options.forever) {
      this._cachedTimeouts = this._timeouts.slice(0);
    }
  }
  module.exports = RetryOperation;
  RetryOperation.prototype.reset = function() {
    this._attempts = 1;
    this._timeouts = this._originalTimeouts;
  };
  RetryOperation.prototype.stop = function() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    this._timeouts = [];
    this._cachedTimeouts = null;
  };
  RetryOperation.prototype.retry = function(err) {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    if (!err) {
      return false;
    }
    var currentTime = new Date().getTime();
    if (err && currentTime - this._operationStart >= this._maxRetryTime) {
      this._errors.unshift(new Error("RetryOperation timeout occurred"));
      return false;
    }
    this._errors.push(err);
    var timeout = this._timeouts.shift();
    if (timeout === undefined) {
      if (this._cachedTimeouts) {
        this._errors.splice(this._errors.length - 1, this._errors.length);
        this._timeouts = this._cachedTimeouts.slice(0);
        timeout = this._timeouts.shift();
      } else {
        return false;
      }
    }
    var self2 = this;
    var timer = setTimeout(function() {
      self2._attempts++;
      if (self2._operationTimeoutCb) {
        self2._timeout = setTimeout(function() {
          self2._operationTimeoutCb(self2._attempts);
        }, self2._operationTimeout);
        if (self2._options.unref) {
          self2._timeout.unref();
        }
      }
      self2._fn(self2._attempts);
    }, timeout);
    if (this._options.unref) {
      timer.unref();
    }
    return true;
  };
  RetryOperation.prototype.attempt = function(fn, timeoutOps) {
    this._fn = fn;
    if (timeoutOps) {
      if (timeoutOps.timeout) {
        this._operationTimeout = timeoutOps.timeout;
      }
      if (timeoutOps.cb) {
        this._operationTimeoutCb = timeoutOps.cb;
      }
    }
    var self2 = this;
    if (this._operationTimeoutCb) {
      this._timeout = setTimeout(function() {
        self2._operationTimeoutCb();
      }, self2._operationTimeout);
    }
    this._operationStart = new Date().getTime();
    this._fn(this._attempts);
  };
  RetryOperation.prototype.try = function(fn) {
    console.log("Using RetryOperation.try() is deprecated");
    this.attempt(fn);
  };
  RetryOperation.prototype.start = function(fn) {
    console.log("Using RetryOperation.start() is deprecated");
    this.attempt(fn);
  };
  RetryOperation.prototype.start = RetryOperation.prototype.try;
  RetryOperation.prototype.errors = function() {
    return this._errors;
  };
  RetryOperation.prototype.attempts = function() {
    return this._attempts;
  };
  RetryOperation.prototype.mainError = function() {
    if (this._errors.length === 0) {
      return null;
    }
    var counts = {};
    var mainError = null;
    var mainErrorCount = 0;
    for (var i = 0;i < this._errors.length; i++) {
      var error = this._errors[i];
      var message = error.message;
      var count = (counts[message] || 0) + 1;
      counts[message] = count;
      if (count >= mainErrorCount) {
        mainError = error;
        mainErrorCount = count;
      }
    }
    return mainError;
  };
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS((exports) => {
  var RetryOperation = require_retry_operation();
  exports.operation = function(options) {
    var timeouts = exports.timeouts(options);
    return new RetryOperation(timeouts, {
      forever: options && options.forever,
      unref: options && options.unref,
      maxRetryTime: options && options.maxRetryTime
    });
  };
  exports.timeouts = function(options) {
    if (options instanceof Array) {
      return [].concat(options);
    }
    var opts = {
      retries: 10,
      factor: 2,
      minTimeout: 1 * 1000,
      maxTimeout: Infinity,
      randomize: false
    };
    for (var key in options) {
      opts[key] = options[key];
    }
    if (opts.minTimeout > opts.maxTimeout) {
      throw new Error("minTimeout is greater than maxTimeout");
    }
    var timeouts = [];
    for (var i = 0;i < opts.retries; i++) {
      timeouts.push(this.createTimeout(i, opts));
    }
    if (options && options.forever && !timeouts.length) {
      timeouts.push(this.createTimeout(i, opts));
    }
    timeouts.sort(function(a3, b3) {
      return a3 - b3;
    });
    return timeouts;
  };
  exports.createTimeout = function(attempt, opts) {
    var random = opts.randomize ? Math.random() + 1 : 1;
    var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));
    timeout = Math.min(timeout, opts.maxTimeout);
    return timeout;
  };
  exports.wrap = function(obj, options, methods) {
    if (options instanceof Array) {
      methods = options;
      options = null;
    }
    if (!methods) {
      methods = [];
      for (var key in obj) {
        if (typeof obj[key] === "function") {
          methods.push(key);
        }
      }
    }
    for (var i = 0;i < methods.length; i++) {
      var method = methods[i];
      var original = obj[method];
      obj[method] = function retryWrapper(original2) {
        var op = exports.operation(options);
        var args = Array.prototype.slice.call(arguments, 1);
        var callback = args.pop();
        args.push(function(err) {
          if (op.retry(err)) {
            return;
          }
          if (err) {
            arguments[0] = op.mainError();
          }
          callback.apply(this, arguments);
        });
        op.attempt(function() {
          original2.apply(obj, args);
        });
      }.bind(obj, original);
      obj[method].options = options;
    }
  };
});

// node_modules/signal-exit/signals.js
var require_signals = __commonJS((exports, module) => {
  module.exports = [
    "SIGABRT",
    "SIGALRM",
    "SIGHUP",
    "SIGINT",
    "SIGTERM"
  ];
  if (process.platform !== "win32") {
    module.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
  }
  if (process.platform === "linux") {
    module.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
  }
});

// node_modules/signal-exit/index.js
var require_signal_exit = __commonJS((exports, module) => {
  var process2 = global.process;
  var processOk = function(process3) {
    return process3 && typeof process3 === "object" && typeof process3.removeListener === "function" && typeof process3.emit === "function" && typeof process3.reallyExit === "function" && typeof process3.listeners === "function" && typeof process3.kill === "function" && typeof process3.pid === "number" && typeof process3.on === "function";
  };
  if (!processOk(process2)) {
    module.exports = function() {
      return function() {};
    };
  } else {
    assert = __require("assert");
    signals = require_signals();
    isWin2 = /^win/i.test(process2.platform);
    EE = __require("events");
    if (typeof EE !== "function") {
      EE = EE.EventEmitter;
    }
    if (process2.__signal_exit_emitter__) {
      emitter = process2.__signal_exit_emitter__;
    } else {
      emitter = process2.__signal_exit_emitter__ = new EE;
      emitter.count = 0;
      emitter.emitted = {};
    }
    if (!emitter.infinite) {
      emitter.setMaxListeners(Infinity);
      emitter.infinite = true;
    }
    module.exports = function(cb, opts) {
      if (!processOk(global.process)) {
        return function() {};
      }
      assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
      if (loaded === false) {
        load();
      }
      var ev = "exit";
      if (opts && opts.alwaysLast) {
        ev = "afterexit";
      }
      var remove = function() {
        emitter.removeListener(ev, cb);
        if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
          unload();
        }
      };
      emitter.on(ev, cb);
      return remove;
    };
    unload = function unload() {
      if (!loaded || !processOk(global.process)) {
        return;
      }
      loaded = false;
      signals.forEach(function(sig) {
        try {
          process2.removeListener(sig, sigListeners[sig]);
        } catch (er) {}
      });
      process2.emit = originalProcessEmit;
      process2.reallyExit = originalProcessReallyExit;
      emitter.count -= 1;
    };
    module.exports.unload = unload;
    emit = function emit(event, code, signal) {
      if (emitter.emitted[event]) {
        return;
      }
      emitter.emitted[event] = true;
      emitter.emit(event, code, signal);
    };
    sigListeners = {};
    signals.forEach(function(sig) {
      sigListeners[sig] = function listener() {
        if (!processOk(global.process)) {
          return;
        }
        var listeners = process2.listeners(sig);
        if (listeners.length === emitter.count) {
          unload();
          emit("exit", null, sig);
          emit("afterexit", null, sig);
          if (isWin2 && sig === "SIGHUP") {
            sig = "SIGINT";
          }
          process2.kill(process2.pid, sig);
        }
      };
    });
    module.exports.signals = function() {
      return signals;
    };
    loaded = false;
    load = function load() {
      if (loaded || !processOk(global.process)) {
        return;
      }
      loaded = true;
      emitter.count += 1;
      signals = signals.filter(function(sig) {
        try {
          process2.on(sig, sigListeners[sig]);
          return true;
        } catch (er) {
          return false;
        }
      });
      process2.emit = processEmit;
      process2.reallyExit = processReallyExit;
    };
    module.exports.load = load;
    originalProcessReallyExit = process2.reallyExit;
    processReallyExit = function processReallyExit(code) {
      if (!processOk(global.process)) {
        return;
      }
      process2.exitCode = code || 0;
      emit("exit", process2.exitCode, null);
      emit("afterexit", process2.exitCode, null);
      originalProcessReallyExit.call(process2, process2.exitCode);
    };
    originalProcessEmit = process2.emit;
    processEmit = function processEmit(ev, arg) {
      if (ev === "exit" && processOk(global.process)) {
        if (arg !== undefined) {
          process2.exitCode = arg;
        }
        var ret = originalProcessEmit.apply(this, arguments);
        emit("exit", process2.exitCode, null);
        emit("afterexit", process2.exitCode, null);
        return ret;
      } else {
        return originalProcessEmit.apply(this, arguments);
      }
    };
  }
  var assert;
  var signals;
  var isWin2;
  var EE;
  var emitter;
  var unload;
  var emit;
  var sigListeners;
  var loaded;
  var load;
  var originalProcessReallyExit;
  var processReallyExit;
  var originalProcessEmit;
  var processEmit;
});

// node_modules/proper-lockfile/lib/mtime-precision.js
var require_mtime_precision = __commonJS((exports, module) => {
  var cacheSymbol = Symbol();
  function probe(file, fs3, callback) {
    const cachedPrecision = fs3[cacheSymbol];
    if (cachedPrecision) {
      return fs3.stat(file, (err, stat3) => {
        if (err) {
          return callback(err);
        }
        callback(null, stat3.mtime, cachedPrecision);
      });
    }
    const mtime = new Date(Math.ceil(Date.now() / 1000) * 1000 + 5);
    fs3.utimes(file, mtime, mtime, (err) => {
      if (err) {
        return callback(err);
      }
      fs3.stat(file, (err2, stat3) => {
        if (err2) {
          return callback(err2);
        }
        const precision = stat3.mtime.getTime() % 1000 === 0 ? "s" : "ms";
        Object.defineProperty(fs3, cacheSymbol, { value: precision });
        callback(null, stat3.mtime, precision);
      });
    });
  }
  function getMtime(precision) {
    let now = Date.now();
    if (precision === "s") {
      now = Math.ceil(now / 1000) * 1000;
    }
    return new Date(now);
  }
  exports.probe = probe;
  exports.getMtime = getMtime;
});

// node_modules/proper-lockfile/lib/lockfile.js
var require_lockfile = __commonJS((exports, module) => {
  var path2 = __require("path");
  var fs3 = require_graceful_fs();
  var retry = require_retry();
  var onExit = require_signal_exit();
  var mtimePrecision = require_mtime_precision();
  var locks = {};
  function getLockFile(file, options) {
    return options.lockfilePath || `${file}.lock`;
  }
  function resolveCanonicalPath(file, options, callback) {
    if (!options.realpath) {
      return callback(null, path2.resolve(file));
    }
    options.fs.realpath(file, callback);
  }
  function acquireLock(file, options, callback) {
    const lockfilePath = getLockFile(file, options);
    options.fs.mkdir(lockfilePath, (err) => {
      if (!err) {
        return mtimePrecision.probe(lockfilePath, options.fs, (err2, mtime, mtimePrecision2) => {
          if (err2) {
            options.fs.rmdir(lockfilePath, () => {});
            return callback(err2);
          }
          callback(null, mtime, mtimePrecision2);
        });
      }
      if (err.code !== "EEXIST") {
        return callback(err);
      }
      if (options.stale <= 0) {
        return callback(Object.assign(new Error("Lock file is already being held"), { code: "ELOCKED", file }));
      }
      options.fs.stat(lockfilePath, (err2, stat3) => {
        if (err2) {
          if (err2.code === "ENOENT") {
            return acquireLock(file, { ...options, stale: 0 }, callback);
          }
          return callback(err2);
        }
        if (!isLockStale(stat3, options)) {
          return callback(Object.assign(new Error("Lock file is already being held"), { code: "ELOCKED", file }));
        }
        removeLock(file, options, (err3) => {
          if (err3) {
            return callback(err3);
          }
          acquireLock(file, { ...options, stale: 0 }, callback);
        });
      });
    });
  }
  function isLockStale(stat3, options) {
    return stat3.mtime.getTime() < Date.now() - options.stale;
  }
  function removeLock(file, options, callback) {
    options.fs.rmdir(getLockFile(file, options), (err) => {
      if (err && err.code !== "ENOENT") {
        return callback(err);
      }
      callback();
    });
  }
  function updateLock(file, options) {
    const lock2 = locks[file];
    if (lock2.updateTimeout) {
      return;
    }
    lock2.updateDelay = lock2.updateDelay || options.update;
    lock2.updateTimeout = setTimeout(() => {
      lock2.updateTimeout = null;
      options.fs.stat(lock2.lockfilePath, (err, stat3) => {
        const isOverThreshold = lock2.lastUpdate + options.stale < Date.now();
        if (err) {
          if (err.code === "ENOENT" || isOverThreshold) {
            return setLockAsCompromised(file, lock2, Object.assign(err, { code: "ECOMPROMISED" }));
          }
          lock2.updateDelay = 1000;
          return updateLock(file, options);
        }
        const isMtimeOurs = lock2.mtime.getTime() === stat3.mtime.getTime();
        if (!isMtimeOurs) {
          return setLockAsCompromised(file, lock2, Object.assign(new Error("Unable to update lock within the stale threshold"), { code: "ECOMPROMISED" }));
        }
        const mtime = mtimePrecision.getMtime(lock2.mtimePrecision);
        options.fs.utimes(lock2.lockfilePath, mtime, mtime, (err2) => {
          const isOverThreshold2 = lock2.lastUpdate + options.stale < Date.now();
          if (lock2.released) {
            return;
          }
          if (err2) {
            if (err2.code === "ENOENT" || isOverThreshold2) {
              return setLockAsCompromised(file, lock2, Object.assign(err2, { code: "ECOMPROMISED" }));
            }
            lock2.updateDelay = 1000;
            return updateLock(file, options);
          }
          lock2.mtime = mtime;
          lock2.lastUpdate = Date.now();
          lock2.updateDelay = null;
          updateLock(file, options);
        });
      });
    }, lock2.updateDelay);
    if (lock2.updateTimeout.unref) {
      lock2.updateTimeout.unref();
    }
  }
  function setLockAsCompromised(file, lock2, err) {
    lock2.released = true;
    if (lock2.updateTimeout) {
      clearTimeout(lock2.updateTimeout);
    }
    if (locks[file] === lock2) {
      delete locks[file];
    }
    lock2.options.onCompromised(err);
  }
  function lock(file, options, callback) {
    options = {
      stale: 1e4,
      update: null,
      realpath: true,
      retries: 0,
      fs: fs3,
      onCompromised: (err) => {
        throw err;
      },
      ...options
    };
    options.retries = options.retries || 0;
    options.retries = typeof options.retries === "number" ? { retries: options.retries } : options.retries;
    options.stale = Math.max(options.stale || 0, 2000);
    options.update = options.update == null ? options.stale / 2 : options.update || 0;
    options.update = Math.max(Math.min(options.update, options.stale / 2), 1000);
    resolveCanonicalPath(file, options, (err, file2) => {
      if (err) {
        return callback(err);
      }
      const operation = retry.operation(options.retries);
      operation.attempt(() => {
        acquireLock(file2, options, (err2, mtime, mtimePrecision2) => {
          if (operation.retry(err2)) {
            return;
          }
          if (err2) {
            return callback(operation.mainError());
          }
          const lock2 = locks[file2] = {
            lockfilePath: getLockFile(file2, options),
            mtime,
            mtimePrecision: mtimePrecision2,
            options,
            lastUpdate: Date.now()
          };
          updateLock(file2, options);
          callback(null, (releasedCallback) => {
            if (lock2.released) {
              return releasedCallback && releasedCallback(Object.assign(new Error("Lock is already released"), { code: "ERELEASED" }));
            }
            unlock(file2, { ...options, realpath: false }, releasedCallback);
          });
        });
      });
    });
  }
  function unlock(file, options, callback) {
    options = {
      fs: fs3,
      realpath: true,
      ...options
    };
    resolveCanonicalPath(file, options, (err, file2) => {
      if (err) {
        return callback(err);
      }
      const lock2 = locks[file2];
      if (!lock2) {
        return callback(Object.assign(new Error("Lock is not acquired/owned by you"), { code: "ENOTACQUIRED" }));
      }
      lock2.updateTimeout && clearTimeout(lock2.updateTimeout);
      lock2.released = true;
      delete locks[file2];
      removeLock(file2, options, callback);
    });
  }
  function check(file, options, callback) {
    options = {
      stale: 1e4,
      realpath: true,
      fs: fs3,
      ...options
    };
    options.stale = Math.max(options.stale || 0, 2000);
    resolveCanonicalPath(file, options, (err, file2) => {
      if (err) {
        return callback(err);
      }
      options.fs.stat(getLockFile(file2, options), (err2, stat3) => {
        if (err2) {
          return err2.code === "ENOENT" ? callback(null, false) : callback(err2);
        }
        return callback(null, !isLockStale(stat3, options));
      });
    });
  }
  function getLocks() {
    return locks;
  }
  onExit(() => {
    for (const file in locks) {
      const options = locks[file].options;
      try {
        options.fs.rmdirSync(getLockFile(file, options));
      } catch (e2) {}
    }
  });
  exports.lock = lock;
  exports.unlock = unlock;
  exports.check = check;
  exports.getLocks = getLocks;
});

// node_modules/proper-lockfile/lib/adapter.js
var require_adapter = __commonJS((exports, module) => {
  var fs3 = require_graceful_fs();
  function createSyncFs(fs4) {
    const methods = ["mkdir", "realpath", "stat", "rmdir", "utimes"];
    const newFs = { ...fs4 };
    methods.forEach((method) => {
      newFs[method] = (...args) => {
        const callback = args.pop();
        let ret;
        try {
          ret = fs4[`${method}Sync`](...args);
        } catch (err) {
          return callback(err);
        }
        callback(null, ret);
      };
    });
    return newFs;
  }
  function toPromise(method) {
    return (...args) => new Promise((resolve4, reject) => {
      args.push((err, result) => {
        if (err) {
          reject(err);
        } else {
          resolve4(result);
        }
      });
      method(...args);
    });
  }
  function toSync(method) {
    return (...args) => {
      let err;
      let result;
      args.push((_err, _result) => {
        err = _err;
        result = _result;
      });
      method(...args);
      if (err) {
        throw err;
      }
      return result;
    };
  }
  function toSyncOptions(options) {
    options = { ...options };
    options.fs = createSyncFs(options.fs || fs3);
    if (typeof options.retries === "number" && options.retries > 0 || options.retries && typeof options.retries.retries === "number" && options.retries.retries > 0) {
      throw Object.assign(new Error("Cannot use retries with the sync api"), { code: "ESYNC" });
    }
    return options;
  }
  module.exports = {
    toPromise,
    toSync,
    toSyncOptions
  };
});

// node_modules/proper-lockfile/index.js
var require_proper_lockfile = __commonJS((exports, module) => {
  var lockfile = require_lockfile();
  var { toPromise, toSync, toSyncOptions } = require_adapter();
  async function lock(file, options) {
    const release = await toPromise(lockfile.lock)(file, options);
    return toPromise(release);
  }
  function lockSync(file, options) {
    const release = toSync(lockfile.lock)(file, toSyncOptions(options));
    return toSync(release);
  }
  function unlock(file, options) {
    return toPromise(lockfile.unlock)(file, options);
  }
  function unlockSync(file, options) {
    return toSync(lockfile.unlock)(file, toSyncOptions(options));
  }
  function check(file, options) {
    return toPromise(lockfile.check)(file, options);
  }
  function checkSync(file, options) {
    return toSync(lockfile.check)(file, toSyncOptions(options));
  }
  module.exports = lock;
  module.exports.lock = lock;
  module.exports.unlock = unlock;
  module.exports.lockSync = lockSync;
  module.exports.unlockSync = unlockSync;
  module.exports.check = check;
  module.exports.checkSync = checkSync;
});

// node_modules/cli-spinners/spinners.json
var require_spinners = __commonJS((exports, module) => {
  module.exports = {
    dots: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dots2: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dots3: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dots4: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dots5: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dots6: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dots7: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dots8: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dots9: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dots10: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dots11: {
      interval: 100,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dots12: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dots13: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dots8Bit: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    sand: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    line: {
      interval: 130,
      frames: [
        "-",
        "\\",
        "|",
        "/"
      ]
    },
    line2: {
      interval: 100,
      frames: [
        "",
        "-",
        "",
        "",
        "",
        "-"
      ]
    },
    pipe: {
      interval: 100,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    simpleDots: {
      interval: 400,
      frames: [
        ".  ",
        ".. ",
        "...",
        "   "
      ]
    },
    simpleDotsScrolling: {
      interval: 200,
      frames: [
        ".  ",
        ".. ",
        "...",
        " ..",
        "  .",
        "   "
      ]
    },
    star: {
      interval: 70,
      frames: [
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    star2: {
      interval: 80,
      frames: [
        "+",
        "x",
        "*"
      ]
    },
    flip: {
      interval: 70,
      frames: [
        "_",
        "_",
        "_",
        "-",
        "`",
        "`",
        "'",
        "",
        "-",
        "_",
        "_",
        "_"
      ]
    },
    hamburger: {
      interval: 100,
      frames: [
        "",
        "",
        ""
      ]
    },
    growVertical: {
      interval: 120,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    growHorizontal: {
      interval: 120,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    balloon: {
      interval: 140,
      frames: [
        " ",
        ".",
        "o",
        "O",
        "@",
        "*",
        " "
      ]
    },
    balloon2: {
      interval: 120,
      frames: [
        ".",
        "o",
        "O",
        "",
        "O",
        "o",
        "."
      ]
    },
    noise: {
      interval: 100,
      frames: [
        "",
        "",
        ""
      ]
    },
    bounce: {
      interval: 120,
      frames: [
        "",
        "",
        "",
        ""
      ]
    },
    boxBounce: {
      interval: 120,
      frames: [
        "",
        "",
        "",
        ""
      ]
    },
    boxBounce2: {
      interval: 100,
      frames: [
        "",
        "",
        "",
        ""
      ]
    },
    triangle: {
      interval: 50,
      frames: [
        "",
        "",
        "",
        ""
      ]
    },
    binary: {
      interval: 80,
      frames: [
        "010010",
        "001100",
        "100101",
        "111010",
        "111101",
        "010111",
        "101011",
        "111000",
        "110011",
        "110101"
      ]
    },
    arc: {
      interval: 100,
      frames: [
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    circle: {
      interval: 120,
      frames: [
        "",
        "",
        ""
      ]
    },
    squareCorners: {
      interval: 180,
      frames: [
        "",
        "",
        "",
        ""
      ]
    },
    circleQuarters: {
      interval: 120,
      frames: [
        "",
        "",
        "",
        ""
      ]
    },
    circleHalves: {
      interval: 50,
      frames: [
        "",
        "",
        "",
        ""
      ]
    },
    squish: {
      interval: 100,
      frames: [
        "",
        ""
      ]
    },
    toggle: {
      interval: 250,
      frames: [
        "",
        ""
      ]
    },
    toggle2: {
      interval: 80,
      frames: [
        "",
        ""
      ]
    },
    toggle3: {
      interval: 120,
      frames: [
        "",
        ""
      ]
    },
    toggle4: {
      interval: 100,
      frames: [
        "",
        "",
        "",
        ""
      ]
    },
    toggle5: {
      interval: 100,
      frames: [
        "",
        ""
      ]
    },
    toggle6: {
      interval: 300,
      frames: [
        "",
        ""
      ]
    },
    toggle7: {
      interval: 80,
      frames: [
        "",
        ""
      ]
    },
    toggle8: {
      interval: 100,
      frames: [
        "",
        ""
      ]
    },
    toggle9: {
      interval: 100,
      frames: [
        "",
        ""
      ]
    },
    toggle10: {
      interval: 100,
      frames: [
        "",
        "",
        ""
      ]
    },
    toggle11: {
      interval: 50,
      frames: [
        "",
        ""
      ]
    },
    toggle12: {
      interval: 120,
      frames: [
        "",
        ""
      ]
    },
    toggle13: {
      interval: 80,
      frames: [
        "=",
        "*",
        "-"
      ]
    },
    arrow: {
      interval: 100,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    arrow2: {
      interval: 80,
      frames: [
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " "
      ]
    },
    arrow3: {
      interval: 120,
      frames: [
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    bouncingBar: {
      interval: 80,
      frames: [
        "[    ]",
        "[=   ]",
        "[==  ]",
        "[=== ]",
        "[====]",
        "[ ===]",
        "[  ==]",
        "[   =]",
        "[    ]",
        "[   =]",
        "[  ==]",
        "[ ===]",
        "[====]",
        "[=== ]",
        "[==  ]",
        "[=   ]"
      ]
    },
    bouncingBall: {
      interval: 80,
      frames: [
        "(     )",
        "(     )",
        "(     )",
        "(     )",
        "(     )",
        "(     )",
        "(     )",
        "(     )",
        "(     )",
        "(     )"
      ]
    },
    smiley: {
      interval: 200,
      frames: [
        " ",
        " "
      ]
    },
    monkey: {
      interval: 300,
      frames: [
        " ",
        " ",
        " ",
        " "
      ]
    },
    hearts: {
      interval: 100,
      frames: [
        " ",
        " ",
        " ",
        " ",
        " "
      ]
    },
    clock: {
      interval: 100,
      frames: [
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " "
      ]
    },
    earth: {
      interval: 180,
      frames: [
        " ",
        " ",
        " "
      ]
    },
    material: {
      interval: 17,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    moon: {
      interval: 80,
      frames: [
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " "
      ]
    },
    runner: {
      interval: 140,
      frames: [
        " ",
        " "
      ]
    },
    pong: {
      interval: 80,
      frames: [
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       "
      ]
    },
    shark: {
      interval: 120,
      frames: [
        "|\\____________",
        "_|\\___________",
        "__|\\__________",
        "___|\\_________",
        "____|\\________",
        "_____|\\_______",
        "______|\\______",
        "_______|\\_____",
        "________|\\____",
        "_________|\\___",
        "__________|\\__",
        "___________|\\_",
        "____________|\\",
        "____________/|",
        "___________/|_",
        "__________/|__",
        "_________/|___",
        "________/|____",
        "_______/|_____",
        "______/|______",
        "_____/|_______",
        "____/|________",
        "___/|_________",
        "__/|__________",
        "_/|___________",
        "/|____________"
      ]
    },
    dqpb: {
      interval: 100,
      frames: [
        "d",
        "q",
        "p",
        "b"
      ]
    },
    weather: {
      interval: 100,
      frames: [
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " "
      ]
    },
    christmas: {
      interval: 400,
      frames: [
        "",
        ""
      ]
    },
    grenade: {
      interval: 80,
      frames: [
        "  ",
        "  ",
        "  ",
        "  ",
        "  ",
        "  ",
        "  |",
        "  ",
        "  ",
        "  ",
        "  ",
        "   ",
        "   ",
        "   "
      ]
    },
    point: {
      interval: 125,
      frames: [
        "",
        "",
        "",
        "",
        ""
      ]
    },
    layer: {
      interval: 150,
      frames: [
        "-",
        "=",
        ""
      ]
    },
    betaWave: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    fingerDance: {
      interval: 160,
      frames: [
        " ",
        " ",
        " ",
        " ",
        " ",
        " "
      ]
    },
    fistBump: {
      interval: 80,
      frames: [
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " "
      ]
    },
    soccerHeader: {
      interval: 80,
      frames: [
        "         ",
        "         ",
        "         ",
        "         ",
        "         ",
        "         ",
        "         ",
        "         ",
        "         ",
        "         ",
        "         ",
        "         "
      ]
    },
    mindblown: {
      interval: 160,
      frames: [
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " "
      ]
    },
    speaker: {
      interval: 160,
      frames: [
        " ",
        " ",
        " ",
        " "
      ]
    },
    orangePulse: {
      interval: 100,
      frames: [
        " ",
        " ",
        " ",
        " ",
        " "
      ]
    },
    bluePulse: {
      interval: 100,
      frames: [
        " ",
        " ",
        " ",
        " ",
        " "
      ]
    },
    orangeBluePulse: {
      interval: 100,
      frames: [
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " "
      ]
    },
    timeTravel: {
      interval: 100,
      frames: [
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " ",
        " "
      ]
    },
    aesthetic: {
      interval: 80,
      frames: [
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ]
    },
    dwarfFortress: {
      interval: 80,
      frames: [
        "   ",
        "  ",
        "  ",
        "  ",
        "  ",
        "  ",
        "  ",
        "  ",
        "  ",
        "   ",
        "   ",
        "   ",
        "   ",
        "   ",
        "   ",
        "   ",
        "   ",
        "   ",
        "    ",
        "    ",
        "    ",
        "    ",
        "    ",
        "    ",
        "    ",
        "    ",
        "    ",
        "     ",
        "     ",
        "     ",
        "     ",
        "     ",
        "     ",
        "     ",
        "     ",
        "     ",
        "      ",
        "      ",
        "      ",
        "      ",
        "      ",
        "      ",
        "      ",
        "      ",
        "      ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "       ",
        "        ",
        "        ",
        "        ",
        "        ",
        "        ",
        "        ",
        "        ",
        "        ",
        "        ",
        "         ",
        "         ",
        "         ",
        "         ",
        "         ",
        "         ",
        "         ",
        "         ",
        "         ",
        "          ",
        "          ",
        "          ",
        "          ",
        "          ",
        "          ",
        "          ",
        "          ",
        "          ",
        "           ",
        "          &",
        "         &",
        "         &",
        "         &",
        "        & ",
        "         & ",
        "        &  ",
        "        &  ",
        "       &   ",
        "       &   ",
        "      &    ",
        "      &    ",
        "      &     ",
        "      &     ",
        "     &     ",
        "     &     ",
        "    &      ",
        "    &      ",
        "   &      ",
        "   &      ",
        "  &       ",
        "  &       ",
        " &       ",
        " &       ",
        "&        ",
        "&        ",
        "        ",
        "        ",
        "        ",
        "        ",
        "       ",
        "       ",
        "       ",
        "       ",
        "      ",
        "      ",
        "      ",
        "      ",
        "     ",
        "     ",
        "     ",
        "     ",
        "    ",
        "    ",
        "    ",
        "    ",
        "   ",
        "   ",
        "   ",
        "   ",
        "   "
      ]
    }
  };
});

// node_modules/cli-spinners/index.js
var require_cli_spinners = __commonJS((exports, module) => {
  var spinners = Object.assign({}, require_spinners());
  var spinnersList = Object.keys(spinners);
  Object.defineProperty(spinners, "random", {
    get() {
      const randomIndex = Math.floor(Math.random() * spinnersList.length);
      const spinnerName = spinnersList[randomIndex];
      return spinners[spinnerName];
    }
  });
  module.exports = spinners;
});

// node_modules/ora/node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS((exports, module) => {
  module.exports = () => {
    return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E-\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED8\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])))?))?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3C-\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE8A\uDE8E-\uDEC2\uDEC6\uDEC8\uDECD-\uDEDC\uDEDF-\uDEEA\uDEEF]|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
  };
});

// node_modules/ignore/index.js
var require_ignore = __commonJS((exports, module) => {
  function makeArray(subject) {
    return Array.isArray(subject) ? subject : [subject];
  }
  var EMPTY = "";
  var SPACE = " ";
  var ESCAPE = "\\";
  var REGEX_TEST_BLANK_LINE = /^\s+$/;
  var REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
  var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
  var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
  var REGEX_SPLITALL_CRLF = /\r?\n/g;
  var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
  var SLASH = "/";
  var TMP_KEY_IGNORE = "node-ignore";
  if (typeof Symbol !== "undefined") {
    TMP_KEY_IGNORE = Symbol.for("node-ignore");
  }
  var KEY_IGNORE = TMP_KEY_IGNORE;
  var define2 = (object, key, value) => Object.defineProperty(object, key, { value });
  var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
  var RETURN_FALSE = () => false;
  var sanitizeRange = (range) => range.replace(REGEX_REGEXP_RANGE, (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY);
  var cleanRangeBackSlash = (slashes) => {
    const { length } = slashes;
    return slashes.slice(0, length - length % 2);
  };
  var REPLACERS = [
    [
      /^\uFEFF/,
      () => EMPTY
    ],
    [
      /((?:\\\\)*?)(\\?\s+)$/,
      (_3, m1, m2) => m1 + (m2.indexOf("\\") === 0 ? SPACE : EMPTY)
    ],
    [
      /(\\+?)\s/g,
      (_3, m1) => {
        const { length } = m1;
        return m1.slice(0, length - length % 2) + SPACE;
      }
    ],
    [
      /[\\$.|*+(){^]/g,
      (match) => `\\${match}`
    ],
    [
      /(?!\\)\?/g,
      () => "[^/]"
    ],
    [
      /^\//,
      () => "^"
    ],
    [
      /\//g,
      () => "\\/"
    ],
    [
      /^\^*\\\*\\\*\\\//,
      () => "^(?:.*\\/)?"
    ],
    [
      /^(?=[^^])/,
      function startingReplacer() {
        return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
      }
    ],
    [
      /\\\/\\\*\\\*(?=\\\/|$)/g,
      (_3, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
    ],
    [
      /(^|[^\\]+)(\\\*)+(?=.+)/g,
      (_3, p1, p2) => {
        const unescaped = p2.replace(/\\\*/g, "[^\\/]*");
        return p1 + unescaped;
      }
    ],
    [
      /\\\\\\(?=[$.|*+(){^])/g,
      () => ESCAPE
    ],
    [
      /\\\\/g,
      () => ESCAPE
    ],
    [
      /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
      (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
    ],
    [
      /(?:[^*])$/,
      (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
    ],
    [
      /(\^|\\\/)?\\\*$/,
      (_3, p1) => {
        const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
        return `${prefix}(?=$|\\/$)`;
      }
    ]
  ];
  var regexCache = Object.create(null);
  var makeRegex = (pattern, ignoreCase) => {
    let source = regexCache[pattern];
    if (!source) {
      source = REPLACERS.reduce((prev, [matcher, replacer]) => prev.replace(matcher, replacer.bind(pattern)), pattern);
      regexCache[pattern] = source;
    }
    return ignoreCase ? new RegExp(source, "i") : new RegExp(source);
  };
  var isString = (subject) => typeof subject === "string";
  var checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf("#") !== 0;
  var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF);

  class IgnoreRule {
    constructor(origin, pattern, negative, regex2) {
      this.origin = origin;
      this.pattern = pattern;
      this.negative = negative;
      this.regex = regex2;
    }
  }
  var createRule = (pattern, ignoreCase) => {
    const origin = pattern;
    let negative = false;
    if (pattern.indexOf("!") === 0) {
      negative = true;
      pattern = pattern.substr(1);
    }
    pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
    const regex2 = makeRegex(pattern, ignoreCase);
    return new IgnoreRule(origin, pattern, negative, regex2);
  };
  var throwError = (message, Ctor) => {
    throw new Ctor(message);
  };
  var checkPath = (path2, originalPath, doThrow) => {
    if (!isString(path2)) {
      return doThrow(`path must be a string, but got \`${originalPath}\``, TypeError);
    }
    if (!path2) {
      return doThrow(`path must not be empty`, TypeError);
    }
    if (checkPath.isNotRelative(path2)) {
      const r2 = "`path.relative()`d";
      return doThrow(`path should be a ${r2} string, but got "${originalPath}"`, RangeError);
    }
    return true;
  };
  var isNotRelative = (path2) => REGEX_TEST_INVALID_PATH.test(path2);
  checkPath.isNotRelative = isNotRelative;
  checkPath.convert = (p) => p;

  class Ignore {
    constructor({
      ignorecase = true,
      ignoreCase = ignorecase,
      allowRelativePaths = false
    } = {}) {
      define2(this, KEY_IGNORE, true);
      this._rules = [];
      this._ignoreCase = ignoreCase;
      this._allowRelativePaths = allowRelativePaths;
      this._initCache();
    }
    _initCache() {
      this._ignoreCache = Object.create(null);
      this._testCache = Object.create(null);
    }
    _addPattern(pattern) {
      if (pattern && pattern[KEY_IGNORE]) {
        this._rules = this._rules.concat(pattern._rules);
        this._added = true;
        return;
      }
      if (checkPattern(pattern)) {
        const rule = createRule(pattern, this._ignoreCase);
        this._added = true;
        this._rules.push(rule);
      }
    }
    add(pattern) {
      this._added = false;
      makeArray(isString(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this);
      if (this._added) {
        this._initCache();
      }
      return this;
    }
    addPattern(pattern) {
      return this.add(pattern);
    }
    _testOne(path2, checkUnignored) {
      let ignored = false;
      let unignored = false;
      this._rules.forEach((rule) => {
        const { negative } = rule;
        if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
          return;
        }
        const matched = rule.regex.test(path2);
        if (matched) {
          ignored = !negative;
          unignored = negative;
        }
      });
      return {
        ignored,
        unignored
      };
    }
    _test(originalPath, cache, checkUnignored, slices) {
      const path2 = originalPath && checkPath.convert(originalPath);
      checkPath(path2, originalPath, this._allowRelativePaths ? RETURN_FALSE : throwError);
      return this._t(path2, cache, checkUnignored, slices);
    }
    _t(path2, cache, checkUnignored, slices) {
      if (path2 in cache) {
        return cache[path2];
      }
      if (!slices) {
        slices = path2.split(SLASH);
      }
      slices.pop();
      if (!slices.length) {
        return cache[path2] = this._testOne(path2, checkUnignored);
      }
      const parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices);
      return cache[path2] = parent.ignored ? parent : this._testOne(path2, checkUnignored);
    }
    ignores(path2) {
      return this._test(path2, this._ignoreCache, false).ignored;
    }
    createFilter() {
      return (path2) => !this.ignores(path2);
    }
    filter(paths) {
      return makeArray(paths).filter(this.createFilter());
    }
    test(path2) {
      return this._test(path2, this._testCache, true);
    }
  }
  var factory = (options) => new Ignore(options);
  var isPathValid = (path2) => checkPath(path2 && checkPath.convert(path2), path2, RETURN_FALSE);
  factory.isPathValid = isPathValid;
  factory.default = factory;
  module.exports = factory;
  if (typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")) {
    const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
    checkPath.convert = makePosix;
    const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
    checkPath.isNotRelative = (path2) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path2) || isNotRelative(path2);
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1000;
  var m2 = s * 60;
  var h2 = m2 * 60;
  var d3 = h2 * 24;
  var w3 = d3 * 7;
  var y3 = d3 * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse5(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse5(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y3;
      case "weeks":
      case "week":
      case "w":
        return n * w3;
      case "days":
      case "day":
      case "d":
        return n * d3;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d3) {
      return Math.round(ms / d3) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms / h2) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms / m2) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d3) {
      return plural(ms, msAbs, d3, "day");
    }
    if (msAbs >= h2) {
      return plural(ms, msAbs, h2, "hour");
    }
    if (msAbs >= m2) {
      return plural(ms, msAbs, m2, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name2) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name2 + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup(env2) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env2).forEach((key) => {
      createDebug[key] = env2[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v2) => {
          enableOverride = v2;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name2) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name2, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name2, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load2;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m2;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c2 = "color: " + this.color;
    args.splice(1, 0, c2, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c2);
  }
  exports.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {}
  }
  function load2() {
    let r2;
    try {
      r2 = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
    } catch (error) {}
    if (!r2 && typeof process !== "undefined" && "env" in process) {
      r2 = process.env.DEBUG;
    }
    return r2;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {}
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v2) {
    try {
      return JSON.stringify(v2);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports, module) => {
  var os4 = __require("os");
  var tty2 = __require("tty");
  var hasFlag2 = require_has_flag();
  var { env: env2 } = process;
  var forceColor;
  if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") || hasFlag2("color=never")) {
    forceColor = 0;
  } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env2) {
    if (env2.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env2.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel2(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor2(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
      return 3;
    }
    if (hasFlag2("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }
    const min = forceColor || 0;
    if (env2.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os4.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env2) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => (sign in env2)) || env2.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env2) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env2.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env2) {
      const version = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env2.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env2.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env2) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor2(stream, stream && stream.isTTY);
    return translateLevel2(level);
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel2(supportsColor2(true, tty2.isatty(1))),
    stderr: translateLevel2(supportsColor2(true, tty2.isatty(2)))
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var tty2 = __require("tty");
  var util3 = __require("util");
  exports.init = init;
  exports.log = log2;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load2;
  exports.useColors = useColors;
  exports.destroy = util3.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor2 = require_supports_color();
    if (supportsColor2 && (supportsColor2.stderr || supportsColor2).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {}
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_3, k2) => {
      return k2.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty2.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name2, useColors: useColors2 } = this;
    if (useColors2) {
      const c2 = this.color;
      const colorCode = "\x1B[3" + (c2 < 8 ? c2 : "8;5;" + c2);
      const prefix = `  ${colorCode};1m${name2} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name2 + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log2(...args) {
    return process.stderr.write(util3.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load2() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v2) {
    this.inspectOpts.colors = this.useColors;
    return util3.inspect(v2, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v2) {
    this.inspectOpts.colors = this.useColors;
    return util3.inspect(v2, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src2 = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS((exports, module) => {
  module.exports = wrappy;
  function wrappy(fn, cb) {
    if (fn && cb)
      return wrappy(fn)(cb);
    if (typeof fn !== "function")
      throw new TypeError("need wrapper function");
    Object.keys(fn).forEach(function(k2) {
      wrapper[k2] = fn[k2];
    });
    return wrapper;
    function wrapper() {
      var args = new Array(arguments.length);
      for (var i = 0;i < args.length; i++) {
        args[i] = arguments[i];
      }
      var ret = fn.apply(this, args);
      var cb2 = args[args.length - 1];
      if (typeof ret === "function" && ret !== cb2) {
        Object.keys(cb2).forEach(function(k2) {
          ret[k2] = cb2[k2];
        });
      }
      return ret;
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS((exports, module) => {
  var wrappy = require_wrappy();
  module.exports = wrappy(once);
  module.exports.strict = wrappy(onceStrict);
  once.proto = once(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: function() {
        return once(this);
      },
      configurable: true
    });
    Object.defineProperty(Function.prototype, "onceStrict", {
      value: function() {
        return onceStrict(this);
      },
      configurable: true
    });
  });
  function once(fn) {
    var f3 = function() {
      if (f3.called)
        return f3.value;
      f3.called = true;
      return f3.value = fn.apply(this, arguments);
    };
    f3.called = false;
    return f3;
  }
  function onceStrict(fn) {
    var f3 = function() {
      if (f3.called)
        throw new Error(f3.onceError);
      f3.called = true;
      return f3.value = fn.apply(this, arguments);
    };
    var name2 = fn.name || "Function wrapped with `once`";
    f3.onceError = name2 + " shouldn't be called more than once";
    f3.called = false;
    return f3;
  }
});

// node_modules/end-of-stream/index.js
var require_end_of_stream = __commonJS((exports, module) => {
  var once = require_once();
  var noop3 = function() {};
  var qnt = global.Bare ? queueMicrotask : process.nextTick.bind(process);
  var isRequest = function(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  };
  var isChildProcess = function(stream) {
    return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
  };
  var eos = function(stream, opts, callback) {
    if (typeof opts === "function")
      return eos(stream, null, opts);
    if (!opts)
      opts = {};
    callback = once(callback || noop3);
    var ws = stream._writableState;
    var rs = stream._readableState;
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var cancelled = false;
    var onlegacyfinish = function() {
      if (!stream.writable)
        onfinish();
    };
    var onfinish = function() {
      writable = false;
      if (!readable)
        callback.call(stream);
    };
    var onend = function() {
      readable = false;
      if (!writable)
        callback.call(stream);
    };
    var onexit = function(exitCode) {
      callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
    };
    var onerror = function(err) {
      callback.call(stream, err);
    };
    var onclose = function() {
      qnt(onclosenexttick);
    };
    var onclosenexttick = function() {
      if (cancelled)
        return;
      if (readable && !(rs && (rs.ended && !rs.destroyed)))
        return callback.call(stream, new Error("premature close"));
      if (writable && !(ws && (ws.ended && !ws.destroyed)))
        return callback.call(stream, new Error("premature close"));
    };
    var onrequest = function() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req)
        onrequest();
      else
        stream.on("request", onrequest);
    } else if (writable && !ws) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    if (isChildProcess(stream))
      stream.on("exit", onexit);
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false)
      stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      cancelled = true;
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req)
        stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("exit", onexit);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  };
  module.exports = eos;
});

// node_modules/pump/index.js
var require_pump = __commonJS((exports, module) => {
  var once = require_once();
  var eos = require_end_of_stream();
  var fs13;
  try {
    fs13 = __require("fs");
  } catch (e2) {}
  var noop3 = function() {};
  var ancient = typeof process === "undefined" ? false : /^v?\.0/.test(process.version);
  var isFn = function(fn) {
    return typeof fn === "function";
  };
  var isFS = function(stream) {
    if (!ancient)
      return false;
    if (!fs13)
      return false;
    return (stream instanceof (fs13.ReadStream || noop3) || stream instanceof (fs13.WriteStream || noop3)) && isFn(stream.close);
  };
  var isRequest = function(stream) {
    return stream.setHeader && isFn(stream.abort);
  };
  var destroyer = function(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    eos(stream, { readable: reading, writable: writing }, function(err) {
      if (err)
        return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed)
        return;
      if (destroyed)
        return;
      destroyed = true;
      if (isFS(stream))
        return stream.close(noop3);
      if (isRequest(stream))
        return stream.abort();
      if (isFn(stream.destroy))
        return stream.destroy();
      callback(err || new Error("stream was destroyed"));
    };
  };
  var call = function(fn) {
    fn();
  };
  var pipe = function(from, to) {
    return from.pipe(to);
  };
  var pump = function() {
    var streams = Array.prototype.slice.call(arguments);
    var callback = isFn(streams[streams.length - 1] || noop3) && streams.pop() || noop3;
    if (Array.isArray(streams[0]))
      streams = streams[0];
    if (streams.length < 2)
      throw new Error("pump requires two streams per minimum");
    var error;
    var destroys = streams.map(function(stream, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error)
          error = err;
        if (err)
          destroys.forEach(call);
        if (reading)
          return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  };
  module.exports = pump;
});

// node_modules/extract-zip/node_modules/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS((exports, module) => {
  var { PassThrough: PassThroughStream } = __require("stream");
  module.exports = (options) => {
    options = { ...options };
    const { array } = options;
    let { encoding } = options;
    const isBuffer = encoding === "buffer";
    let objectMode = false;
    if (array) {
      objectMode = !(encoding || isBuffer);
    } else {
      encoding = encoding || "utf8";
    }
    if (isBuffer) {
      encoding = null;
    }
    const stream = new PassThroughStream({ objectMode });
    if (encoding) {
      stream.setEncoding(encoding);
    }
    let length = 0;
    const chunks = [];
    stream.on("data", (chunk) => {
      chunks.push(chunk);
      if (objectMode) {
        length = chunks.length;
      } else {
        length += chunk.length;
      }
    });
    stream.getBufferedValue = () => {
      if (array) {
        return chunks;
      }
      return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
    };
    stream.getBufferedLength = () => length;
    return stream;
  };
});

// node_modules/extract-zip/node_modules/get-stream/index.js
var require_get_stream = __commonJS((exports, module) => {
  var { constants: BufferConstants } = __require("buffer");
  var pump = require_pump();
  var bufferStream = require_buffer_stream();

  class MaxBufferError extends Error {
    constructor() {
      super("maxBuffer exceeded");
      this.name = "MaxBufferError";
    }
  }
  async function getStream(inputStream, options) {
    if (!inputStream) {
      return Promise.reject(new Error("Expected a stream"));
    }
    options = {
      maxBuffer: Infinity,
      ...options
    };
    const { maxBuffer } = options;
    let stream;
    await new Promise((resolve5, reject) => {
      const rejectPromise = (error) => {
        if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
          error.bufferedData = stream.getBufferedValue();
        }
        reject(error);
      };
      stream = pump(inputStream, bufferStream(options), (error) => {
        if (error) {
          rejectPromise(error);
          return;
        }
        resolve5();
      });
      stream.on("data", () => {
        if (stream.getBufferedLength() > maxBuffer) {
          rejectPromise(new MaxBufferError);
        }
      });
    });
    return stream.getBufferedValue();
  }
  module.exports = getStream;
  module.exports.default = getStream;
  module.exports.buffer = (stream, options) => getStream(stream, { ...options, encoding: "buffer" });
  module.exports.array = (stream, options) => getStream(stream, { ...options, array: true });
  module.exports.MaxBufferError = MaxBufferError;
});

// node_modules/pend/index.js
var require_pend = __commonJS((exports, module) => {
  module.exports = Pend;
  function Pend() {
    this.pending = 0;
    this.max = Infinity;
    this.listeners = [];
    this.waiting = [];
    this.error = null;
  }
  Pend.prototype.go = function(fn) {
    if (this.pending < this.max) {
      pendGo(this, fn);
    } else {
      this.waiting.push(fn);
    }
  };
  Pend.prototype.wait = function(cb) {
    if (this.pending === 0) {
      cb(this.error);
    } else {
      this.listeners.push(cb);
    }
  };
  Pend.prototype.hold = function() {
    return pendHold(this);
  };
  function pendHold(self2) {
    self2.pending += 1;
    var called = false;
    return onCb;
    function onCb(err) {
      if (called)
        throw new Error("callback called twice");
      called = true;
      self2.error = self2.error || err;
      self2.pending -= 1;
      if (self2.waiting.length > 0 && self2.pending < self2.max) {
        pendGo(self2, self2.waiting.shift());
      } else if (self2.pending === 0) {
        var listeners = self2.listeners;
        self2.listeners = [];
        listeners.forEach(cbListener);
      }
    }
    function cbListener(listener) {
      listener(self2.error);
    }
  }
  function pendGo(self2, fn) {
    fn(pendHold(self2));
  }
});

// node_modules/fd-slicer/index.js
var require_fd_slicer = __commonJS((exports) => {
  var fs13 = __require("fs");
  var util3 = __require("util");
  var stream = __require("stream");
  var Readable = stream.Readable;
  var Writable = stream.Writable;
  var PassThrough = stream.PassThrough;
  var Pend = require_pend();
  var EventEmitter5 = __require("events").EventEmitter;
  exports.createFromBuffer = createFromBuffer;
  exports.createFromFd = createFromFd;
  exports.BufferSlicer = BufferSlicer;
  exports.FdSlicer = FdSlicer;
  util3.inherits(FdSlicer, EventEmitter5);
  function FdSlicer(fd, options) {
    options = options || {};
    EventEmitter5.call(this);
    this.fd = fd;
    this.pend = new Pend;
    this.pend.max = 1;
    this.refCount = 0;
    this.autoClose = !!options.autoClose;
  }
  FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
    var self2 = this;
    self2.pend.go(function(cb) {
      fs13.read(self2.fd, buffer, offset, length, position, function(err, bytesRead, buffer2) {
        cb();
        callback(err, bytesRead, buffer2);
      });
    });
  };
  FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
    var self2 = this;
    self2.pend.go(function(cb) {
      fs13.write(self2.fd, buffer, offset, length, position, function(err, written, buffer2) {
        cb();
        callback(err, written, buffer2);
      });
    });
  };
  FdSlicer.prototype.createReadStream = function(options) {
    return new ReadStream2(this, options);
  };
  FdSlicer.prototype.createWriteStream = function(options) {
    return new WriteStream2(this, options);
  };
  FdSlicer.prototype.ref = function() {
    this.refCount += 1;
  };
  FdSlicer.prototype.unref = function() {
    var self2 = this;
    self2.refCount -= 1;
    if (self2.refCount > 0)
      return;
    if (self2.refCount < 0)
      throw new Error("invalid unref");
    if (self2.autoClose) {
      fs13.close(self2.fd, onCloseDone);
    }
    function onCloseDone(err) {
      if (err) {
        self2.emit("error", err);
      } else {
        self2.emit("close");
      }
    }
  };
  util3.inherits(ReadStream2, Readable);
  function ReadStream2(context, options) {
    options = options || {};
    Readable.call(this, options);
    this.context = context;
    this.context.ref();
    this.start = options.start || 0;
    this.endOffset = options.end;
    this.pos = this.start;
    this.destroyed = false;
  }
  ReadStream2.prototype._read = function(n) {
    var self2 = this;
    if (self2.destroyed)
      return;
    var toRead = Math.min(self2._readableState.highWaterMark, n);
    if (self2.endOffset != null) {
      toRead = Math.min(toRead, self2.endOffset - self2.pos);
    }
    if (toRead <= 0) {
      self2.destroyed = true;
      self2.push(null);
      self2.context.unref();
      return;
    }
    self2.context.pend.go(function(cb) {
      if (self2.destroyed)
        return cb();
      var buffer = new Buffer(toRead);
      fs13.read(self2.context.fd, buffer, 0, toRead, self2.pos, function(err, bytesRead) {
        if (err) {
          self2.destroy(err);
        } else if (bytesRead === 0) {
          self2.destroyed = true;
          self2.push(null);
          self2.context.unref();
        } else {
          self2.pos += bytesRead;
          self2.push(buffer.slice(0, bytesRead));
        }
        cb();
      });
    });
  };
  ReadStream2.prototype.destroy = function(err) {
    if (this.destroyed)
      return;
    err = err || new Error("stream destroyed");
    this.destroyed = true;
    this.emit("error", err);
    this.context.unref();
  };
  util3.inherits(WriteStream2, Writable);
  function WriteStream2(context, options) {
    options = options || {};
    Writable.call(this, options);
    this.context = context;
    this.context.ref();
    this.start = options.start || 0;
    this.endOffset = options.end == null ? Infinity : +options.end;
    this.bytesWritten = 0;
    this.pos = this.start;
    this.destroyed = false;
    this.on("finish", this.destroy.bind(this));
  }
  WriteStream2.prototype._write = function(buffer, encoding, callback) {
    var self2 = this;
    if (self2.destroyed)
      return;
    if (self2.pos + buffer.length > self2.endOffset) {
      var err = new Error("maximum file length exceeded");
      err.code = "ETOOBIG";
      self2.destroy();
      callback(err);
      return;
    }
    self2.context.pend.go(function(cb) {
      if (self2.destroyed)
        return cb();
      fs13.write(self2.context.fd, buffer, 0, buffer.length, self2.pos, function(err2, bytes) {
        if (err2) {
          self2.destroy();
          cb();
          callback(err2);
        } else {
          self2.bytesWritten += bytes;
          self2.pos += bytes;
          self2.emit("progress");
          cb();
          callback();
        }
      });
    });
  };
  WriteStream2.prototype.destroy = function() {
    if (this.destroyed)
      return;
    this.destroyed = true;
    this.context.unref();
  };
  util3.inherits(BufferSlicer, EventEmitter5);
  function BufferSlicer(buffer, options) {
    EventEmitter5.call(this);
    options = options || {};
    this.refCount = 0;
    this.buffer = buffer;
    this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;
  }
  BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
    var end = position + length;
    var delta = end - this.buffer.length;
    var written = delta > 0 ? delta : length;
    this.buffer.copy(buffer, offset, position, end);
    setImmediate(function() {
      callback(null, written);
    });
  };
  BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
    buffer.copy(this.buffer, position, offset, offset + length);
    setImmediate(function() {
      callback(null, length, buffer);
    });
  };
  BufferSlicer.prototype.createReadStream = function(options) {
    options = options || {};
    var readStream = new PassThrough(options);
    readStream.destroyed = false;
    readStream.start = options.start || 0;
    readStream.endOffset = options.end;
    readStream.pos = readStream.endOffset || this.buffer.length;
    var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
    var offset = 0;
    while (true) {
      var nextOffset = offset + this.maxChunkSize;
      if (nextOffset >= entireSlice.length) {
        if (offset < entireSlice.length) {
          readStream.write(entireSlice.slice(offset, entireSlice.length));
        }
        break;
      }
      readStream.write(entireSlice.slice(offset, nextOffset));
      offset = nextOffset;
    }
    readStream.end();
    readStream.destroy = function() {
      readStream.destroyed = true;
    };
    return readStream;
  };
  BufferSlicer.prototype.createWriteStream = function(options) {
    var bufferSlicer = this;
    options = options || {};
    var writeStream = new Writable(options);
    writeStream.start = options.start || 0;
    writeStream.endOffset = options.end == null ? this.buffer.length : +options.end;
    writeStream.bytesWritten = 0;
    writeStream.pos = writeStream.start;
    writeStream.destroyed = false;
    writeStream._write = function(buffer, encoding, callback) {
      if (writeStream.destroyed)
        return;
      var end = writeStream.pos + buffer.length;
      if (end > writeStream.endOffset) {
        var err = new Error("maximum file length exceeded");
        err.code = "ETOOBIG";
        writeStream.destroyed = true;
        callback(err);
        return;
      }
      buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);
      writeStream.bytesWritten += buffer.length;
      writeStream.pos = end;
      writeStream.emit("progress");
      callback();
    };
    writeStream.destroy = function() {
      writeStream.destroyed = true;
    };
    return writeStream;
  };
  BufferSlicer.prototype.ref = function() {
    this.refCount += 1;
  };
  BufferSlicer.prototype.unref = function() {
    this.refCount -= 1;
    if (this.refCount < 0) {
      throw new Error("invalid unref");
    }
  };
  function createFromBuffer(buffer, options) {
    return new BufferSlicer(buffer, options);
  }
  function createFromFd(fd, options) {
    return new FdSlicer(fd, options);
  }
});

// node_modules/buffer-crc32/index.js
var require_buffer_crc32 = __commonJS((exports, module) => {
  var Buffer4 = __require("buffer").Buffer;
  var CRC_TABLE = [
    0,
    1996959894,
    3993919788,
    2567524794,
    124634137,
    1886057615,
    3915621685,
    2657392035,
    249268274,
    2044508324,
    3772115230,
    2547177864,
    162941995,
    2125561021,
    3887607047,
    2428444049,
    498536548,
    1789927666,
    4089016648,
    2227061214,
    450548861,
    1843258603,
    4107580753,
    2211677639,
    325883990,
    1684777152,
    4251122042,
    2321926636,
    335633487,
    1661365465,
    4195302755,
    2366115317,
    997073096,
    1281953886,
    3579855332,
    2724688242,
    1006888145,
    1258607687,
    3524101629,
    2768942443,
    901097722,
    1119000684,
    3686517206,
    2898065728,
    853044451,
    1172266101,
    3705015759,
    2882616665,
    651767980,
    1373503546,
    3369554304,
    3218104598,
    565507253,
    1454621731,
    3485111705,
    3099436303,
    671266974,
    1594198024,
    3322730930,
    2970347812,
    795835527,
    1483230225,
    3244367275,
    3060149565,
    1994146192,
    31158534,
    2563907772,
    4023717930,
    1907459465,
    112637215,
    2680153253,
    3904427059,
    2013776290,
    251722036,
    2517215374,
    3775830040,
    2137656763,
    141376813,
    2439277719,
    3865271297,
    1802195444,
    476864866,
    2238001368,
    4066508878,
    1812370925,
    453092731,
    2181625025,
    4111451223,
    1706088902,
    314042704,
    2344532202,
    4240017532,
    1658658271,
    366619977,
    2362670323,
    4224994405,
    1303535960,
    984961486,
    2747007092,
    3569037538,
    1256170817,
    1037604311,
    2765210733,
    3554079995,
    1131014506,
    879679996,
    2909243462,
    3663771856,
    1141124467,
    855842277,
    2852801631,
    3708648649,
    1342533948,
    654459306,
    3188396048,
    3373015174,
    1466479909,
    544179635,
    3110523913,
    3462522015,
    1591671054,
    702138776,
    2966460450,
    3352799412,
    1504918807,
    783551873,
    3082640443,
    3233442989,
    3988292384,
    2596254646,
    62317068,
    1957810842,
    3939845945,
    2647816111,
    81470997,
    1943803523,
    3814918930,
    2489596804,
    225274430,
    2053790376,
    3826175755,
    2466906013,
    167816743,
    2097651377,
    4027552580,
    2265490386,
    503444072,
    1762050814,
    4150417245,
    2154129355,
    426522225,
    1852507879,
    4275313526,
    2312317920,
    282753626,
    1742555852,
    4189708143,
    2394877945,
    397917763,
    1622183637,
    3604390888,
    2714866558,
    953729732,
    1340076626,
    3518719985,
    2797360999,
    1068828381,
    1219638859,
    3624741850,
    2936675148,
    906185462,
    1090812512,
    3747672003,
    2825379669,
    829329135,
    1181335161,
    3412177804,
    3160834842,
    628085408,
    1382605366,
    3423369109,
    3138078467,
    570562233,
    1426400815,
    3317316542,
    2998733608,
    733239954,
    1555261956,
    3268935591,
    3050360625,
    752459403,
    1541320221,
    2607071920,
    3965973030,
    1969922972,
    40735498,
    2617837225,
    3943577151,
    1913087877,
    83908371,
    2512341634,
    3803740692,
    2075208622,
    213261112,
    2463272603,
    3855990285,
    2094854071,
    198958881,
    2262029012,
    4057260610,
    1759359992,
    534414190,
    2176718541,
    4139329115,
    1873836001,
    414664567,
    2282248934,
    4279200368,
    1711684554,
    285281116,
    2405801727,
    4167216745,
    1634467795,
    376229701,
    2685067896,
    3608007406,
    1308918612,
    956543938,
    2808555105,
    3495958263,
    1231636301,
    1047427035,
    2932959818,
    3654703836,
    1088359270,
    936918000,
    2847714899,
    3736837829,
    1202900863,
    817233897,
    3183342108,
    3401237130,
    1404277552,
    615818150,
    3134207493,
    3453421203,
    1423857449,
    601450431,
    3009837614,
    3294710456,
    1567103746,
    711928724,
    3020668471,
    3272380065,
    1510334235,
    755167117
  ];
  if (typeof Int32Array !== "undefined") {
    CRC_TABLE = new Int32Array(CRC_TABLE);
  }
  function ensureBuffer(input) {
    if (Buffer4.isBuffer(input)) {
      return input;
    }
    var hasNewBufferAPI = typeof Buffer4.alloc === "function" && typeof Buffer4.from === "function";
    if (typeof input === "number") {
      return hasNewBufferAPI ? Buffer4.alloc(input) : new Buffer4(input);
    } else if (typeof input === "string") {
      return hasNewBufferAPI ? Buffer4.from(input) : new Buffer4(input);
    } else {
      throw new Error("input must be buffer, number, or string, received " + typeof input);
    }
  }
  function bufferizeInt(num) {
    var tmp = ensureBuffer(4);
    tmp.writeInt32BE(num, 0);
    return tmp;
  }
  function _crc32(buf, previous) {
    buf = ensureBuffer(buf);
    if (Buffer4.isBuffer(previous)) {
      previous = previous.readUInt32BE(0);
    }
    var crc = ~~previous ^ -1;
    for (var n = 0;n < buf.length; n++) {
      crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
    }
    return crc ^ -1;
  }
  function crc32() {
    return bufferizeInt(_crc32.apply(null, arguments));
  }
  crc32.signed = function() {
    return _crc32.apply(null, arguments);
  };
  crc32.unsigned = function() {
    return _crc32.apply(null, arguments) >>> 0;
  };
  module.exports = crc32;
});

// node_modules/yauzl/index.js
var require_yauzl = __commonJS((exports) => {
  var fs13 = __require("fs");
  var zlib = __require("zlib");
  var fd_slicer = require_fd_slicer();
  var crc32 = require_buffer_crc32();
  var util3 = __require("util");
  var EventEmitter5 = __require("events").EventEmitter;
  var Transform = __require("stream").Transform;
  var PassThrough = __require("stream").PassThrough;
  var Writable = __require("stream").Writable;
  exports.open = open;
  exports.fromFd = fromFd;
  exports.fromBuffer = fromBuffer;
  exports.fromRandomAccessReader = fromRandomAccessReader;
  exports.dosDateTimeToDate = dosDateTimeToDate;
  exports.validateFileName = validateFileName;
  exports.ZipFile = ZipFile;
  exports.Entry = Entry;
  exports.RandomAccessReader = RandomAccessReader;
  function open(path9, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    if (options == null)
      options = {};
    if (options.autoClose == null)
      options.autoClose = true;
    if (options.lazyEntries == null)
      options.lazyEntries = false;
    if (options.decodeStrings == null)
      options.decodeStrings = true;
    if (options.validateEntrySizes == null)
      options.validateEntrySizes = true;
    if (options.strictFileNames == null)
      options.strictFileNames = false;
    if (callback == null)
      callback = defaultCallback;
    fs13.open(path9, "r", function(err, fd) {
      if (err)
        return callback(err);
      fromFd(fd, options, function(err2, zipfile) {
        if (err2)
          fs13.close(fd, defaultCallback);
        callback(err2, zipfile);
      });
    });
  }
  function fromFd(fd, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    if (options == null)
      options = {};
    if (options.autoClose == null)
      options.autoClose = false;
    if (options.lazyEntries == null)
      options.lazyEntries = false;
    if (options.decodeStrings == null)
      options.decodeStrings = true;
    if (options.validateEntrySizes == null)
      options.validateEntrySizes = true;
    if (options.strictFileNames == null)
      options.strictFileNames = false;
    if (callback == null)
      callback = defaultCallback;
    fs13.fstat(fd, function(err, stats) {
      if (err)
        return callback(err);
      var reader = fd_slicer.createFromFd(fd, { autoClose: true });
      fromRandomAccessReader(reader, stats.size, options, callback);
    });
  }
  function fromBuffer(buffer, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    if (options == null)
      options = {};
    options.autoClose = false;
    if (options.lazyEntries == null)
      options.lazyEntries = false;
    if (options.decodeStrings == null)
      options.decodeStrings = true;
    if (options.validateEntrySizes == null)
      options.validateEntrySizes = true;
    if (options.strictFileNames == null)
      options.strictFileNames = false;
    var reader = fd_slicer.createFromBuffer(buffer, { maxChunkSize: 65536 });
    fromRandomAccessReader(reader, buffer.length, options, callback);
  }
  function fromRandomAccessReader(reader, totalSize, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    if (options == null)
      options = {};
    if (options.autoClose == null)
      options.autoClose = true;
    if (options.lazyEntries == null)
      options.lazyEntries = false;
    if (options.decodeStrings == null)
      options.decodeStrings = true;
    var decodeStrings = !!options.decodeStrings;
    if (options.validateEntrySizes == null)
      options.validateEntrySizes = true;
    if (options.strictFileNames == null)
      options.strictFileNames = false;
    if (callback == null)
      callback = defaultCallback;
    if (typeof totalSize !== "number")
      throw new Error("expected totalSize parameter to be a number");
    if (totalSize > Number.MAX_SAFE_INTEGER) {
      throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
    }
    reader.ref();
    var eocdrWithoutCommentSize = 22;
    var maxCommentSize = 65535;
    var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);
    var buffer = newBuffer(bufferSize);
    var bufferReadStart = totalSize - buffer.length;
    readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
      if (err)
        return callback(err);
      for (var i = bufferSize - eocdrWithoutCommentSize;i >= 0; i -= 1) {
        if (buffer.readUInt32LE(i) !== 101010256)
          continue;
        var eocdrBuffer = buffer.slice(i);
        var diskNumber = eocdrBuffer.readUInt16LE(4);
        if (diskNumber !== 0) {
          return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
        }
        var entryCount = eocdrBuffer.readUInt16LE(10);
        var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
        var commentLength = eocdrBuffer.readUInt16LE(20);
        var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
        if (commentLength !== expectedCommentLength) {
          return callback(new Error("invalid comment length. expected: " + expectedCommentLength + ". found: " + commentLength));
        }
        var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false) : eocdrBuffer.slice(22);
        if (!(entryCount === 65535 || centralDirectoryOffset === 4294967295)) {
          return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
        }
        var zip64EocdlBuffer = newBuffer(20);
        var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;
        readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err2) {
          if (err2)
            return callback(err2);
          if (zip64EocdlBuffer.readUInt32LE(0) !== 117853008) {
            return callback(new Error("invalid zip64 end of central directory locator signature"));
          }
          var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
          var zip64EocdrBuffer = newBuffer(56);
          readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err3) {
            if (err3)
              return callback(err3);
            if (zip64EocdrBuffer.readUInt32LE(0) !== 101075792) {
              return callback(new Error("invalid zip64 end of central directory record signature"));
            }
            entryCount = readUInt64LE(zip64EocdrBuffer, 32);
            centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
            return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
          });
        });
        return;
      }
      callback(new Error("end of central directory record signature not found"));
    });
  }
  util3.inherits(ZipFile, EventEmitter5);
  function ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
    var self2 = this;
    EventEmitter5.call(self2);
    self2.reader = reader;
    self2.reader.on("error", function(err) {
      emitError(self2, err);
    });
    self2.reader.once("close", function() {
      self2.emit("close");
    });
    self2.readEntryCursor = centralDirectoryOffset;
    self2.fileSize = fileSize;
    self2.entryCount = entryCount;
    self2.comment = comment;
    self2.entriesRead = 0;
    self2.autoClose = !!autoClose;
    self2.lazyEntries = !!lazyEntries;
    self2.decodeStrings = !!decodeStrings;
    self2.validateEntrySizes = !!validateEntrySizes;
    self2.strictFileNames = !!strictFileNames;
    self2.isOpen = true;
    self2.emittedError = false;
    if (!self2.lazyEntries)
      self2._readEntry();
  }
  ZipFile.prototype.close = function() {
    if (!this.isOpen)
      return;
    this.isOpen = false;
    this.reader.unref();
  };
  function emitErrorAndAutoClose(self2, err) {
    if (self2.autoClose)
      self2.close();
    emitError(self2, err);
  }
  function emitError(self2, err) {
    if (self2.emittedError)
      return;
    self2.emittedError = true;
    self2.emit("error", err);
  }
  ZipFile.prototype.readEntry = function() {
    if (!this.lazyEntries)
      throw new Error("readEntry() called without lazyEntries:true");
    this._readEntry();
  };
  ZipFile.prototype._readEntry = function() {
    var self2 = this;
    if (self2.entryCount === self2.entriesRead) {
      setImmediate(function() {
        if (self2.autoClose)
          self2.close();
        if (self2.emittedError)
          return;
        self2.emit("end");
      });
      return;
    }
    if (self2.emittedError)
      return;
    var buffer = newBuffer(46);
    readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err) {
      if (err)
        return emitErrorAndAutoClose(self2, err);
      if (self2.emittedError)
        return;
      var entry = new Entry;
      var signature = buffer.readUInt32LE(0);
      if (signature !== 33639248)
        return emitErrorAndAutoClose(self2, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
      entry.versionMadeBy = buffer.readUInt16LE(4);
      entry.versionNeededToExtract = buffer.readUInt16LE(6);
      entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
      entry.compressionMethod = buffer.readUInt16LE(10);
      entry.lastModFileTime = buffer.readUInt16LE(12);
      entry.lastModFileDate = buffer.readUInt16LE(14);
      entry.crc32 = buffer.readUInt32LE(16);
      entry.compressedSize = buffer.readUInt32LE(20);
      entry.uncompressedSize = buffer.readUInt32LE(24);
      entry.fileNameLength = buffer.readUInt16LE(28);
      entry.extraFieldLength = buffer.readUInt16LE(30);
      entry.fileCommentLength = buffer.readUInt16LE(32);
      entry.internalFileAttributes = buffer.readUInt16LE(36);
      entry.externalFileAttributes = buffer.readUInt32LE(38);
      entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);
      if (entry.generalPurposeBitFlag & 64)
        return emitErrorAndAutoClose(self2, new Error("strong encryption is not supported"));
      self2.readEntryCursor += 46;
      buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err2) {
        if (err2)
          return emitErrorAndAutoClose(self2, err2);
        if (self2.emittedError)
          return;
        var isUtf8 = (entry.generalPurposeBitFlag & 2048) !== 0;
        entry.fileName = self2.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8) : buffer.slice(0, entry.fileNameLength);
        var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
        var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);
        entry.extraFields = [];
        var i = 0;
        while (i < extraFieldBuffer.length - 3) {
          var headerId = extraFieldBuffer.readUInt16LE(i + 0);
          var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
          var dataStart = i + 4;
          var dataEnd = dataStart + dataSize;
          if (dataEnd > extraFieldBuffer.length)
            return emitErrorAndAutoClose(self2, new Error("extra field length exceeds extra field buffer size"));
          var dataBuffer = newBuffer(dataSize);
          extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
          entry.extraFields.push({
            id: headerId,
            data: dataBuffer
          });
          i = dataEnd;
        }
        entry.fileComment = self2.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8) : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);
        entry.comment = entry.fileComment;
        self2.readEntryCursor += buffer.length;
        self2.entriesRead += 1;
        if (entry.uncompressedSize === 4294967295 || entry.compressedSize === 4294967295 || entry.relativeOffsetOfLocalHeader === 4294967295) {
          var zip64EiefBuffer = null;
          for (var i = 0;i < entry.extraFields.length; i++) {
            var extraField = entry.extraFields[i];
            if (extraField.id === 1) {
              zip64EiefBuffer = extraField.data;
              break;
            }
          }
          if (zip64EiefBuffer == null) {
            return emitErrorAndAutoClose(self2, new Error("expected zip64 extended information extra field"));
          }
          var index = 0;
          if (entry.uncompressedSize === 4294967295) {
            if (index + 8 > zip64EiefBuffer.length) {
              return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include uncompressed size"));
            }
            entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);
            index += 8;
          }
          if (entry.compressedSize === 4294967295) {
            if (index + 8 > zip64EiefBuffer.length) {
              return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include compressed size"));
            }
            entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);
            index += 8;
          }
          if (entry.relativeOffsetOfLocalHeader === 4294967295) {
            if (index + 8 > zip64EiefBuffer.length) {
              return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include relative header offset"));
            }
            entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);
            index += 8;
          }
        }
        if (self2.decodeStrings) {
          for (var i = 0;i < entry.extraFields.length; i++) {
            var extraField = entry.extraFields[i];
            if (extraField.id === 28789) {
              if (extraField.data.length < 6) {
                continue;
              }
              if (extraField.data.readUInt8(0) !== 1) {
                continue;
              }
              var oldNameCrc32 = extraField.data.readUInt32LE(1);
              if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {
                continue;
              }
              entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);
              break;
            }
          }
        }
        if (self2.validateEntrySizes && entry.compressionMethod === 0) {
          var expectedCompressedSize = entry.uncompressedSize;
          if (entry.isEncrypted()) {
            expectedCompressedSize += 12;
          }
          if (entry.compressedSize !== expectedCompressedSize) {
            var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
            return emitErrorAndAutoClose(self2, new Error(msg));
          }
        }
        if (self2.decodeStrings) {
          if (!self2.strictFileNames) {
            entry.fileName = entry.fileName.replace(/\\/g, "/");
          }
          var errorMessage = validateFileName(entry.fileName, self2.validateFileNameOptions);
          if (errorMessage != null)
            return emitErrorAndAutoClose(self2, new Error(errorMessage));
        }
        self2.emit("entry", entry);
        if (!self2.lazyEntries)
          self2._readEntry();
      });
    });
  };
  ZipFile.prototype.openReadStream = function(entry, options, callback) {
    var self2 = this;
    var relativeStart = 0;
    var relativeEnd = entry.compressedSize;
    if (callback == null) {
      callback = options;
      options = {};
    } else {
      if (options.decrypt != null) {
        if (!entry.isEncrypted()) {
          throw new Error("options.decrypt can only be specified for encrypted entries");
        }
        if (options.decrypt !== false)
          throw new Error("invalid options.decrypt value: " + options.decrypt);
        if (entry.isCompressed()) {
          if (options.decompress !== false)
            throw new Error("entry is encrypted and compressed, and options.decompress !== false");
        }
      }
      if (options.decompress != null) {
        if (!entry.isCompressed()) {
          throw new Error("options.decompress can only be specified for compressed entries");
        }
        if (!(options.decompress === false || options.decompress === true)) {
          throw new Error("invalid options.decompress value: " + options.decompress);
        }
      }
      if (options.start != null || options.end != null) {
        if (entry.isCompressed() && options.decompress !== false) {
          throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
        }
        if (entry.isEncrypted() && options.decrypt !== false) {
          throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
        }
      }
      if (options.start != null) {
        relativeStart = options.start;
        if (relativeStart < 0)
          throw new Error("options.start < 0");
        if (relativeStart > entry.compressedSize)
          throw new Error("options.start > entry.compressedSize");
      }
      if (options.end != null) {
        relativeEnd = options.end;
        if (relativeEnd < 0)
          throw new Error("options.end < 0");
        if (relativeEnd > entry.compressedSize)
          throw new Error("options.end > entry.compressedSize");
        if (relativeEnd < relativeStart)
          throw new Error("options.end < options.start");
      }
    }
    if (!self2.isOpen)
      return callback(new Error("closed"));
    if (entry.isEncrypted()) {
      if (options.decrypt !== false)
        return callback(new Error("entry is encrypted, and options.decrypt !== false"));
    }
    self2.reader.ref();
    var buffer = newBuffer(30);
    readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
      try {
        if (err)
          return callback(err);
        var signature = buffer.readUInt32LE(0);
        if (signature !== 67324752) {
          return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
        }
        var fileNameLength = buffer.readUInt16LE(26);
        var extraFieldLength = buffer.readUInt16LE(28);
        var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;
        var decompress;
        if (entry.compressionMethod === 0) {
          decompress = false;
        } else if (entry.compressionMethod === 8) {
          decompress = options.decompress != null ? options.decompress : true;
        } else {
          return callback(new Error("unsupported compression method: " + entry.compressionMethod));
        }
        var fileDataStart = localFileHeaderEnd;
        var fileDataEnd = fileDataStart + entry.compressedSize;
        if (entry.compressedSize !== 0) {
          if (fileDataEnd > self2.fileSize) {
            return callback(new Error("file data overflows file bounds: " + fileDataStart + " + " + entry.compressedSize + " > " + self2.fileSize));
          }
        }
        var readStream = self2.reader.createReadStream({
          start: fileDataStart + relativeStart,
          end: fileDataStart + relativeEnd
        });
        var endpointStream = readStream;
        if (decompress) {
          var destroyed = false;
          var inflateFilter = zlib.createInflateRaw();
          readStream.on("error", function(err2) {
            setImmediate(function() {
              if (!destroyed)
                inflateFilter.emit("error", err2);
            });
          });
          readStream.pipe(inflateFilter);
          if (self2.validateEntrySizes) {
            endpointStream = new AssertByteCountStream(entry.uncompressedSize);
            inflateFilter.on("error", function(err2) {
              setImmediate(function() {
                if (!destroyed)
                  endpointStream.emit("error", err2);
              });
            });
            inflateFilter.pipe(endpointStream);
          } else {
            endpointStream = inflateFilter;
          }
          endpointStream.destroy = function() {
            destroyed = true;
            if (inflateFilter !== endpointStream)
              inflateFilter.unpipe(endpointStream);
            readStream.unpipe(inflateFilter);
            readStream.destroy();
          };
        }
        callback(null, endpointStream);
      } finally {
        self2.reader.unref();
      }
    });
  };
  function Entry() {}
  Entry.prototype.getLastModDate = function() {
    return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
  };
  Entry.prototype.isEncrypted = function() {
    return (this.generalPurposeBitFlag & 1) !== 0;
  };
  Entry.prototype.isCompressed = function() {
    return this.compressionMethod === 8;
  };
  function dosDateTimeToDate(date, time) {
    var day = date & 31;
    var month = (date >> 5 & 15) - 1;
    var year = (date >> 9 & 127) + 1980;
    var millisecond = 0;
    var second = (time & 31) * 2;
    var minute = time >> 5 & 63;
    var hour = time >> 11 & 31;
    return new Date(year, month, day, hour, minute, second, millisecond);
  }
  function validateFileName(fileName) {
    if (fileName.indexOf("\\") !== -1) {
      return "invalid characters in fileName: " + fileName;
    }
    if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
      return "absolute path: " + fileName;
    }
    if (fileName.split("/").indexOf("..") !== -1) {
      return "invalid relative path: " + fileName;
    }
    return null;
  }
  function readAndAssertNoEof(reader, buffer, offset, length, position, callback) {
    if (length === 0) {
      return setImmediate(function() {
        callback(null, newBuffer(0));
      });
    }
    reader.read(buffer, offset, length, position, function(err, bytesRead) {
      if (err)
        return callback(err);
      if (bytesRead < length) {
        return callback(new Error("unexpected EOF"));
      }
      callback();
    });
  }
  util3.inherits(AssertByteCountStream, Transform);
  function AssertByteCountStream(byteCount) {
    Transform.call(this);
    this.actualByteCount = 0;
    this.expectedByteCount = byteCount;
  }
  AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
    this.actualByteCount += chunk.length;
    if (this.actualByteCount > this.expectedByteCount) {
      var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
      return cb(new Error(msg));
    }
    cb(null, chunk);
  };
  AssertByteCountStream.prototype._flush = function(cb) {
    if (this.actualByteCount < this.expectedByteCount) {
      var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
      return cb(new Error(msg));
    }
    cb();
  };
  util3.inherits(RandomAccessReader, EventEmitter5);
  function RandomAccessReader() {
    EventEmitter5.call(this);
    this.refCount = 0;
  }
  RandomAccessReader.prototype.ref = function() {
    this.refCount += 1;
  };
  RandomAccessReader.prototype.unref = function() {
    var self2 = this;
    self2.refCount -= 1;
    if (self2.refCount > 0)
      return;
    if (self2.refCount < 0)
      throw new Error("invalid unref");
    self2.close(onCloseDone);
    function onCloseDone(err) {
      if (err)
        return self2.emit("error", err);
      self2.emit("close");
    }
  };
  RandomAccessReader.prototype.createReadStream = function(options) {
    var start = options.start;
    var end = options.end;
    if (start === end) {
      var emptyStream = new PassThrough;
      setImmediate(function() {
        emptyStream.end();
      });
      return emptyStream;
    }
    var stream = this._readStreamForRange(start, end);
    var destroyed = false;
    var refUnrefFilter = new RefUnrefFilter(this);
    stream.on("error", function(err) {
      setImmediate(function() {
        if (!destroyed)
          refUnrefFilter.emit("error", err);
      });
    });
    refUnrefFilter.destroy = function() {
      stream.unpipe(refUnrefFilter);
      refUnrefFilter.unref();
      stream.destroy();
    };
    var byteCounter = new AssertByteCountStream(end - start);
    refUnrefFilter.on("error", function(err) {
      setImmediate(function() {
        if (!destroyed)
          byteCounter.emit("error", err);
      });
    });
    byteCounter.destroy = function() {
      destroyed = true;
      refUnrefFilter.unpipe(byteCounter);
      refUnrefFilter.destroy();
    };
    return stream.pipe(refUnrefFilter).pipe(byteCounter);
  };
  RandomAccessReader.prototype._readStreamForRange = function(start, end) {
    throw new Error("not implemented");
  };
  RandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {
    var readStream = this.createReadStream({ start: position, end: position + length });
    var writeStream = new Writable;
    var written = 0;
    writeStream._write = function(chunk, encoding, cb) {
      chunk.copy(buffer, offset + written, 0, chunk.length);
      written += chunk.length;
      cb();
    };
    writeStream.on("finish", callback);
    readStream.on("error", function(error) {
      callback(error);
    });
    readStream.pipe(writeStream);
  };
  RandomAccessReader.prototype.close = function(callback) {
    setImmediate(callback);
  };
  util3.inherits(RefUnrefFilter, PassThrough);
  function RefUnrefFilter(context) {
    PassThrough.call(this);
    this.context = context;
    this.context.ref();
    this.unreffedYet = false;
  }
  RefUnrefFilter.prototype._flush = function(cb) {
    this.unref();
    cb();
  };
  RefUnrefFilter.prototype.unref = function(cb) {
    if (this.unreffedYet)
      return;
    this.unreffedYet = true;
    this.context.unref();
  };
  var cp437 = "\x00 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
  function decodeBuffer(buffer, start, end, isUtf8) {
    if (isUtf8) {
      return buffer.toString("utf8", start, end);
    } else {
      var result = "";
      for (var i = start;i < end; i++) {
        result += cp437[buffer[i]];
      }
      return result;
    }
  }
  function readUInt64LE(buffer, offset) {
    var lower32 = buffer.readUInt32LE(offset);
    var upper32 = buffer.readUInt32LE(offset + 4);
    return upper32 * 4294967296 + lower32;
  }
  var newBuffer;
  if (typeof Buffer.allocUnsafe === "function") {
    newBuffer = function(len) {
      return Buffer.allocUnsafe(len);
    };
  } else {
    newBuffer = function(len) {
      return new Buffer(len);
    };
  }
  function defaultCallback(err) {
    if (err)
      throw err;
  }
});

// node_modules/extract-zip/index.js
var require_extract_zip = __commonJS((exports, module) => {
  var debug = require_src2()("extract-zip");
  var { createWriteStream: createWriteStream3, promises: fs13 } = __require("fs");
  var getStream = require_get_stream();
  var path9 = __require("path");
  var { promisify: promisify7 } = __require("util");
  var stream = __require("stream");
  var yauzl = require_yauzl();
  var openZip = promisify7(yauzl.open);
  var pipeline = promisify7(stream.pipeline);

  class Extractor {
    constructor(zipPath, opts) {
      this.zipPath = zipPath;
      this.opts = opts;
    }
    async extract() {
      debug("opening", this.zipPath, "with opts", this.opts);
      this.zipfile = await openZip(this.zipPath, { lazyEntries: true });
      this.canceled = false;
      return new Promise((resolve5, reject) => {
        this.zipfile.on("error", (err) => {
          this.canceled = true;
          reject(err);
        });
        this.zipfile.readEntry();
        this.zipfile.on("close", () => {
          if (!this.canceled) {
            debug("zip extraction complete");
            resolve5();
          }
        });
        this.zipfile.on("entry", async (entry) => {
          if (this.canceled) {
            debug("skipping entry", entry.fileName, { cancelled: this.canceled });
            return;
          }
          debug("zipfile entry", entry.fileName);
          if (entry.fileName.startsWith("__MACOSX/")) {
            this.zipfile.readEntry();
            return;
          }
          const destDir = path9.dirname(path9.join(this.opts.dir, entry.fileName));
          try {
            await fs13.mkdir(destDir, { recursive: true });
            const canonicalDestDir = await fs13.realpath(destDir);
            const relativeDestDir = path9.relative(this.opts.dir, canonicalDestDir);
            if (relativeDestDir.split(path9.sep).includes("..")) {
              throw new Error(`Out of bound path "${canonicalDestDir}" found while processing file ${entry.fileName}`);
            }
            await this.extractEntry(entry);
            debug("finished processing", entry.fileName);
            this.zipfile.readEntry();
          } catch (err) {
            this.canceled = true;
            this.zipfile.close();
            reject(err);
          }
        });
      });
    }
    async extractEntry(entry) {
      if (this.canceled) {
        debug("skipping entry extraction", entry.fileName, { cancelled: this.canceled });
        return;
      }
      if (this.opts.onEntry) {
        this.opts.onEntry(entry, this.zipfile);
      }
      const dest = path9.join(this.opts.dir, entry.fileName);
      const mode = entry.externalFileAttributes >> 16 & 65535;
      const IFMT = 61440;
      const IFDIR = 16384;
      const IFLNK = 40960;
      const symlink3 = (mode & IFMT) === IFLNK;
      let isDir = (mode & IFMT) === IFDIR;
      if (!isDir && entry.fileName.endsWith("/")) {
        isDir = true;
      }
      const madeBy = entry.versionMadeBy >> 8;
      if (!isDir)
        isDir = madeBy === 0 && entry.externalFileAttributes === 16;
      debug("extracting entry", { filename: entry.fileName, isDir, isSymlink: symlink3 });
      const procMode = this.getExtractedMode(mode, isDir) & 511;
      const destDir = isDir ? dest : path9.dirname(dest);
      const mkdirOptions = { recursive: true };
      if (isDir) {
        mkdirOptions.mode = procMode;
      }
      debug("mkdir", { dir: destDir, ...mkdirOptions });
      await fs13.mkdir(destDir, mkdirOptions);
      if (isDir)
        return;
      debug("opening read stream", dest);
      const readStream = await promisify7(this.zipfile.openReadStream.bind(this.zipfile))(entry);
      if (symlink3) {
        const link = await getStream(readStream);
        debug("creating symlink", link, dest);
        await fs13.symlink(link, dest);
      } else {
        await pipeline(readStream, createWriteStream3(dest, { mode: procMode }));
      }
    }
    getExtractedMode(entryMode, isDir) {
      let mode = entryMode;
      if (mode === 0) {
        if (isDir) {
          if (this.opts.defaultDirMode) {
            mode = parseInt(this.opts.defaultDirMode, 10);
          }
          if (!mode) {
            mode = 493;
          }
        } else {
          if (this.opts.defaultFileMode) {
            mode = parseInt(this.opts.defaultFileMode, 10);
          }
          if (!mode) {
            mode = 420;
          }
        }
      }
      return mode;
    }
  }
  module.exports = async function(zipPath, opts) {
    debug("creating target directory", opts.dir);
    if (!path9.isAbsolute(opts.dir)) {
      throw new Error("Target directory is expected to be absolute");
    }
    await fs13.mkdir(opts.dir, { recursive: true });
    opts.dir = await fs13.realpath(opts.dir);
    return new Extractor(zipPath, opts).extract();
  };
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS((exports, module) => {
  var SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  var RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  module.exports = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS((exports, module) => {
  var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {};
  module.exports = debug;
});

// node_modules/semver/internal/re.js
var require_re = __commonJS((exports, module) => {
  var {
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_LENGTH
  } = require_constants();
  var debug = require_debug();
  exports = module.exports = {};
  var re2 = exports.re = [];
  var safeRe = exports.safeRe = [];
  var src = exports.src = [];
  var safeSrc = exports.safeSrc = [];
  var t = exports.t = {};
  var R3 = 0;
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
  ];
  var makeSafeRegex = (value) => {
    for (const [token, max] of safeRegexReplacements) {
      value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value;
  };
  var createToken = (name2, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index = R3++;
    debug(name2, index, value);
    t[name2] = index;
    src[index] = value;
    safeSrc[index] = safe;
    re2[index] = new RegExp(value, isGlobal ? "g" : undefined);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : undefined);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
  createToken("FULL", `^${src[t.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
  createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("COERCEPLAIN", `${"(^|[^\\d])" + "(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
  createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
  createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?` + `(?:${src[t.BUILD]})?` + `(?:$|[^\\d])`);
  createToken("COERCERTL", src[t.COERCE], true);
  createToken("COERCERTLFULL", src[t.COERCEFULL], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS((exports, module) => {
  var looseOption = Object.freeze({ loose: true });
  var emptyOpts = Object.freeze({});
  var parseOptions = (options) => {
    if (!options) {
      return emptyOpts;
    }
    if (typeof options !== "object") {
      return looseOption;
    }
    return options;
  };
  module.exports = parseOptions;
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS((exports, module) => {
  var numeric = /^[0-9]+$/;
  var compareIdentifiers = (a3, b3) => {
    if (typeof a3 === "number" && typeof b3 === "number") {
      return a3 === b3 ? 0 : a3 < b3 ? -1 : 1;
    }
    const anum = numeric.test(a3);
    const bnum = numeric.test(b3);
    if (anum && bnum) {
      a3 = +a3;
      b3 = +b3;
    }
    return a3 === b3 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a3 < b3 ? -1 : 1;
  };
  var rcompareIdentifiers = (a3, b3) => compareIdentifiers(b3, a3);
  module.exports = {
    compareIdentifiers,
    rcompareIdentifiers
  };
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS((exports, module) => {
  var debug = require_debug();
  var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
  var { safeRe: re2, t } = require_re();
  var parseOptions = require_parse_options();
  var { compareIdentifiers } = require_identifiers();

  class SemVer {
    constructor(version, options) {
      options = parseOptions(options);
      if (version instanceof SemVer) {
        if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
      }
      debug("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m2 = version.trim().match(options.loose ? re2[t.LOOSE] : re2[t.FULL]);
      if (!m2) {
        throw new TypeError(`Invalid Version: ${version}`);
      }
      this.raw = version;
      this.major = +m2[1];
      this.minor = +m2[2];
      this.patch = +m2[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m2[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m2[4].split(".").map((id) => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m2[5] ? m2[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.major < other.major) {
        return -1;
      }
      if (this.major > other.major) {
        return 1;
      }
      if (this.minor < other.minor) {
        return -1;
      }
      if (this.minor > other.minor) {
        return 1;
      }
      if (this.patch < other.patch) {
        return -1;
      }
      if (this.patch > other.patch) {
        return 1;
      }
      return 0;
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a3 = this.prerelease[i];
        const b3 = other.prerelease[i];
        debug("prerelease compare", i, a3, b3);
        if (a3 === undefined && b3 === undefined) {
          return 0;
        } else if (b3 === undefined) {
          return 1;
        } else if (a3 === undefined) {
          return -1;
        } else if (a3 === b3) {
          continue;
        } else {
          return compareIdentifiers(a3, b3);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i = 0;
      do {
        const a3 = this.build[i];
        const b3 = other.build[i];
        debug("build compare", i, a3, b3);
        if (a3 === undefined && b3 === undefined) {
          return 0;
        } else if (b3 === undefined) {
          return 1;
        } else if (a3 === undefined) {
          return -1;
        } else if (a3 === b3) {
          continue;
        } else {
          return compareIdentifiers(a3, b3);
        }
      } while (++i);
    }
    inc(release, identifier, identifierBase) {
      if (release.startsWith("pre")) {
        if (!identifier && identifierBase === false) {
          throw new Error("invalid increment argument: identifier is empty");
        }
        if (identifier) {
          const match = `-${identifier}`.match(this.options.loose ? re2[t.PRERELEASELOOSE] : re2[t.PRERELEASE]);
          if (!match || match[1] !== identifier) {
            throw new Error(`invalid identifier: ${identifier}`);
          }
        }
      }
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier, identifierBase);
          this.inc("pre", identifier, identifierBase);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier, identifierBase);
          }
          this.inc("pre", identifier, identifierBase);
          break;
        case "release":
          if (this.prerelease.length === 0) {
            throw new Error(`version ${this.raw} is not a prerelease`);
          }
          this.prerelease.length = 0;
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre": {
          const base = Number(identifierBase) ? 1 : 0;
          if (this.prerelease.length === 0) {
            this.prerelease = [base];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              if (identifier === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base);
            }
          }
          if (identifier) {
            let prerelease = [identifier, base];
            if (identifierBase === false) {
              prerelease = [identifier];
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease;
              }
            } else {
              this.prerelease = prerelease;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  }
  module.exports = SemVer;
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var parse5 = (version, options, throwErrors = false) => {
    if (version instanceof SemVer) {
      return version;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      if (!throwErrors) {
        return null;
      }
      throw er;
    }
  };
  module.exports = parse5;
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS((exports, module) => {
  var parse5 = require_parse();
  var valid = (version, options) => {
    const v2 = parse5(version, options);
    return v2 ? v2.version : null;
  };
  module.exports = valid;
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS((exports, module) => {
  var parse5 = require_parse();
  var clean = (version, options) => {
    const s = parse5(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  };
  module.exports = clean;
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var inc = (version, release, options, identifier, identifierBase) => {
    if (typeof options === "string") {
      identifierBase = identifier;
      identifier = options;
      options = undefined;
    }
    try {
      return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier, identifierBase).version;
    } catch (er) {
      return null;
    }
  };
  module.exports = inc;
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS((exports, module) => {
  var parse5 = require_parse();
  var diff = (version1, version2) => {
    const v1 = parse5(version1, null, true);
    const v2 = parse5(version2, null, true);
    const comparison = v1.compare(v2);
    if (comparison === 0) {
      return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v1 : v2;
    const lowVersion = v1Higher ? v2 : v1;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
      if (!lowVersion.patch && !lowVersion.minor) {
        return "major";
      }
      if (lowVersion.compareMain(highVersion) === 0) {
        if (lowVersion.minor && !lowVersion.patch) {
          return "minor";
        }
        return "patch";
      }
    }
    const prefix = highHasPre ? "pre" : "";
    if (v1.major !== v2.major) {
      return prefix + "major";
    }
    if (v1.minor !== v2.minor) {
      return prefix + "minor";
    }
    if (v1.patch !== v2.patch) {
      return prefix + "patch";
    }
    return "prerelease";
  };
  module.exports = diff;
});

// node_modules/semver/functions/major.js
var require_major = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var major = (a3, loose) => new SemVer(a3, loose).major;
  module.exports = major;
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var minor = (a3, loose) => new SemVer(a3, loose).minor;
  module.exports = minor;
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var patch = (a3, loose) => new SemVer(a3, loose).patch;
  module.exports = patch;
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS((exports, module) => {
  var parse5 = require_parse();
  var prerelease = (version, options) => {
    const parsed = parse5(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  module.exports = prerelease;
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var compare = (a3, b3, loose) => new SemVer(a3, loose).compare(new SemVer(b3, loose));
  module.exports = compare;
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS((exports, module) => {
  var compare = require_compare();
  var rcompare = (a3, b3, loose) => compare(b3, a3, loose);
  module.exports = rcompare;
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS((exports, module) => {
  var compare = require_compare();
  var compareLoose = (a3, b3) => compare(a3, b3, true);
  module.exports = compareLoose;
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var compareBuild = (a3, b3, loose) => {
    const versionA = new SemVer(a3, loose);
    const versionB = new SemVer(b3, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  module.exports = compareBuild;
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var sort = (list3, loose) => list3.sort((a3, b3) => compareBuild(a3, b3, loose));
  module.exports = sort;
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var rsort = (list3, loose) => list3.sort((a3, b3) => compareBuild(b3, a3, loose));
  module.exports = rsort;
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS((exports, module) => {
  var compare = require_compare();
  var gt = (a3, b3, loose) => compare(a3, b3, loose) > 0;
  module.exports = gt;
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS((exports, module) => {
  var compare = require_compare();
  var lt = (a3, b3, loose) => compare(a3, b3, loose) < 0;
  module.exports = lt;
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS((exports, module) => {
  var compare = require_compare();
  var eq = (a3, b3, loose) => compare(a3, b3, loose) === 0;
  module.exports = eq;
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS((exports, module) => {
  var compare = require_compare();
  var neq = (a3, b3, loose) => compare(a3, b3, loose) !== 0;
  module.exports = neq;
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS((exports, module) => {
  var compare = require_compare();
  var gte = (a3, b3, loose) => compare(a3, b3, loose) >= 0;
  module.exports = gte;
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS((exports, module) => {
  var compare = require_compare();
  var lte = (a3, b3, loose) => compare(a3, b3, loose) <= 0;
  module.exports = lte;
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS((exports, module) => {
  var eq = require_eq();
  var neq = require_neq();
  var gt = require_gt();
  var gte = require_gte();
  var lt = require_lt();
  var lte = require_lte();
  var cmp = (a3, op, b3, loose) => {
    switch (op) {
      case "===":
        if (typeof a3 === "object") {
          a3 = a3.version;
        }
        if (typeof b3 === "object") {
          b3 = b3.version;
        }
        return a3 === b3;
      case "!==":
        if (typeof a3 === "object") {
          a3 = a3.version;
        }
        if (typeof b3 === "object") {
          b3 = b3.version;
        }
        return a3 !== b3;
      case "":
      case "=":
      case "==":
        return eq(a3, b3, loose);
      case "!=":
        return neq(a3, b3, loose);
      case ">":
        return gt(a3, b3, loose);
      case ">=":
        return gte(a3, b3, loose);
      case "<":
        return lt(a3, b3, loose);
      case "<=":
        return lte(a3, b3, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  module.exports = cmp;
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var parse5 = require_parse();
  var { safeRe: re2, t } = require_re();
  var coerce2 = (version, options) => {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version === "number") {
      version = String(version);
    }
    if (typeof version !== "string") {
      return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
      match = version.match(options.includePrerelease ? re2[t.COERCEFULL] : re2[t.COERCE]);
    } else {
      const coerceRtlRegex = options.includePrerelease ? re2[t.COERCERTLFULL] : re2[t.COERCERTL];
      let next;
      while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
      }
      coerceRtlRegex.lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    const major = match[2];
    const minor = match[3] || "0";
    const patch = match[4] || "0";
    const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
    const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
    return parse5(`${major}.${minor}.${patch}${prerelease}${build}`, options);
  };
  module.exports = coerce2;
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS((exports, module) => {
  class LRUCache {
    constructor() {
      this.max = 1000;
      this.map = new Map;
    }
    get(key) {
      const value = this.map.get(key);
      if (value === undefined) {
        return;
      } else {
        this.map.delete(key);
        this.map.set(key, value);
        return value;
      }
    }
    delete(key) {
      return this.map.delete(key);
    }
    set(key, value) {
      const deleted = this.delete(key);
      if (!deleted && value !== undefined) {
        if (this.map.size >= this.max) {
          const firstKey = this.map.keys().next().value;
          this.delete(firstKey);
        }
        this.map.set(key, value);
      }
      return this;
    }
  }
  module.exports = LRUCache;
});

// node_modules/semver/classes/range.js
var require_range = __commonJS((exports, module) => {
  var SPACE_CHARACTERS = /\s+/g;

  class Range {
    constructor(range, options) {
      options = parseOptions(options);
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        this.raw = range.value;
        this.set = [[range]];
        this.formatted = undefined;
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r2) => this.parseRange(r2.trim())).filter((c2) => c2.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c2) => !isNullSet(c2[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c2 of this.set) {
            if (c2.length === 1 && isAny(c2[0])) {
              this.set = [c2];
              break;
            }
          }
        }
      }
      this.formatted = undefined;
    }
    get range() {
      if (this.formatted === undefined) {
        this.formatted = "";
        for (let i = 0;i < this.set.length; i++) {
          if (i > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i];
          for (let k2 = 0;k2 < comps.length; k2++) {
            if (k2 > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k2].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range;
      const cached = cache2.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re2[t.HYPHENRANGELOOSE] : re2[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug("hyphen replace", range);
      range = range.replace(re2[t.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range);
      range = range.replace(re2[t.TILDETRIM], tildeTrimReplace);
      debug("tilde trim", range);
      range = range.replace(re2[t.CARETTRIM], caretTrimReplace);
      debug("caret trim", range);
      let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug("loose invalid filter", comp, this.options);
          return !!comp.match(re2[t.COMPARATORLOOSE]);
        });
      }
      debug("range list", rangeList);
      const rangeMap = new Map;
      const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache2.set(memoKey, result);
      return result;
    }
    intersects(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    test(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0;i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  module.exports = Range;
  var LRU = require_lrucache();
  var cache2 = new LRU;
  var parseOptions = require_parse_options();
  var Comparator = require_comparator();
  var debug = require_debug();
  var SemVer = require_semver();
  var {
    safeRe: re2,
    t,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = require_re();
  var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
  var isNullSet = (c2) => c2.value === "<0.0.0-0";
  var isAny = (c2) => c2.value === "";
  var isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var parseComparator = (comp, options) => {
    comp = comp.replace(re2[t.BUILD], "");
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  };
  var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  var replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c2) => replaceTilde(c2, options)).join(" ");
  };
  var replaceTilde = (comp, options) => {
    const r2 = options.loose ? re2[t.TILDELOOSE] : re2[t.TILDE];
    return comp.replace(r2, (_3, M3, m2, p, pr) => {
      debug("tilde", comp, _3, M3, m2, p, pr);
      let ret;
      if (isX(M3)) {
        ret = "";
      } else if (isX(m2)) {
        ret = `>=${M3}.0.0 <${+M3 + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M3}.${m2}.0 <${M3}.${+m2 + 1}.0-0`;
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = `>=${M3}.${m2}.${p}-${pr} <${M3}.${+m2 + 1}.0-0`;
      } else {
        ret = `>=${M3}.${m2}.${p} <${M3}.${+m2 + 1}.0-0`;
      }
      debug("tilde return", ret);
      return ret;
    });
  };
  var replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c2) => replaceCaret(c2, options)).join(" ");
  };
  var replaceCaret = (comp, options) => {
    debug("caret", comp, options);
    const r2 = options.loose ? re2[t.CARETLOOSE] : re2[t.CARET];
    const z3 = options.includePrerelease ? "-0" : "";
    return comp.replace(r2, (_3, M3, m2, p, pr) => {
      debug("caret", comp, _3, M3, m2, p, pr);
      let ret;
      if (isX(M3)) {
        ret = "";
      } else if (isX(m2)) {
        ret = `>=${M3}.0.0${z3} <${+M3 + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M3 === "0") {
          ret = `>=${M3}.${m2}.0${z3} <${M3}.${+m2 + 1}.0-0`;
        } else {
          ret = `>=${M3}.${m2}.0${z3} <${+M3 + 1}.0.0-0`;
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M3 === "0") {
          if (m2 === "0") {
            ret = `>=${M3}.${m2}.${p}-${pr} <${M3}.${m2}.${+p + 1}-0`;
          } else {
            ret = `>=${M3}.${m2}.${p}-${pr} <${M3}.${+m2 + 1}.0-0`;
          }
        } else {
          ret = `>=${M3}.${m2}.${p}-${pr} <${+M3 + 1}.0.0-0`;
        }
      } else {
        debug("no pr");
        if (M3 === "0") {
          if (m2 === "0") {
            ret = `>=${M3}.${m2}.${p}${z3} <${M3}.${m2}.${+p + 1}-0`;
          } else {
            ret = `>=${M3}.${m2}.${p}${z3} <${M3}.${+m2 + 1}.0-0`;
          }
        } else {
          ret = `>=${M3}.${m2}.${p} <${+M3 + 1}.0.0-0`;
        }
      }
      debug("caret return", ret);
      return ret;
    });
  };
  var replaceXRanges = (comp, options) => {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c2) => replaceXRange(c2, options)).join(" ");
  };
  var replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r2 = options.loose ? re2[t.XRANGELOOSE] : re2[t.XRANGE];
    return comp.replace(r2, (ret, gtlt, M3, m2, p, pr) => {
      debug("xRange", comp, ret, gtlt, M3, m2, p, pr);
      const xM = isX(M3);
      const xm = xM || isX(m2);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m2 = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M3 = +M3 + 1;
            m2 = 0;
            p = 0;
          } else {
            m2 = +m2 + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M3 = +M3 + 1;
          } else {
            m2 = +m2 + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M3}.${m2}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M3}.0.0${pr} <${+M3 + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M3}.${m2}.0${pr} <${M3}.${+m2 + 1}.0-0`;
      }
      debug("xRange return", ret);
      return ret;
    });
  };
  var replaceStars = (comp, options) => {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re2[t.STAR], "");
  };
  var replaceGTE0 = (comp, options) => {
    debug("replaceGTE0", comp, options);
    return comp.trim().replace(re2[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
  };
  var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  var testSet = (set, version, options) => {
    for (let i = 0;i < set.length; i++) {
      if (!set[i].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (let i = 0;i < set.length; i++) {
        debug(set[i].semver);
        if (set[i].semver === Comparator.ANY) {
          continue;
        }
        if (set[i].semver.prerelease.length > 0) {
          const allowed = set[i].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS((exports, module) => {
  var ANY = Symbol("SemVer ANY");

  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    parse(comp) {
      const r2 = this.options.loose ? re2[t.COMPARATORLOOSE] : re2[t.COMPARATOR];
      const m2 = comp.match(r2);
      if (!m2) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m2[1] !== undefined ? m2[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m2[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m2[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options).test(comp.semver);
      }
      options = parseOptions(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  module.exports = Comparator;
  var parseOptions = require_parse_options();
  var { safeRe: re2, t } = require_re();
  var cmp = require_cmp();
  var debug = require_debug();
  var SemVer = require_semver();
  var Range = require_range();
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS((exports, module) => {
  var Range = require_range();
  var satisfies = (version, range, options) => {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  };
  module.exports = satisfies;
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS((exports, module) => {
  var Range = require_range();
  var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c2) => c2.value).join(" ").trim().split(" "));
  module.exports = toComparators;
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var maxSatisfying = (versions, range, options) => {
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v2) => {
      if (rangeObj.test(v2)) {
        if (!max || maxSV.compare(v2) === -1) {
          max = v2;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  };
  module.exports = maxSatisfying;
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var minSatisfying = (versions, range, options) => {
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v2) => {
      if (rangeObj.test(v2)) {
        if (!min || minSV.compare(v2) === 1) {
          min = v2;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  };
  module.exports = minSatisfying;
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var gt = require_gt();
  var minVersion = (range, loose) => {
    range = new Range(range, loose);
    let minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i = 0;i < range.set.length; ++i) {
      const comparators = range.set[i];
      let setMin = null;
      comparators.forEach((comparator) => {
        const compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!setMin || gt(compver, setMin)) {
              setMin = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${comparator.operator}`);
        }
      });
      if (setMin && (!minver || gt(minver, setMin))) {
        minver = setMin;
      }
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  };
  module.exports = minVersion;
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS((exports, module) => {
  var Range = require_range();
  var validRange = (range, options) => {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  module.exports = validRange;
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var Range = require_range();
  var satisfies = require_satisfies();
  var gt = require_gt();
  var lt = require_lt();
  var lte = require_lte();
  var gte = require_gte();
  var outside = (version, range, hilo, options) => {
    version = new SemVer(version, options);
    range = new Range(range, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (let i = 0;i < range.set.length; ++i) {
      const comparators = range.set[i];
      let high = null;
      let low = null;
      comparators.forEach((comparator) => {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  };
  module.exports = outside;
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS((exports, module) => {
  var outside = require_outside();
  var gtr = (version, range, options) => outside(version, range, ">", options);
  module.exports = gtr;
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS((exports, module) => {
  var outside = require_outside();
  var ltr = (version, range, options) => outside(version, range, "<", options);
  module.exports = ltr;
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS((exports, module) => {
  var Range = require_range();
  var intersects = (r1, r2, options) => {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2, options);
  };
  module.exports = intersects;
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS((exports, module) => {
  var satisfies = require_satisfies();
  var compare = require_compare();
  module.exports = (versions, range, options) => {
    const set = [];
    let first = null;
    let prev = null;
    const v2 = versions.sort((a3, b3) => compare(a3, b3, options));
    for (const version of v2) {
      const included = satisfies(version, range, options);
      if (included) {
        prev = version;
        if (!first) {
          first = version;
        }
      } else {
        if (prev) {
          set.push([first, prev]);
        }
        prev = null;
        first = null;
      }
    }
    if (first) {
      set.push([first, null]);
    }
    const ranges = [];
    for (const [min, max] of set) {
      if (min === max) {
        ranges.push(min);
      } else if (!max && min === v2[0]) {
        ranges.push("*");
      } else if (!max) {
        ranges.push(`>=${min}`);
      } else if (min === v2[0]) {
        ranges.push(`<=${max}`);
      } else {
        ranges.push(`${min} - ${max}`);
      }
    }
    const simplified = ranges.join(" || ");
    const original = typeof range.raw === "string" ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
  };
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS((exports, module) => {
  var Range = require_range();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var satisfies = require_satisfies();
  var compare = require_compare();
  var subset = (sub, dom, options = {}) => {
    if (sub === dom) {
      return true;
    }
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER:
      for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
    return true;
  };
  var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
  var minimumVersion = [new Comparator(">=0.0.0")];
  var simpleSubset = (sub, dom, options) => {
    if (sub === dom) {
      return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
      if (dom.length === 1 && dom[0].semver === ANY) {
        return true;
      } else if (options.includePrerelease) {
        sub = minimumVersionWithPreRelease;
      } else {
        sub = minimumVersion;
      }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
      if (options.includePrerelease) {
        return true;
      } else {
        dom = minimumVersion;
      }
    }
    const eqSet = new Set;
    let gt, lt;
    for (const c2 of sub) {
      if (c2.operator === ">" || c2.operator === ">=") {
        gt = higherGT(gt, c2, options);
      } else if (c2.operator === "<" || c2.operator === "<=") {
        lt = lowerLT(lt, c2, options);
      } else {
        eqSet.add(c2.semver);
      }
    }
    if (eqSet.size > 1) {
      return null;
    }
    let gtltComp;
    if (gt && lt) {
      gtltComp = compare(gt.semver, lt.semver, options);
      if (gtltComp > 0) {
        return null;
      } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
        return null;
      }
    }
    for (const eq of eqSet) {
      if (gt && !satisfies(eq, String(gt), options)) {
        return null;
      }
      if (lt && !satisfies(eq, String(lt), options)) {
        return null;
      }
      for (const c2 of dom) {
        if (!satisfies(eq, String(c2), options)) {
          return false;
        }
      }
      return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
      needDomLTPre = false;
    }
    for (const c2 of dom) {
      hasDomGT = hasDomGT || c2.operator === ">" || c2.operator === ">=";
      hasDomLT = hasDomLT || c2.operator === "<" || c2.operator === "<=";
      if (gt) {
        if (needDomGTPre) {
          if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomGTPre.major && c2.semver.minor === needDomGTPre.minor && c2.semver.patch === needDomGTPre.patch) {
            needDomGTPre = false;
          }
        }
        if (c2.operator === ">" || c2.operator === ">=") {
          higher = higherGT(gt, c2, options);
          if (higher === c2 && higher !== gt) {
            return false;
          }
        } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c2), options)) {
          return false;
        }
      }
      if (lt) {
        if (needDomLTPre) {
          if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomLTPre.major && c2.semver.minor === needDomLTPre.minor && c2.semver.patch === needDomLTPre.patch) {
            needDomLTPre = false;
          }
        }
        if (c2.operator === "<" || c2.operator === "<=") {
          lower = lowerLT(lt, c2, options);
          if (lower === c2 && lower !== lt) {
            return false;
          }
        } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c2), options)) {
          return false;
        }
      }
      if (!c2.operator && (lt || gt) && gtltComp !== 0) {
        return false;
      }
    }
    if (gt && hasDomLT && !lt && gtltComp !== 0) {
      return false;
    }
    if (lt && hasDomGT && !gt && gtltComp !== 0) {
      return false;
    }
    if (needDomGTPre || needDomLTPre) {
      return false;
    }
    return true;
  };
  var higherGT = (a3, b3, options) => {
    if (!a3) {
      return b3;
    }
    const comp = compare(a3.semver, b3.semver, options);
    return comp > 0 ? a3 : comp < 0 ? b3 : b3.operator === ">" && a3.operator === ">=" ? b3 : a3;
  };
  var lowerLT = (a3, b3, options) => {
    if (!a3) {
      return b3;
    }
    const comp = compare(a3.semver, b3.semver, options);
    return comp < 0 ? a3 : comp > 0 ? b3 : b3.operator === "<" && a3.operator === "<=" ? b3 : a3;
  };
  module.exports = subset;
});

// node_modules/semver/index.js
var require_semver2 = __commonJS((exports, module) => {
  var internalRe = require_re();
  var constants5 = require_constants();
  var SemVer = require_semver();
  var identifiers = require_identifiers();
  var parse5 = require_parse();
  var valid = require_valid();
  var clean = require_clean();
  var inc = require_inc();
  var diff = require_diff();
  var major = require_major();
  var minor = require_minor();
  var patch = require_patch();
  var prerelease = require_prerelease();
  var compare = require_compare();
  var rcompare = require_rcompare();
  var compareLoose = require_compare_loose();
  var compareBuild = require_compare_build();
  var sort = require_sort();
  var rsort = require_rsort();
  var gt = require_gt();
  var lt = require_lt();
  var eq = require_eq();
  var neq = require_neq();
  var gte = require_gte();
  var lte = require_lte();
  var cmp = require_cmp();
  var coerce2 = require_coerce();
  var Comparator = require_comparator();
  var Range = require_range();
  var satisfies = require_satisfies();
  var toComparators = require_to_comparators();
  var maxSatisfying = require_max_satisfying();
  var minSatisfying = require_min_satisfying();
  var minVersion = require_min_version();
  var validRange = require_valid2();
  var outside = require_outside();
  var gtr = require_gtr();
  var ltr = require_ltr();
  var intersects = require_intersects();
  var simplifyRange = require_simplify();
  var subset = require_subset();
  module.exports = {
    parse: parse5,
    valid,
    clean,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce: coerce2,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants5.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants5.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
  };
});

// src/domains/ui/ownership-display.ts
var exports_ownership_display = {};
__export(exports_ownership_display, {
  OwnershipDisplay: () => OwnershipDisplay
});

class OwnershipDisplay {
  static formatOwnership(ownership) {
    switch (ownership) {
      case "ck":
        return import_picocolors18.default.blue("CK-owned");
      case "user":
        return import_picocolors18.default.green("User-created");
      case "ck-modified":
        return import_picocolors18.default.yellow("CK-modified");
      default:
        return import_picocolors18.default.gray("Unknown");
    }
  }
  static formatAction(action) {
    switch (action) {
      case "delete":
        return import_picocolors18.default.red(" DELETE");
      case "preserve":
        return import_picocolors18.default.green(" PRESERVE");
      case "skip":
        return import_picocolors18.default.gray(" SKIP");
      default:
        return import_picocolors18.default.gray("? UNKNOWN");
    }
  }
  static calculateSummary(results) {
    const summary = {
      totalFiles: results.length,
      ckOwned: 0,
      userCreated: 0,
      ckModified: 0,
      toDelete: 0,
      toPreserve: 0
    };
    for (const result of results) {
      switch (result.ownership) {
        case "ck":
          summary.ckOwned++;
          break;
        case "user":
          summary.userCreated++;
          break;
        case "ck-modified":
          summary.ckModified++;
          break;
      }
      if (result.action === "delete") {
        summary.toDelete++;
      } else if (result.action === "preserve") {
        summary.toPreserve++;
      }
    }
    return summary;
  }
  static displaySummary(summary, title = "Ownership Summary") {
    const lines = [
      `Total files: ${import_picocolors18.default.bold(String(summary.totalFiles))}`,
      "",
      "By ownership:",
      `  ${import_picocolors18.default.blue("")} CK-owned:     ${summary.ckOwned}`,
      `  ${import_picocolors18.default.green("")} User-created: ${summary.userCreated}`,
      `  ${import_picocolors18.default.yellow("")} CK-modified:  ${summary.ckModified}`,
      "",
      "Actions:",
      `  ${import_picocolors18.default.red("")} To delete:   ${summary.toDelete}`,
      `  ${import_picocolors18.default.green("")} To preserve: ${summary.toPreserve}`
    ];
    le(lines.join(`
`), title);
  }
  static displayOperationPreview(results, maxItems = 10) {
    const summary = OwnershipDisplay.calculateSummary(results);
    f2.info(import_picocolors18.default.bold("DRY RUN - Preview of changes:"));
    console.log("");
    const toDelete = results.filter((r2) => r2.action === "delete");
    const toPreserve = results.filter((r2) => r2.action === "preserve");
    if (toDelete.length > 0) {
      console.log(import_picocolors18.default.red(import_picocolors18.default.bold(`Files to DELETE (${toDelete.length}):`)));
      const showDelete = toDelete.slice(0, maxItems);
      for (const result of showDelete) {
        console.log(`  ${import_picocolors18.default.red("")} ${result.path}`);
      }
      if (toDelete.length > maxItems) {
        console.log(import_picocolors18.default.gray(`  ... and ${toDelete.length - maxItems} more`));
      }
      console.log("");
    }
    if (toPreserve.length > 0) {
      console.log(import_picocolors18.default.green(import_picocolors18.default.bold(`Files to PRESERVE (${toPreserve.length}):`)));
      const showPreserve = toPreserve.slice(0, maxItems);
      for (const result of showPreserve) {
        const reason = result.reason ? import_picocolors18.default.gray(` (${result.reason})`) : "";
        console.log(`  ${import_picocolors18.default.green("")} ${result.path}${reason}`);
      }
      if (toPreserve.length > maxItems) {
        console.log(import_picocolors18.default.gray(`  ... and ${toPreserve.length - maxItems} more`));
      }
      console.log("");
    }
    OwnershipDisplay.displaySummary(summary, "Preview Summary");
    f2.warn(import_picocolors18.default.yellow("No changes were made. Run without --dry-run to apply changes."));
  }
  static displayFile(path11, ownership, action, reason) {
    const ownershipStr = OwnershipDisplay.formatOwnership(ownership);
    const actionStr = OwnershipDisplay.formatAction(action);
    const reasonStr = reason ? import_picocolors18.default.gray(` - ${reason}`) : "";
    console.log(`  ${actionStr} ${path11} [${ownershipStr}]${reasonStr}`);
  }
  static displayForceWarning() {
    f2.warn(`${import_picocolors18.default.yellow(import_picocolors18.default.bold("FORCE MODE ENABLED"))}
${import_picocolors18.default.yellow("User modifications will be overwritten!")}
${import_picocolors18.default.gray("Use --dry-run first to preview changes.")}`);
  }
  static displayLegacyWarning() {
    f2.warn(`${import_picocolors18.default.yellow(import_picocolors18.default.bold("Legacy Installation Detected"))}
${import_picocolors18.default.yellow("No ownership metadata found.")}
${import_picocolors18.default.gray("Running migration to enable ownership tracking...")}`);
  }
  static displayCompletionSummary(deleted, preserved) {
    const message = `${import_picocolors18.default.green(` Deleted ${deleted} CK-owned file(s)`)}
${import_picocolors18.default.blue(` Preserved ${preserved} user/modified file(s)`)}`;
    f2.success(message);
  }
}
var import_picocolors18;
var init_ownership_display = __esm(() => {
  init_dist2();
  import_picocolors18 = __toESM(require_picocolors(), 1);
});

// src/domains/help/commands/common-options.ts
var filterOptionsGroup, folderOptionsGroup;
var init_common_options = __esm(() => {
  filterOptionsGroup = {
    title: "Filter Options",
    options: [
      {
        flags: "--exclude <pattern>",
        description: "Exclude files matching glob pattern (can be used multiple times)"
      },
      {
        flags: "--beta",
        description: "Show beta versions in selection prompt"
      },
      {
        flags: "--refresh",
        description: "Bypass release cache to fetch latest versions from GitHub"
      }
    ]
  };
  folderOptionsGroup = {
    title: "Folder Options",
    options: [
      {
        flags: "--docs-dir <name>",
        description: "Custom docs folder name to avoid conflicts with existing folders",
        defaultValue: "docs"
      },
      {
        flags: "--plans-dir <name>",
        description: "Custom plans folder name to avoid conflicts with existing folders",
        defaultValue: "plans"
      }
    ]
  };
});

// src/domains/help/commands/new-command-help.ts
var newCommandHelp;
var init_new_command_help = __esm(() => {
  init_common_options();
  newCommandHelp = {
    name: "new",
    description: "Bootstrap a new ClaudeKit project (with interactive version selection)",
    usage: "ck new [options]",
    examples: [
      {
        command: "ck new --kit engineer --dir ./my-project",
        description: "Create engineer kit project in specific directory"
      },
      {
        command: "ck new -y --use-git --release v2.1.0",
        description: "Non-interactive with git clone (no GitHub API needed)"
      }
    ],
    optionGroups: [
      {
        title: "Mode Options",
        options: [
          {
            flags: "-y, --yes",
            description: "Non-interactive mode (skip all prompts)"
          },
          {
            flags: "--use-git",
            description: "Use git clone instead of GitHub API (uses SSH/HTTPS credentials)"
          }
        ]
      },
      {
        title: "Project Options",
        options: [
          {
            flags: "--dir <directory>",
            description: "Target directory for the new project",
            defaultValue: "."
          },
          {
            flags: "--kit <kit>",
            description: "Kit to use (engineer, marketing)"
          },
          {
            flags: "-r, --release <version>",
            description: "Skip version selection, use specific version (e.g., latest, v1.0.0)"
          },
          {
            flags: "--force",
            description: "Overwrite existing files without confirmation"
          }
        ]
      },
      filterOptionsGroup,
      {
        title: "Installation Options",
        options: [
          {
            flags: "--opencode",
            description: "Install OpenCode CLI package (non-interactive mode)"
          },
          {
            flags: "--gemini",
            description: "Install Google Gemini CLI package (non-interactive mode)"
          },
          {
            flags: "--install-skills",
            description: "Install skills dependencies (non-interactive mode)"
          },
          {
            flags: "--with-sudo",
            description: "Include system packages requiring sudo (Linux: ffmpeg, imagemagick)"
          },
          {
            flags: "--prefix",
            description: "Add /ck: prefix to all slash commands"
          }
        ]
      },
      folderOptionsGroup
    ]
  };
});

// src/domains/help/commands/init-command-help.ts
var initCommandHelp;
var init_init_command_help = __esm(() => {
  init_common_options();
  initCommandHelp = {
    name: "init",
    description: "Initialize or update ClaudeKit project (with interactive version selection)",
    usage: "ck init [options]",
    examples: [
      {
        command: "ck init --kit engineer",
        description: "Update local project with latest engineer kit"
      },
      {
        command: "ck init --use-git --release v2.1.0 -y",
        description: "Non-interactive with git clone (no GitHub API needed)"
      }
    ],
    optionGroups: [
      {
        title: "Mode Options",
        options: [
          {
            flags: "-y, --yes",
            description: "Non-interactive mode with sensible defaults (kit: engineer, dir: ., version: latest)"
          },
          {
            flags: "--use-git",
            description: "Use git clone instead of GitHub API (uses SSH/HTTPS credentials)"
          },
          {
            flags: "--sync",
            description: "Sync config files from upstream with interactive hunk-by-hunk merge"
          }
        ]
      },
      {
        title: "Project Options",
        options: [
          {
            flags: "--dir <directory>",
            description: "Target directory to initialize/update",
            defaultValue: "."
          },
          {
            flags: "--kit <kit>",
            description: "Kit to use (engineer, marketing)"
          },
          {
            flags: "-r, --release <version>",
            description: "Skip version selection, use specific version"
          },
          {
            flags: "-g, --global",
            description: "Use platform-specific user configuration directory"
          },
          {
            flags: "--fresh",
            description: "Remove ClaudeKit directories (commands/, agents/, skills/, rules/, hooks/) and reinstall"
          }
        ]
      },
      {
        title: "Filter Options",
        options: [
          {
            flags: "--exclude <pattern>",
            description: "Exclude files matching glob pattern (can be used multiple times)"
          },
          {
            flags: "--only <pattern>",
            description: "Include only files matching glob pattern (can be used multiple times)"
          },
          {
            flags: "--beta",
            description: "Show beta versions in selection prompt"
          },
          {
            flags: "--refresh",
            description: "Bypass release cache to fetch latest versions from GitHub"
          }
        ]
      },
      {
        title: "Installation Options",
        options: [
          {
            flags: "--install-skills",
            description: "Install skills dependencies (non-interactive mode)"
          },
          {
            flags: "--with-sudo",
            description: "Include system packages requiring sudo (Linux: ffmpeg, imagemagick)"
          },
          {
            flags: "--prefix",
            description: "Add /ck: prefix to all slash commands"
          },
          {
            flags: "--skip-setup",
            description: "Skip interactive configuration wizard"
          },
          {
            flags: "--dry-run",
            description: "Preview changes without applying them (requires --prefix)"
          },
          {
            flags: "--force-overwrite",
            description: "Override ownership protections and delete user-modified files"
          },
          {
            flags: "--force-overwrite-settings",
            description: "Fully replace settings.json instead of selective merge"
          }
        ]
      },
      folderOptionsGroup
    ]
  };
});

// src/domains/help/commands/doctor-command-help.ts
var doctorCommandHelp;
var init_doctor_command_help = __esm(() => {
  doctorCommandHelp = {
    name: "doctor",
    description: "Comprehensive health check for ClaudeKit",
    usage: "ck doctor [options]",
    examples: [
      {
        command: "ck doctor",
        description: "Run full health check interactively"
      },
      {
        command: "ck doctor --fix",
        description: "Auto-fix all fixable issues"
      },
      {
        command: "ck doctor --check-only",
        description: "CI mode: exit 1 on failures, no prompts"
      }
    ],
    optionGroups: [
      {
        title: "Options",
        options: [
          {
            flags: "--report",
            description: "Generate shareable diagnostic report"
          },
          {
            flags: "--fix",
            description: "Auto-fix all fixable issues"
          },
          {
            flags: "--check-only",
            description: "CI mode: no prompts, exit 1 on failures"
          },
          {
            flags: "--full",
            description: "Include extended priority checks (slower but more thorough)"
          },
          {
            flags: "--json",
            description: "Output JSON format"
          }
        ]
      }
    ]
  };
});

// src/domains/help/commands/uninstall-command-help.ts
var uninstallCommandHelp;
var init_uninstall_command_help = __esm(() => {
  uninstallCommandHelp = {
    name: "uninstall",
    description: "Remove ClaudeKit installations (ownership-aware)",
    usage: "ck uninstall [options]",
    examples: [
      {
        command: "ck uninstall --local --yes",
        description: "Remove local installation without confirmation"
      },
      {
        command: "ck uninstall --dry-run",
        description: "Preview what would be removed without deleting"
      }
    ],
    optionGroups: [
      {
        title: "Scope Options",
        options: [
          {
            flags: "-l, --local",
            description: "Uninstall only local installation (current project)"
          },
          {
            flags: "-g, --global",
            description: "Uninstall only global installation (~/.claude/)"
          },
          {
            flags: "-A, --all",
            description: "Uninstall from both local and global locations"
          },
          {
            flags: "-k, --kit <type>",
            description: "Uninstall specific kit only (engineer, marketing)"
          }
        ]
      },
      {
        title: "Safety Options",
        options: [
          {
            flags: "--dry-run",
            description: "Preview what would be removed without deleting"
          },
          {
            flags: "--force-overwrite",
            description: "Delete even user-modified files (requires confirmation)"
          },
          {
            flags: "-y, --yes",
            description: "Skip confirmation prompt"
          }
        ]
      }
    ],
    sections: [
      {
        title: "Ownership-Aware Uninstall",
        content: "Uninstall preserves user customizations by default. Only CK-installed files that haven't been modified are removed. User-created files and modified files are preserved unless --force-overwrite is used."
      }
    ]
  };
});

// src/domains/help/commands/update-command-help.ts
var updateCommandHelp;
var init_update_command_help = __esm(() => {
  updateCommandHelp = {
    name: "update",
    description: "Update ClaudeKit CLI tool only (not kit content)",
    usage: "ck update [options]",
    examples: [
      {
        command: "ck update --check",
        description: "Check for CLI updates without installing"
      },
      {
        command: "ck update --beta --yes",
        description: "Update to latest beta version without confirmation"
      }
    ],
    optionGroups: [
      {
        title: "Update Options",
        options: [
          {
            flags: "-r, --release <version>",
            description: "Update to a specific version"
          },
          {
            flags: "--check",
            description: "Check for updates without installing"
          },
          {
            flags: "-y, --yes",
            description: "Skip confirmation prompt"
          },
          {
            flags: "--beta",
            description: "Update to the latest beta version"
          },
          {
            flags: "--registry <url>",
            description: "Custom npm registry URL"
          }
        ]
      },
      {
        title: "Deprecated Options",
        options: [
          {
            flags: "--kit <kit>",
            description: "This option is no longer supported with 'ck update'",
            deprecated: {
              message: "Use 'ck init --kit <kit>' to update kit installations",
              alternative: "ck init --kit <kit>"
            }
          },
          {
            flags: "-g, --global",
            description: "This option is no longer supported with 'ck update'",
            deprecated: {
              message: "Use 'ck init --global' to update global kit",
              alternative: "ck init --global"
            }
          }
        ]
      }
    ],
    sections: [
      {
        title: "Note",
        content: "'ck update' updates the CLI tool only. To update kit content (skills, commands, rules), use 'ck init' for local or 'ck init -g' for global."
      }
    ]
  };
});

// src/domains/help/commands/versions-command-help.ts
var versionsCommandHelp;
var init_versions_command_help = __esm(() => {
  versionsCommandHelp = {
    name: "versions",
    description: "List available versions of ClaudeKit repositories",
    usage: "ck versions [options]",
    examples: [
      {
        command: "ck versions --kit engineer --limit 10",
        description: "Show latest 10 versions of engineer kit"
      },
      {
        command: "ck versions --all",
        description: "Show all releases including prereleases"
      }
    ],
    optionGroups: [
      {
        title: "Filter Options",
        options: [
          {
            flags: "--kit <kit>",
            description: "Filter by specific kit (engineer, marketing)"
          },
          {
            flags: "--limit <number>",
            description: "Number of releases to show",
            defaultValue: "30"
          },
          {
            flags: "--all",
            description: "Show all releases including prereleases"
          }
        ]
      }
    ]
  };
});

// src/domains/help/commands/index.ts
var init_commands2 = __esm(() => {
  init_new_command_help();
  init_init_command_help();
  init_doctor_command_help();
  init_uninstall_command_help();
  init_update_command_help();
  init_versions_command_help();
  init_common_options();
});

// src/domains/help/help-commands.ts
function hasCommand(command) {
  return command in HELP_REGISTRY;
}
var HELP_REGISTRY;
var init_help_commands = __esm(() => {
  init_commands2();
  init_commands2();
  HELP_REGISTRY = {
    new: newCommandHelp,
    init: initCommandHelp,
    update: updateCommandHelp,
    versions: versionsCommandHelp,
    doctor: doctorCommandHelp,
    uninstall: uninstallCommandHelp
  };
});

// src/domains/help/help-colors.ts
function stripColors(text) {
  return text.replace(/\x1b\[[0-9;]*m/g, "");
}
function getVisibleLength(text) {
  return stripColors(text).length;
}
function padEnd(text, width) {
  const visibleLength = getVisibleLength(text);
  const padding = Math.max(0, width - visibleLength);
  return text + " ".repeat(padding);
}
var import_picocolors27, NO_COLOR, isColorSupported, identity = (text) => text, colors, defaultTheme;
var init_help_colors = __esm(() => {
  import_picocolors27 = __toESM(require_picocolors(), 1);
  NO_COLOR = process.env.NO_COLOR !== undefined;
  isColorSupported = !NO_COLOR && Boolean(process.stdout.isTTY);
  colors = {
    banner: isColorSupported ? import_picocolors27.default.cyan : identity,
    command: isColorSupported ? import_picocolors27.default.bold : identity,
    heading: isColorSupported ? import_picocolors27.default.yellow : identity,
    flag: isColorSupported ? import_picocolors27.default.green : identity,
    description: isColorSupported ? import_picocolors27.default.gray : identity,
    example: isColorSupported ? import_picocolors27.default.blue : identity,
    warning: isColorSupported ? import_picocolors27.default.yellow : identity,
    error: isColorSupported ? import_picocolors27.default.red : identity,
    muted: isColorSupported ? import_picocolors27.default.dim : identity,
    success: isColorSupported ? import_picocolors27.default.green : identity
  };
  defaultTheme = {
    banner: colors.banner,
    command: colors.command,
    heading: colors.heading,
    flag: colors.flag,
    description: colors.description,
    example: colors.example,
    warning: colors.warning,
    error: colors.error,
    muted: colors.muted,
    success: colors.success
  };
});

// src/domains/help/help-interactive.ts
import { spawn as spawn2 } from "node:child_process";
import * as readline from "node:readline";
function getTerminalHeight() {
  return process.stdout.rows || 24;
}
function getContentHeight(content) {
  return stripColors(content).split(`
`).length;
}
function shouldUsePager(content, options) {
  if (!options.interactive)
    return false;
  if (!process.stdout.isTTY)
    return false;
  if (options.width < 80)
    return false;
  const termHeight = getTerminalHeight();
  const contentHeight = getContentHeight(content);
  return contentHeight > termHeight - 2;
}
function getPagerArgs(pagerCmd) {
  if (pagerCmd.includes("less")) {
    return [
      "-R",
      "-F",
      "-X"
    ];
  }
  return [];
}
async function trySystemPager(content) {
  return new Promise((resolve11) => {
    const pagerCmd = process.env.PAGER || "less";
    const pagerArgs = getPagerArgs(pagerCmd);
    try {
      const pager = spawn2(pagerCmd, pagerArgs, {
        stdio: ["pipe", process.stdout, process.stderr],
        shell: false
      });
      const timeout = setTimeout(() => {
        pager.kill();
        resolve11(false);
      }, 30000);
      pager.stdin.write(content);
      pager.stdin.end();
      pager.on("close", (code2) => {
        clearTimeout(timeout);
        resolve11(code2 === 0);
      });
      pager.on("error", () => {
        clearTimeout(timeout);
        resolve11(false);
      });
    } catch {
      resolve11(false);
    }
  });
}
async function basicPager(content) {
  const lines = content.split(`
`);
  const termHeight = getTerminalHeight();
  const pageSize = termHeight - 1;
  let currentLine = 0;
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  rl.on("SIGINT", () => {
    rl.close();
    process.exitCode = 0;
  });
  while (currentLine < lines.length) {
    const pageLines = lines.slice(currentLine, currentLine + pageSize);
    console.log(pageLines.join(`
`));
    currentLine += pageSize;
    if (currentLine >= lines.length) {
      break;
    }
    const remaining = lines.length - currentLine;
    await new Promise((resolve11) => {
      rl.question(`-- More (${remaining} lines) [Enter/q] --`, (answer) => {
        if (answer.toLowerCase() === "q") {
          rl.close();
          process.exitCode = 0;
          resolve11();
          return;
        }
        process.stdout.write("\x1B[1A\x1B[2K");
        resolve11();
      });
    });
  }
  rl.close();
}
async function displayHelp(content, options) {
  if (!shouldUsePager(content, options)) {
    console.log(content);
    return;
  }
  const pagerSuccess = await trySystemPager(content);
  if (pagerSuccess) {
    return;
  }
  try {
    await basicPager(content);
  } catch {
    console.log(content);
  }
}
var init_help_interactive = __esm(() => {
  init_help_colors();
});

// src/domains/help/help-banner.ts
function getBanner() {
  return BANNER_LINES.map((line) => defaultTheme.banner(line)).join(`
`);
}
var BANNER_LINES;
var init_help_banner = __esm(() => {
  init_help_colors();
  BANNER_LINES = [
    "   ",
    " ",
    "      ",
    "      ",
    "  ",
    "   "
  ];
});

// src/domains/help/help-renderer.ts
function renderBanner(options) {
  if (!options.showBanner)
    return "";
  return `${getBanner()}

`;
}
function renderCommandHeader(help, theme) {
  const parts = [theme.command(help.name), theme.muted("-"), theme.description(help.description)];
  if (help.aliases?.length) {
    const aliasText = theme.muted(`(alias: ${help.aliases.join(", ")})`);
    parts.push(aliasText);
  }
  return parts.join(" ");
}
function renderUsage(help, theme) {
  return [theme.heading("Usage:"), `  ${theme.example(help.usage)}`, ""].join(`
`);
}
function renderExamples(help, options) {
  if (!options.showExamples || help.examples.length === 0)
    return "";
  const theme = options.theme;
  const examples = help.examples.slice(0, options.maxExamples);
  const lines = [theme.heading("Examples:")];
  for (const example of examples) {
    lines.push(`  ${theme.example(example.command)}`);
    lines.push(`    ${theme.description(example.description)}`);
    lines.push("");
  }
  return lines.join(`
`);
}
function renderOptionGroup(group, theme) {
  const lines = [];
  lines.push(theme.heading(`${group.title}:`));
  const maxFlagWidth = Math.max(...group.options.map((opt) => opt.flags.length));
  for (const opt of group.options) {
    const flagsPart = `  ${padEnd(theme.flag(opt.flags), maxFlagWidth + 4)}`;
    if (opt.deprecated) {
      const warning = theme.warning(`[DEPRECATED: ${opt.deprecated.message}]`);
      lines.push(`${flagsPart}${warning}`);
      lines.push(`      Use: ${theme.example(opt.deprecated.alternative)}`);
    } else {
      lines.push(`${flagsPart}${theme.description(opt.description)}`);
      if (opt.defaultValue) {
        lines.push(`      ${theme.muted(`(default: ${opt.defaultValue})`)}`);
      }
    }
  }
  lines.push("");
  return lines;
}
function renderOptionGroups(help, theme) {
  if (help.optionGroups.length === 0)
    return "";
  const lines = [];
  for (const group of help.optionGroups) {
    lines.push(...renderOptionGroup(group, theme));
  }
  return lines.join(`
`);
}
function renderSections(help, theme) {
  if (!help.sections || help.sections.length === 0)
    return "";
  const lines = [];
  for (const section of help.sections) {
    lines.push(theme.heading(`${section.title}:`));
    const contentLines = section.content.split(`
`);
    for (const line of contentLines) {
      lines.push(`  ${theme.description(line)}`);
    }
    lines.push("");
  }
  return lines.join(`
`);
}
function renderDeprecationWarning(help, theme) {
  if (!help.deprecated)
    return "";
  return [
    theme.warning(`  DEPRECATED: ${help.deprecated.message}`),
    `   Use: ${theme.example(help.deprecated.alternative)}`,
    help.deprecated.removeInVersion ? theme.muted(`   Will be removed in ${help.deprecated.removeInVersion}`) : "",
    ""
  ].filter(Boolean).join(`
`);
}
function renderHelp(help, context = { globalHelp: false, options: DEFAULT_HELP_OPTIONS }) {
  const options = { ...DEFAULT_HELP_OPTIONS, ...context.options };
  const theme = options.theme;
  const sections = [
    renderBanner(options),
    renderDeprecationWarning(help, theme),
    renderCommandHeader(help, theme),
    "",
    renderUsage(help, theme),
    renderExamples(help, options),
    renderOptionGroups(help, theme),
    renderSections(help, theme)
  ];
  return sections.filter((s) => s !== undefined && s !== "").join(`
`);
}
function renderGlobalHelp(commands, options = DEFAULT_HELP_OPTIONS) {
  const theme = options.theme;
  const lines = [
    renderBanner(options),
    theme.heading("ClaudeKit CLI"),
    theme.description("Bootstrap and manage ClaudeKit projects"),
    "",
    theme.heading("Commands:")
  ];
  const commandNames = Object.keys(commands);
  const maxNameWidth = Math.max(...commandNames.map((n) => n.length));
  const sortedCommands = Object.entries(commands).sort(([a3], [b3]) => a3.localeCompare(b3));
  for (const [name2, help] of sortedCommands) {
    const cmdPart = `  ${padEnd(theme.command(name2), maxNameWidth + 4)}`;
    const descPart = theme.description(help.description);
    lines.push(`${cmdPart}${descPart}`);
  }
  lines.push("");
  lines.push(theme.heading("Global Options:"));
  lines.push(`  ${padEnd(theme.flag("--verbose"), 20)}${theme.description("Enable verbose logging")}`);
  lines.push(`  ${padEnd(theme.flag("--log-file <path>"), 20)}${theme.description("Write logs to file")}`);
  lines.push(`  ${padEnd(theme.flag("-V, --version"), 20)}${theme.description("Display version number")}`);
  lines.push(`  ${padEnd(theme.flag("-h, --help"), 20)}${theme.description("Display help information")}`);
  lines.push("");
  lines.push(theme.heading("Authentication:"));
  lines.push(`  ${padEnd(theme.flag("--use-git"), 20)}${theme.description("Use git clone (SSH/HTTPS) instead of API")}`);
  lines.push(`  ${padEnd(theme.flag("GITHUB_TOKEN"), 20)}${theme.description("Environment variable for Classic PAT")}`);
  lines.push(`  ${padEnd(theme.flag("gh auth login"), 20)}${theme.description("GitHub CLI authentication (default)")}`);
  lines.push("");
  lines.push(theme.muted("Run 'ck <command> --help' for detailed command information"));
  return lines.filter((s) => s !== undefined).join(`
`);
}
var DEFAULT_HELP_OPTIONS;
var init_help_renderer = __esm(() => {
  init_help_banner();
  init_help_colors();
  DEFAULT_HELP_OPTIONS = {
    showBanner: true,
    showExamples: true,
    maxExamples: 2,
    interactive: false,
    width: process.stdout.columns || 80,
    theme: defaultTheme,
    noColor: process.env.NO_COLOR !== undefined
  };
});

// src/domains/help/help-interceptor.ts
var exports_help_interceptor = {};
__export(exports_help_interceptor, {
  isHelpRequested: () => isHelpRequested,
  handleHelp: () => handleHelp
});
function getHelpOptions() {
  const isTTY2 = process.stdout.isTTY ?? false;
  const width = process.stdout.columns || 80;
  const noColor = process.env.NO_COLOR !== undefined || !isTTY2;
  return {
    ...DEFAULT_HELP_OPTIONS,
    showBanner: isTTY2,
    showExamples: true,
    maxExamples: 2,
    interactive: isTTY2,
    width,
    noColor
  };
}
function getCommandFromArgv() {
  const argv = process.argv.slice(2);
  for (const arg of argv) {
    if (arg.startsWith("-")) {
      continue;
    }
    if (hasCommand(arg)) {
      return arg;
    }
    return null;
  }
  return null;
}
async function handleHelp(_args) {
  try {
    const options = getHelpOptions();
    const command = getCommandFromArgv();
    let output3;
    if (command === null) {
      output3 = renderGlobalHelp(HELP_REGISTRY, options);
    } else {
      const help = HELP_REGISTRY[command];
      output3 = renderHelp(help, {
        command,
        globalHelp: false,
        options
      });
    }
    await displayHelp(output3, options);
  } catch (error) {
    console.error("Error rendering help:", error);
    return;
  }
  process.exitCode = 0;
}
function isHelpRequested(argv) {
  return argv.includes("--help") || argv.includes("-h");
}
var init_help_interceptor = __esm(() => {
  init_help_commands();
  init_help_interactive();
  init_help_renderer();
});

// node_modules/cac/dist/index.mjs
import { EventEmitter } from "events";
function toArr(any) {
  return any == null ? [] : Array.isArray(any) ? any : [any];
}
function toVal(out, key, val, opts) {
  var x, old = out[key], nxt = ~opts.string.indexOf(key) ? val == null || val === true ? "" : String(val) : typeof val === "boolean" ? val : ~opts.boolean.indexOf(key) ? val === "false" ? false : val === "true" || (out._.push((x = +val, x * 0 === 0) ? x : val), !!val) : (x = +val, x * 0 === 0) ? x : val;
  out[key] = old == null ? nxt : Array.isArray(old) ? old.concat(nxt) : [old, nxt];
}
function mri2(args, opts) {
  args = args || [];
  opts = opts || {};
  var k, arr, arg, name, val, out = { _: [] };
  var i = 0, j = 0, idx = 0, len = args.length;
  const alibi = opts.alias !== undefined;
  const strict = opts.unknown !== undefined;
  const defaults = opts.default !== undefined;
  opts.alias = opts.alias || {};
  opts.string = toArr(opts.string);
  opts.boolean = toArr(opts.boolean);
  if (alibi) {
    for (k in opts.alias) {
      arr = opts.alias[k] = toArr(opts.alias[k]);
      for (i = 0;i < arr.length; i++) {
        (opts.alias[arr[i]] = arr.concat(k)).splice(i, 1);
      }
    }
  }
  for (i = opts.boolean.length;i-- > 0; ) {
    arr = opts.alias[opts.boolean[i]] || [];
    for (j = arr.length;j-- > 0; )
      opts.boolean.push(arr[j]);
  }
  for (i = opts.string.length;i-- > 0; ) {
    arr = opts.alias[opts.string[i]] || [];
    for (j = arr.length;j-- > 0; )
      opts.string.push(arr[j]);
  }
  if (defaults) {
    for (k in opts.default) {
      name = typeof opts.default[k];
      arr = opts.alias[k] = opts.alias[k] || [];
      if (opts[name] !== undefined) {
        opts[name].push(k);
        for (i = 0;i < arr.length; i++) {
          opts[name].push(arr[i]);
        }
      }
    }
  }
  const keys = strict ? Object.keys(opts.alias) : [];
  for (i = 0;i < len; i++) {
    arg = args[i];
    if (arg === "--") {
      out._ = out._.concat(args.slice(++i));
      break;
    }
    for (j = 0;j < arg.length; j++) {
      if (arg.charCodeAt(j) !== 45)
        break;
    }
    if (j === 0) {
      out._.push(arg);
    } else if (arg.substring(j, j + 3) === "no-") {
      name = arg.substring(j + 3);
      if (strict && !~keys.indexOf(name)) {
        return opts.unknown(arg);
      }
      out[name] = false;
    } else {
      for (idx = j + 1;idx < arg.length; idx++) {
        if (arg.charCodeAt(idx) === 61)
          break;
      }
      name = arg.substring(j, idx);
      val = arg.substring(++idx) || (i + 1 === len || ("" + args[i + 1]).charCodeAt(0) === 45 || args[++i]);
      arr = j === 2 ? [name] : name;
      for (idx = 0;idx < arr.length; idx++) {
        name = arr[idx];
        if (strict && !~keys.indexOf(name))
          return opts.unknown("-".repeat(j) + name);
        toVal(out, name, idx + 1 < arr.length || val, opts);
      }
    }
  }
  if (defaults) {
    for (k in opts.default) {
      if (out[k] === undefined) {
        out[k] = opts.default[k];
      }
    }
  }
  if (alibi) {
    for (k in out) {
      arr = opts.alias[k] || [];
      while (arr.length > 0) {
        out[arr.shift()] = out[k];
      }
    }
  }
  return out;
}
var removeBrackets = (v) => v.replace(/[<[].+/, "").trim();
var findAllBrackets = (v) => {
  const ANGLED_BRACKET_RE_GLOBAL = /<([^>]+)>/g;
  const SQUARE_BRACKET_RE_GLOBAL = /\[([^\]]+)\]/g;
  const res = [];
  const parse = (match) => {
    let variadic = false;
    let value = match[1];
    if (value.startsWith("...")) {
      value = value.slice(3);
      variadic = true;
    }
    return {
      required: match[0].startsWith("<"),
      value,
      variadic
    };
  };
  let angledMatch;
  while (angledMatch = ANGLED_BRACKET_RE_GLOBAL.exec(v)) {
    res.push(parse(angledMatch));
  }
  let squareMatch;
  while (squareMatch = SQUARE_BRACKET_RE_GLOBAL.exec(v)) {
    res.push(parse(squareMatch));
  }
  return res;
};
var getMriOptions = (options) => {
  const result = { alias: {}, boolean: [] };
  for (const [index, option] of options.entries()) {
    if (option.names.length > 1) {
      result.alias[option.names[0]] = option.names.slice(1);
    }
    if (option.isBoolean) {
      if (option.negated) {
        const hasStringTypeOption = options.some((o, i) => {
          return i !== index && o.names.some((name) => option.names.includes(name)) && typeof o.required === "boolean";
        });
        if (!hasStringTypeOption) {
          result.boolean.push(option.names[0]);
        }
      } else {
        result.boolean.push(option.names[0]);
      }
    }
  }
  return result;
};
var findLongest = (arr) => {
  return arr.sort((a, b) => {
    return a.length > b.length ? -1 : 1;
  })[0];
};
var padRight = (str, length) => {
  return str.length >= length ? str : `${str}${" ".repeat(length - str.length)}`;
};
var camelcase = (input) => {
  return input.replace(/([a-z])-([a-z])/g, (_, p1, p2) => {
    return p1 + p2.toUpperCase();
  });
};
var setDotProp = (obj, keys, val) => {
  let i = 0;
  let length = keys.length;
  let t = obj;
  let x;
  for (;i < length; ++i) {
    x = t[keys[i]];
    t = t[keys[i]] = i === length - 1 ? val : x != null ? x : !!~keys[i + 1].indexOf(".") || !(+keys[i + 1] > -1) ? {} : [];
  }
};
var setByType = (obj, transforms) => {
  for (const key of Object.keys(transforms)) {
    const transform = transforms[key];
    if (transform.shouldTransform) {
      obj[key] = Array.prototype.concat.call([], obj[key]);
      if (typeof transform.transformFunction === "function") {
        obj[key] = obj[key].map(transform.transformFunction);
      }
    }
  }
};
var getFileName = (input) => {
  const m = /([^\\\/]+)$/.exec(input);
  return m ? m[1] : "";
};
var camelcaseOptionName = (name) => {
  return name.split(".").map((v, i) => {
    return i === 0 ? camelcase(v) : v;
  }).join(".");
};

class CACError extends Error {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error(message).stack;
    }
  }
}

class Option {
  constructor(rawName, description, config) {
    this.rawName = rawName;
    this.description = description;
    this.config = Object.assign({}, config);
    rawName = rawName.replace(/\.\*/g, "");
    this.negated = false;
    this.names = removeBrackets(rawName).split(",").map((v) => {
      let name = v.trim().replace(/^-{1,2}/, "");
      if (name.startsWith("no-")) {
        this.negated = true;
        name = name.replace(/^no-/, "");
      }
      return camelcaseOptionName(name);
    }).sort((a, b) => a.length > b.length ? 1 : -1);
    this.name = this.names[this.names.length - 1];
    if (this.negated && this.config.default == null) {
      this.config.default = true;
    }
    if (rawName.includes("<")) {
      this.required = true;
    } else if (rawName.includes("[")) {
      this.required = false;
    } else {
      this.isBoolean = true;
    }
  }
}
var processArgs = process.argv;
var platformInfo = `${process.platform}-${process.arch} node-${process.version}`;

class Command {
  constructor(rawName, description, config = {}, cli) {
    this.rawName = rawName;
    this.description = description;
    this.config = config;
    this.cli = cli;
    this.options = [];
    this.aliasNames = [];
    this.name = removeBrackets(rawName);
    this.args = findAllBrackets(rawName);
    this.examples = [];
  }
  usage(text) {
    this.usageText = text;
    return this;
  }
  allowUnknownOptions() {
    this.config.allowUnknownOptions = true;
    return this;
  }
  ignoreOptionDefaultValue() {
    this.config.ignoreOptionDefaultValue = true;
    return this;
  }
  version(version, customFlags = "-v, --version") {
    this.versionNumber = version;
    this.option(customFlags, "Display version number");
    return this;
  }
  example(example) {
    this.examples.push(example);
    return this;
  }
  option(rawName, description, config) {
    const option = new Option(rawName, description, config);
    this.options.push(option);
    return this;
  }
  alias(name) {
    this.aliasNames.push(name);
    return this;
  }
  action(callback) {
    this.commandAction = callback;
    return this;
  }
  isMatched(name) {
    return this.name === name || this.aliasNames.includes(name);
  }
  get isDefaultCommand() {
    return this.name === "" || this.aliasNames.includes("!");
  }
  get isGlobalCommand() {
    return this instanceof GlobalCommand;
  }
  hasOption(name) {
    name = name.split(".")[0];
    return this.options.find((option) => {
      return option.names.includes(name);
    });
  }
  outputHelp() {
    const { name, commands } = this.cli;
    const {
      versionNumber,
      options: globalOptions,
      helpCallback
    } = this.cli.globalCommand;
    let sections = [
      {
        body: `${name}${versionNumber ? `/${versionNumber}` : ""}`
      }
    ];
    sections.push({
      title: "Usage",
      body: `  $ ${name} ${this.usageText || this.rawName}`
    });
    const showCommands = (this.isGlobalCommand || this.isDefaultCommand) && commands.length > 0;
    if (showCommands) {
      const longestCommandName = findLongest(commands.map((command) => command.rawName));
      sections.push({
        title: "Commands",
        body: commands.map((command) => {
          return `  ${padRight(command.rawName, longestCommandName.length)}  ${command.description}`;
        }).join(`
`)
      });
      sections.push({
        title: `For more info, run any command with the \`--help\` flag`,
        body: commands.map((command) => `  $ ${name}${command.name === "" ? "" : ` ${command.name}`} --help`).join(`
`)
      });
    }
    let options = this.isGlobalCommand ? globalOptions : [...this.options, ...globalOptions || []];
    if (!this.isGlobalCommand && !this.isDefaultCommand) {
      options = options.filter((option) => option.name !== "version");
    }
    if (options.length > 0) {
      const longestOptionName = findLongest(options.map((option) => option.rawName));
      sections.push({
        title: "Options",
        body: options.map((option) => {
          return `  ${padRight(option.rawName, longestOptionName.length)}  ${option.description} ${option.config.default === undefined ? "" : `(default: ${option.config.default})`}`;
        }).join(`
`)
      });
    }
    if (this.examples.length > 0) {
      sections.push({
        title: "Examples",
        body: this.examples.map((example) => {
          if (typeof example === "function") {
            return example(name);
          }
          return example;
        }).join(`
`)
      });
    }
    if (helpCallback) {
      sections = helpCallback(sections) || sections;
    }
    console.log(sections.map((section) => {
      return section.title ? `${section.title}:
${section.body}` : section.body;
    }).join(`

`));
  }
  outputVersion() {
    const { name } = this.cli;
    const { versionNumber } = this.cli.globalCommand;
    if (versionNumber) {
      console.log(`${name}/${versionNumber} ${platformInfo}`);
    }
  }
  checkRequiredArgs() {
    const minimalArgsCount = this.args.filter((arg) => arg.required).length;
    if (this.cli.args.length < minimalArgsCount) {
      throw new CACError(`missing required args for command \`${this.rawName}\``);
    }
  }
  checkUnknownOptions() {
    const { options, globalCommand } = this.cli;
    if (!this.config.allowUnknownOptions) {
      for (const name of Object.keys(options)) {
        if (name !== "--" && !this.hasOption(name) && !globalCommand.hasOption(name)) {
          throw new CACError(`Unknown option \`${name.length > 1 ? `--${name}` : `-${name}`}\``);
        }
      }
    }
  }
  checkOptionValue() {
    const { options: parsedOptions, globalCommand } = this.cli;
    const options = [...globalCommand.options, ...this.options];
    for (const option of options) {
      const value = parsedOptions[option.name.split(".")[0]];
      if (option.required) {
        const hasNegated = options.some((o) => o.negated && o.names.includes(option.name));
        if (value === true || value === false && !hasNegated) {
          throw new CACError(`option \`${option.rawName}\` value is missing`);
        }
      }
    }
  }
}

class GlobalCommand extends Command {
  constructor(cli) {
    super("@@global@@", "", {}, cli);
  }
}
var __assign = Object.assign;

class CAC extends EventEmitter {
  constructor(name = "") {
    super();
    this.name = name;
    this.commands = [];
    this.rawArgs = [];
    this.args = [];
    this.options = {};
    this.globalCommand = new GlobalCommand(this);
    this.globalCommand.usage("<command> [options]");
  }
  usage(text) {
    this.globalCommand.usage(text);
    return this;
  }
  command(rawName, description, config) {
    const command = new Command(rawName, description || "", config, this);
    command.globalCommand = this.globalCommand;
    this.commands.push(command);
    return command;
  }
  option(rawName, description, config) {
    this.globalCommand.option(rawName, description, config);
    return this;
  }
  help(callback) {
    this.globalCommand.option("-h, --help", "Display this message");
    this.globalCommand.helpCallback = callback;
    this.showHelpOnExit = true;
    return this;
  }
  version(version, customFlags = "-v, --version") {
    this.globalCommand.version(version, customFlags);
    this.showVersionOnExit = true;
    return this;
  }
  example(example) {
    this.globalCommand.example(example);
    return this;
  }
  outputHelp() {
    if (this.matchedCommand) {
      this.matchedCommand.outputHelp();
    } else {
      this.globalCommand.outputHelp();
    }
  }
  outputVersion() {
    this.globalCommand.outputVersion();
  }
  setParsedInfo({ args, options }, matchedCommand, matchedCommandName) {
    this.args = args;
    this.options = options;
    if (matchedCommand) {
      this.matchedCommand = matchedCommand;
    }
    if (matchedCommandName) {
      this.matchedCommandName = matchedCommandName;
    }
    return this;
  }
  unsetMatchedCommand() {
    this.matchedCommand = undefined;
    this.matchedCommandName = undefined;
  }
  parse(argv = processArgs, {
    run = true
  } = {}) {
    this.rawArgs = argv;
    if (!this.name) {
      this.name = argv[1] ? getFileName(argv[1]) : "cli";
    }
    let shouldParse = true;
    for (const command of this.commands) {
      const parsed = this.mri(argv.slice(2), command);
      const commandName = parsed.args[0];
      if (command.isMatched(commandName)) {
        shouldParse = false;
        const parsedInfo = __assign(__assign({}, parsed), {
          args: parsed.args.slice(1)
        });
        this.setParsedInfo(parsedInfo, command, commandName);
        this.emit(`command:${commandName}`, command);
      }
    }
    if (shouldParse) {
      for (const command of this.commands) {
        if (command.name === "") {
          shouldParse = false;
          const parsed = this.mri(argv.slice(2), command);
          this.setParsedInfo(parsed, command);
          this.emit(`command:!`, command);
        }
      }
    }
    if (shouldParse) {
      const parsed = this.mri(argv.slice(2));
      this.setParsedInfo(parsed);
    }
    if (this.options.help && this.showHelpOnExit) {
      this.outputHelp();
      run = false;
      this.unsetMatchedCommand();
    }
    if (this.options.version && this.showVersionOnExit && this.matchedCommandName == null) {
      this.outputVersion();
      run = false;
      this.unsetMatchedCommand();
    }
    const parsedArgv = { args: this.args, options: this.options };
    if (run) {
      this.runMatchedCommand();
    }
    if (!this.matchedCommand && this.args[0]) {
      this.emit("command:*");
    }
    return parsedArgv;
  }
  mri(argv, command) {
    const cliOptions = [
      ...this.globalCommand.options,
      ...command ? command.options : []
    ];
    const mriOptions = getMriOptions(cliOptions);
    let argsAfterDoubleDashes = [];
    const doubleDashesIndex = argv.indexOf("--");
    if (doubleDashesIndex > -1) {
      argsAfterDoubleDashes = argv.slice(doubleDashesIndex + 1);
      argv = argv.slice(0, doubleDashesIndex);
    }
    let parsed = mri2(argv, mriOptions);
    parsed = Object.keys(parsed).reduce((res, name) => {
      return __assign(__assign({}, res), {
        [camelcaseOptionName(name)]: parsed[name]
      });
    }, { _: [] });
    const args = parsed._;
    const options = {
      "--": argsAfterDoubleDashes
    };
    const ignoreDefault = command && command.config.ignoreOptionDefaultValue ? command.config.ignoreOptionDefaultValue : this.globalCommand.config.ignoreOptionDefaultValue;
    let transforms = Object.create(null);
    for (const cliOption of cliOptions) {
      if (!ignoreDefault && cliOption.config.default !== undefined) {
        for (const name of cliOption.names) {
          options[name] = cliOption.config.default;
        }
      }
      if (Array.isArray(cliOption.config.type)) {
        if (transforms[cliOption.name] === undefined) {
          transforms[cliOption.name] = Object.create(null);
          transforms[cliOption.name]["shouldTransform"] = true;
          transforms[cliOption.name]["transformFunction"] = cliOption.config.type[0];
        }
      }
    }
    for (const key of Object.keys(parsed)) {
      if (key !== "_") {
        const keys = key.split(".");
        setDotProp(options, keys, parsed[key]);
        setByType(options, transforms);
      }
    }
    return {
      args,
      options
    };
  }
  runMatchedCommand() {
    const { args, options, matchedCommand: command } = this;
    if (!command || !command.commandAction)
      return;
    command.checkUnknownOptions();
    command.checkOptionValue();
    command.checkRequiredArgs();
    const actionArgs = [];
    command.args.forEach((arg, index) => {
      if (arg.variadic) {
        actionArgs.push(args.slice(index));
      } else {
        actionArgs.push(args[index]);
      }
    });
    actionArgs.push(options);
    return command.commandAction.apply(this, actionArgs);
  }
}
var cac = (name = "") => new CAC(name);

// src/cli/cli-config.ts
function createCliInstance() {
  const cli = cac("ck");
  cli.option("--verbose", "Enable verbose logging for debugging");
  cli.option("--json", "Output machine-readable JSON format");
  cli.option("--log-file <path>", "Write logs to file");
  return cli;
}
function registerGlobalFlags(cli) {
  cli.option("-V, --version", "Display version number");
  cli.option("-h, --help", "Display help information");
}

// src/domains/health-checks/types.ts
init_zod();
var CheckStatusSchema = exports_external.enum(["pass", "warn", "fail", "info"]);
var CheckPrioritySchema = exports_external.enum(["critical", "standard", "extended"]);
var CheckGroupSchema = exports_external.enum(["system", "claudekit", "auth", "platform", "network"]);
var FixResultSchema = exports_external.object({
  success: exports_external.boolean(),
  message: exports_external.string(),
  details: exports_external.string().optional()
});
var CheckResultSchema = exports_external.object({
  id: exports_external.string().min(1),
  name: exports_external.string().min(1),
  group: CheckGroupSchema,
  priority: CheckPrioritySchema.optional().default("standard"),
  status: CheckStatusSchema,
  message: exports_external.string(),
  details: exports_external.string().optional(),
  suggestion: exports_external.string().optional(),
  autoFixable: exports_external.boolean(),
  fixed: exports_external.boolean().optional(),
  fixError: exports_external.string().optional()
});
var CheckRunnerOptionsSchema = exports_external.object({
  fix: exports_external.boolean().optional(),
  checkOnly: exports_external.boolean().optional(),
  json: exports_external.boolean().optional(),
  groups: exports_external.array(CheckGroupSchema).optional(),
  verbose: exports_external.boolean().optional(),
  full: exports_external.boolean().optional()
});
var CheckSummarySchema = exports_external.object({
  timestamp: exports_external.string().datetime(),
  total: exports_external.number().int().nonnegative(),
  passed: exports_external.number().int().nonnegative(),
  warnings: exports_external.number().int().nonnegative(),
  failed: exports_external.number().int().nonnegative(),
  fixed: exports_external.number().int().nonnegative(),
  checks: exports_external.array(CheckResultSchema)
});
var FixAttemptSchema = exports_external.object({
  checkId: exports_external.string().min(1),
  checkName: exports_external.string().min(1),
  fixId: exports_external.string().min(1),
  success: exports_external.boolean(),
  message: exports_external.string(),
  error: exports_external.string().optional(),
  duration: exports_external.number().nonnegative()
});
var HealingSummarySchema = exports_external.object({
  totalFixable: exports_external.number().int().nonnegative(),
  attempted: exports_external.number().int().nonnegative(),
  succeeded: exports_external.number().int().nonnegative(),
  failed: exports_external.number().int().nonnegative(),
  fixes: exports_external.array(FixAttemptSchema)
});
// src/domains/health-checks/check-runner.ts
init_logger();

class CheckRunner {
  checkers = [];
  options;
  constructor(options = {}) {
    this.options = options;
    logger.verbose("CheckRunner initialized", { options });
  }
  registerChecker(checker) {
    this.checkers.push(checker);
  }
  registerCheckers(checkers) {
    for (const checker of checkers) {
      this.registerChecker(checker);
    }
  }
  async run() {
    logger.verbose("Starting health check run");
    const filteredCheckers = this.filterCheckersByGroup();
    logger.verbose(`Running ${filteredCheckers.length} checker(s)`, {
      groups: filteredCheckers.map((c) => c.group)
    });
    const allResults = await this.executeCheckersInParallel(filteredCheckers);
    const filteredResults = this.filterChecksByPriority(allResults);
    logger.verbose("All checks completed, building summary");
    return this.buildSummary(filteredResults);
  }
  filterCheckersByGroup() {
    if (!this.options.groups || this.options.groups.length === 0) {
      return this.checkers;
    }
    const allowedGroups = new Set(this.options.groups);
    return this.checkers.filter((checker) => allowedGroups.has(checker.group));
  }
  filterChecksByPriority(checks) {
    const includedPriorities = new Set(["critical", "standard"]);
    if (this.options.full) {
      includedPriorities.add("extended");
    }
    return checks.filter((check) => {
      const priority = check.priority ?? "standard";
      return includedPriorities.has(priority);
    });
  }
  async executeCheckersInParallel(checkers) {
    const resultsArrays = await Promise.all(checkers.map(async (checker) => {
      logger.verbose(`Starting checker: ${checker.group}`);
      const results = await checker.run();
      logger.verbose(`Completed checker: ${checker.group}`, {
        checkCount: results.length
      });
      return results;
    }));
    return resultsArrays.flat();
  }
  buildSummary(checks) {
    let passed = 0;
    let warnings = 0;
    let failed = 0;
    let fixed = 0;
    for (const check of checks) {
      switch (check.status) {
        case "pass":
          passed++;
          break;
        case "warn":
          warnings++;
          break;
        case "fail":
          failed++;
          break;
      }
      if (check.fixed) {
        fixed++;
      }
    }
    return {
      timestamp: new Date().toISOString(),
      total: checks.length,
      passed,
      warnings,
      failed,
      fixed,
      checks
    };
  }
  getOptions() {
    return { ...this.options };
  }
  getCheckers() {
    return [...this.checkers];
  }
}
// src/domains/health-checks/system-checker.ts
import { exec as exec4 } from "node:child_process";
import { promisify as promisify4 } from "node:util";

// src/domains/github/gh-cli-utils.ts
init_logger();
import { readFileSync } from "node:fs";
var MIN_GH_CLI_VERSION = "2.20.0";
var GH_COMMAND_TIMEOUT_MS = 1e4;
function compareVersions(a, b) {
  const partsA = a.split(".").map(Number);
  const partsB = b.split(".").map(Number);
  const maxLen = Math.max(partsA.length, partsB.length);
  for (let i = 0;i < maxLen; i++) {
    const numA = partsA[i] ?? 0;
    const numB = partsB[i] ?? 0;
    if (numA < numB)
      return -1;
    if (numA > numB)
      return 1;
  }
  return 0;
}
function isWSL() {
  if (process.platform !== "linux")
    return false;
  try {
    const release = readFileSync("/proc/version", "utf-8").toLowerCase();
    return release.includes("microsoft") || release.includes("wsl");
  } catch (error) {
    logger.debug(`WSL detection skipped: ${error instanceof Error ? error.message : "unknown error"}`);
    return false;
  }
}
function shouldSkipExpensiveOperations() {
  if (process.env.CK_TEST_HOME) {
    return false;
  }
  return process.env.CI === "true" || process.env.CI_SAFE_MODE === "true";
}
function getGhUpgradeInstructions(currentVersion) {
  const platform = process.platform;
  const wsl = isWSL();
  const lines = [];
  lines.push(` GitHub CLI v${currentVersion} is outdated`);
  lines.push(`  Minimum required: v${MIN_GH_CLI_VERSION}`);
  lines.push("");
  if (wsl) {
    lines.push("Upgrade GitHub CLI (WSL/Ubuntu):");
    lines.push("  curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg");
    lines.push('  echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null');
    lines.push("  sudo apt update && sudo apt install gh");
  } else if (platform === "darwin") {
    lines.push("Upgrade GitHub CLI:");
    lines.push("  brew upgrade gh");
  } else if (platform === "win32") {
    lines.push("Upgrade GitHub CLI:");
    lines.push("  winget upgrade GitHub.cli");
  } else {
    lines.push("Upgrade GitHub CLI:");
    lines.push("  sudo apt update && sudo apt upgrade gh");
    lines.push("  Or visit: https://cli.github.com");
  }
  lines.push("");
  lines.push("After upgrade: gh auth login -h github.com");
  return lines;
}

// src/services/package-installer/dependency-checker.ts
import { exec } from "node:child_process";
import { promisify } from "node:util";

// src/shared/error-utils.ts
function operationError(operation, subject, details) {
  return `${operation} failed for '${subject}': ${details}`;
}
function notFoundError(type, name, hint) {
  return hint ? `${type} not found: ${name} (${hint})` : `${type} not found: ${name}`;
}

// src/services/package-installer/dependency-checker.ts
init_logger();
var execAsync = promisify(exec);
function shouldSkipExpensiveOperations2() {
  if (process.env.CK_TEST_HOME) {
    return false;
  }
  return process.env.CI === "true" || process.env.CI_SAFE_MODE === "true";
}
function getOSInfo() {
  const platform = process.platform;
  const arch = process.arch;
  const isWindows = platform === "win32";
  const isMacOS = platform === "darwin";
  const isLinux = platform === "linux";
  const isWSL2 = isLinux && process.env.WSL_DISTRO_NAME !== undefined;
  let details = `${platform}-${arch}`;
  if (isWSL2) {
    details += ` (WSL: ${process.env.WSL_DISTRO_NAME})`;
  }
  return {
    platform,
    arch,
    isWindows,
    isMacOS,
    isLinux,
    isWSL: isWSL2,
    details
  };
}
function getCICommandPath(command) {
  const osInfo = getOSInfo();
  switch (command) {
    case "node":
      if (osInfo.isWindows) {
        return process.env.NODE_PATH ? `${process.env.NODE_PATH}\\node.exe` : "C:\\Program Files\\nodejs\\node.exe";
      }
      return "/usr/bin/node";
    case "python3":
    case "python":
      if (osInfo.isWindows) {
        const pythonDir = process.env.PYTHON;
        if (pythonDir) {
          return `${pythonDir}\\python.exe`;
        }
        return "C:\\Windows\\py.exe";
      }
      return "/usr/bin/python3";
    case "pip3":
    case "pip":
      if (osInfo.isWindows) {
        const pythonDir = process.env.PYTHON;
        if (pythonDir) {
          return `${pythonDir}\\Scripts\\pip.exe`;
        }
        return "C:\\Windows\\py.exe -m pip";
      }
      return "/usr/bin/pip3";
    default:
      return null;
  }
}
var DEPENDENCIES = {
  claude: {
    name: "claude",
    commands: ["claude"],
    versionFlag: "--version",
    versionRegex: /(\d+\.\d+\.\d+)/,
    minVersion: "1.0.0",
    required: false
  },
  python: {
    name: "python",
    commands: ["python3", "python"],
    versionFlag: "--version",
    versionRegex: /Python (\d+\.\d+\.\d+)/,
    minVersion: "3.8.0",
    required: true
  },
  pip: {
    name: "pip",
    commands: ["pip3", "pip"],
    versionFlag: "--version",
    versionRegex: /pip (\d+\.\d+\.\d+)/,
    minVersion: undefined,
    required: true
  },
  nodejs: {
    name: "nodejs",
    commands: ["node"],
    versionFlag: "--version",
    versionRegex: /v?(\d+\.\d+\.\d+)/,
    minVersion: "16.0.0",
    required: true
  }
};
async function commandExists(command) {
  if (shouldSkipExpensiveOperations2()) {
    const supportedCommands = ["node", "python", "python3", "pip", "pip3", "claude"];
    return supportedCommands.includes(command);
  }
  try {
    const whichCmd = process.platform === "win32" ? "where" : "which";
    logger.verbose(`Checking if command exists: ${command}`);
    await execAsync(`${whichCmd} ${command}`);
    logger.verbose(`Command found: ${command}`);
    return true;
  } catch {
    logger.verbose(`Command not found: ${command}`);
    return false;
  }
}
async function getCommandPath(command) {
  if (shouldSkipExpensiveOperations2()) {
    const ciPath = getCICommandPath(command);
    if (ciPath)
      return ciPath;
  }
  try {
    const whichCmd = process.platform === "win32" ? "where" : "which";
    logger.verbose(`Getting path for command: ${command}`);
    const { stdout } = await execAsync(`${whichCmd} ${command}`);
    const path = stdout.trim().split(`
`)[0] || null;
    logger.verbose(`Command path resolved: ${command} -> ${path}`);
    return path;
  } catch {
    logger.verbose(`Failed to get path for command: ${command}`);
    return null;
  }
}
async function getCommandVersion(command, versionFlag, versionRegex) {
  if (shouldSkipExpensiveOperations2()) {
    const mockVersions = {
      npm: "10.0.0",
      node: "20.0.0",
      python: "3.11.0",
      python3: "3.11.0",
      pip: "23.0.0",
      pip3: "23.0.0",
      claude: "1.0.0"
    };
    return mockVersions[command] || null;
  }
  try {
    logger.verbose(`Getting version for: ${command} ${versionFlag}`);
    const { stdout, stderr } = await execAsync(`${command} ${versionFlag}`);
    const output2 = stdout || stderr;
    const match = output2.match(versionRegex);
    const version = match?.[1] || null;
    logger.verbose(`Version detected: ${command} -> ${version}`);
    return version;
  } catch (error) {
    logger.verbose(`Failed to get version for ${command}: ${error}`);
    logger.debug(`Failed to get version for ${command}: ${error}`);
    return null;
  }
}
function compareVersions2(current, required) {
  const parseCurrent = current.split(".").map((n) => Number.parseInt(n, 10));
  const parseRequired = required.split(".").map((n) => Number.parseInt(n, 10));
  for (let i = 0;i < 3; i++) {
    const curr = parseCurrent[i] || 0;
    const req = parseRequired[i] || 0;
    if (curr > req)
      return true;
    if (curr < req)
      return false;
  }
  return true;
}
async function checkDependency(config) {
  logger.verbose(`Checking dependency: ${config.name}`);
  for (const command of config.commands) {
    const exists = await commandExists(command);
    if (exists) {
      logger.verbose(`Found ${config.name} via command: ${command}`);
      const path = await getCommandPath(command);
      const version = await getCommandVersion(command, config.versionFlag, config.versionRegex);
      let meetsRequirements = true;
      let message;
      if (config.minVersion && version) {
        meetsRequirements = compareVersions2(version, config.minVersion);
        if (!meetsRequirements) {
          message = `Version ${version} is below minimum ${config.minVersion}`;
        }
      }
      return {
        name: config.name,
        installed: true,
        version: version || undefined,
        path: path || undefined,
        minVersion: config.minVersion,
        meetsRequirements,
        message
      };
    }
  }
  return {
    name: config.name,
    installed: false,
    meetsRequirements: false,
    minVersion: config.minVersion,
    message: notFoundError(config.name, "PATH", "check installation")
  };
}
async function checkAllDependencies() {
  logger.verbose("Checking all dependencies in parallel");
  const checks = Object.values(DEPENDENCIES).map((config) => checkDependency(config));
  const results = await Promise.all(checks);
  logger.verbose("All dependency checks complete", {
    count: results.length
  });
  return results;
}

// src/services/package-installer/dependency-installer.ts
init_logger();
import { exec as exec3 } from "node:child_process";
import { promisify as promisify3 } from "node:util";

// src/services/package-installer/dependencies/node-installer.ts
var NODEJS_INSTALLERS = [
  {
    name: "Homebrew (macOS)",
    command: "brew install node",
    requiresSudo: false,
    platform: "darwin",
    priority: 1,
    description: "Install Node.js via Homebrew"
  },
  {
    name: "NodeSource (Debian/Ubuntu)",
    command: "curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash - && sudo apt-get install -y nodejs",
    requiresSudo: true,
    platform: "linux",
    priority: 1,
    description: "Install Node.js 20.x via NodeSource"
  },
  {
    name: "dnf (Fedora/RHEL)",
    command: "sudo dnf install -y nodejs npm",
    requiresSudo: true,
    platform: "linux",
    priority: 2,
    description: "Install Node.js via dnf"
  },
  {
    name: "pacman (Arch)",
    command: "sudo pacman -S --noconfirm nodejs npm",
    requiresSudo: true,
    platform: "linux",
    priority: 3,
    description: "Install Node.js via pacman"
  },
  {
    name: "winget (Windows)",
    command: "winget install OpenJS.NodeJS.LTS",
    requiresSudo: false,
    platform: "win32",
    priority: 1,
    description: "Install Node.js LTS via winget"
  }
];

// src/services/package-installer/dependencies/python-installer.ts
var PYTHON_INSTALLERS = [
  {
    name: "Homebrew (macOS)",
    command: "brew install python@3.12",
    requiresSudo: false,
    platform: "darwin",
    priority: 1,
    description: "Install Python 3.12 via Homebrew"
  },
  {
    name: "apt (Debian/Ubuntu)",
    command: "sudo apt update && sudo apt install -y python3 python3-pip",
    requiresSudo: true,
    platform: "linux",
    priority: 1,
    description: "Install Python via apt package manager"
  },
  {
    name: "dnf (Fedora/RHEL)",
    command: "sudo dnf install -y python3 python3-pip",
    requiresSudo: true,
    platform: "linux",
    priority: 2,
    description: "Install Python via dnf package manager"
  },
  {
    name: "pacman (Arch)",
    command: "sudo pacman -S --noconfirm python python-pip",
    requiresSudo: true,
    platform: "linux",
    priority: 3,
    description: "Install Python via pacman"
  },
  {
    name: "winget (Windows)",
    command: "winget install Python.Python.3.12",
    requiresSudo: false,
    platform: "win32",
    priority: 1,
    description: "Install Python 3.12 via winget"
  }
];

// src/services/package-installer/dependencies/system-installer.ts
init_logger();
import { exec as exec2 } from "node:child_process";
import * as fs from "node:fs";
import { promisify as promisify2 } from "node:util";
var execAsync2 = promisify2(exec2);
async function detectOS() {
  const platform = process.platform;
  const info = { platform };
  if (platform === "darwin") {
    try {
      await execAsync2("which brew");
      info.hasHomebrew = true;
    } catch {
      info.hasHomebrew = false;
    }
  } else if (platform === "linux") {
    try {
      if (fs.existsSync("/etc/os-release")) {
        const content = fs.readFileSync("/etc/os-release", "utf-8");
        const idMatch = content.match(/^ID=(.+)$/m);
        info.distro = idMatch?.[1]?.replace(/"/g, "");
      }
    } catch (error) {
      logger.debug(`Failed to detect Linux distro: ${error}`);
    }
    try {
      await execAsync2("which apt");
      info.hasApt = true;
    } catch {
      info.hasApt = false;
    }
    try {
      await execAsync2("which dnf");
      info.hasDnf = true;
    } catch {
      info.hasDnf = false;
    }
    try {
      await execAsync2("which pacman");
      info.hasPacman = true;
    } catch {
      info.hasPacman = false;
    }
  }
  return info;
}
var CLAUDE_INSTALLERS = [
  {
    name: "Homebrew (macOS)",
    command: "brew install --cask claude-code",
    requiresSudo: false,
    platform: "darwin",
    priority: 1,
    description: "Install via Homebrew (recommended for macOS)"
  },
  {
    name: "Installer Script (Linux)",
    command: "curl -fsSL https://claude.ai/install.sh | bash",
    requiresSudo: false,
    platform: "linux",
    priority: 1,
    description: "Install via official installer script"
  },
  {
    name: "PowerShell (Windows)",
    command: 'powershell -Command "irm https://claude.ai/install.ps1 | iex"',
    requiresSudo: false,
    platform: "win32",
    priority: 1,
    description: "Install via PowerShell script"
  }
];

// src/services/package-installer/dependency-installer.ts
var execAsync3 = promisify3(exec3);
function getInstallerMethods(dependency, osInfo) {
  let installers = dependency === "claude" ? CLAUDE_INSTALLERS : dependency === "python" || dependency === "pip" ? PYTHON_INSTALLERS : dependency === "nodejs" ? NODEJS_INSTALLERS : [];
  installers = installers.filter((m) => m.platform === osInfo.platform);
  if (osInfo.platform === "darwin" && !osInfo.hasHomebrew) {
    installers = installers.filter((m) => !m.command.includes("brew"));
  } else if (osInfo.platform === "linux") {
    if (!osInfo.hasApt)
      installers = installers.filter((m) => !m.command.includes("apt"));
    if (!osInfo.hasDnf)
      installers = installers.filter((m) => !m.command.includes("dnf"));
    if (!osInfo.hasPacman)
      installers = installers.filter((m) => !m.command.includes("pacman"));
  }
  return installers.sort((a, b) => a.priority - b.priority);
}
async function installDependency(dependency, method) {
  try {
    const osInfo = await detectOS();
    const methods = method ? [method] : getInstallerMethods(dependency, osInfo);
    if (methods.length === 0) {
      return {
        success: false,
        message: `No installation method available for ${dependency} on ${osInfo.platform}`
      };
    }
    const selectedMethod = methods[0];
    logger.info(`Installing ${dependency} using ${selectedMethod.name}...`);
    if (selectedMethod.requiresSudo)
      logger.info("  This installation requires sudo privileges");
    try {
      await execAsync3(selectedMethod.command);
    } catch (error) {
      throw new Error(`Installation command failed: ${error}`);
    }
    const config = DEPENDENCIES[dependency === "pip" ? "python" : dependency];
    const status = await checkDependency(config);
    return status.installed ? {
      success: true,
      message: `Successfully installed ${dependency}`,
      installedVersion: status.version
    } : {
      success: false,
      message: `Installation completed but ${dependency} is still not available`
    };
  } catch (error) {
    logger.debug(`Installation error: ${error}`);
    return {
      success: false,
      message: error instanceof Error ? error.message : "Unknown installation error"
    };
  }
}

// src/domains/health-checks/system-checker.ts
init_logger();
var execAsync4 = promisify4(exec4);

class SystemChecker {
  group = "system";
  async run() {
    logger.verbose("SystemChecker: Starting dependency checks");
    const deps = await checkAllDependencies();
    logger.verbose("SystemChecker: Dependency scan complete", {
      count: deps.length
    });
    const results = [];
    for (const dep of deps) {
      logger.verbose(`SystemChecker: Processing ${dep.name}`);
      results.push(await this.mapDependencyToCheck(dep));
    }
    if (!shouldSkipExpensiveOperations()) {
      logger.verbose("SystemChecker: Checking git");
      results.push(await this.checkGit());
      logger.verbose("SystemChecker: Checking GitHub CLI");
      results.push(await this.checkGitHubCli());
    } else {
      logger.verbose("SystemChecker: Skipping git/gh checks in CI");
      results.push(this.createCISkipResult("git-version", "Git"));
      results.push(this.createCISkipResult("gh-cli-version", "GitHub CLI"));
    }
    logger.verbose("SystemChecker: All system checks complete");
    return results;
  }
  createCISkipResult(id, name) {
    return {
      id,
      name,
      group: "system",
      status: "pass",
      message: "Skipped in CI",
      autoFixable: false
    };
  }
  async mapDependencyToCheck(dep) {
    const isInstalled = dep.installed && dep.meetsRequirements;
    const name = this.formatDependencyName(dep.name);
    return {
      id: `${dep.name}-version`,
      name,
      group: "system",
      status: isInstalled ? "pass" : dep.installed ? "warn" : "fail",
      message: this.buildMessage(dep),
      details: dep.path,
      suggestion: !isInstalled ? this.getSuggestion(dep.name) : undefined,
      autoFixable: this.isAutoFixable(dep.name),
      fix: !isInstalled ? this.createInstallFix(dep.name) : undefined
    };
  }
  formatDependencyName(name) {
    const nameMap = {
      nodejs: "Node.js",
      npm: "npm",
      python: "Python",
      pip: "pip",
      claude: "Claude CLI"
    };
    return nameMap[name] || name.charAt(0).toUpperCase() + name.slice(1);
  }
  buildMessage(dep) {
    if (!dep.installed)
      return "Not installed";
    if (!dep.meetsRequirements && dep.minVersion) {
      return `v${dep.version} (requires >=${dep.minVersion})`;
    }
    return dep.version ? `v${dep.version}` : "Installed";
  }
  getSuggestion(name) {
    const suggestions = {
      nodejs: "Install Node.js 16+ from nodejs.org or via package manager",
      npm: "npm comes with Node.js - install Node.js first",
      python: "Install Python 3.8+ from python.org or via package manager",
      pip: "pip comes with Python - install Python first",
      claude: "Install Claude CLI from https://claude.ai/download"
    };
    return suggestions[name] || `Install ${name}`;
  }
  isAutoFixable(name) {
    return !["pip", "npm"].includes(name);
  }
  createInstallFix(name) {
    if (!this.isAutoFixable(name))
      return;
    return {
      id: `install-${name}`,
      description: `Install ${this.formatDependencyName(name)}`,
      execute: async () => {
        const osInfo = await detectOS();
        const methods = getInstallerMethods(name, osInfo);
        if (methods.length === 0) {
          return {
            success: false,
            message: `No auto-install method for ${name} on ${osInfo.platform}`
          };
        }
        const result = await installDependency(name);
        return {
          success: result.success,
          message: result.message,
          details: result.installedVersion ? `Installed v${result.installedVersion}` : undefined
        };
      }
    };
  }
  async checkGit() {
    try {
      const { stdout } = await execAsync4("git --version");
      const match = stdout.match(/(\d+\.\d+\.\d+)/);
      return {
        id: "git-version",
        name: "Git",
        group: "system",
        status: "pass",
        message: match ? `v${match[1]}` : "Installed",
        autoFixable: false
      };
    } catch {
      return {
        id: "git-version",
        name: "Git",
        group: "system",
        status: "fail",
        message: "Not installed",
        suggestion: "Install Git from https://git-scm.com/downloads",
        autoFixable: false
      };
    }
  }
  async checkGitHubCli() {
    try {
      const { stdout } = await execAsync4("gh --version");
      const match = stdout.match(/(\d+\.\d+\.\d+)/);
      const version = match?.[1];
      if (version && compareVersions(version, MIN_GH_CLI_VERSION) < 0) {
        return {
          id: "gh-cli-version",
          name: "GitHub CLI",
          group: "system",
          status: "warn",
          message: `v${version} (outdated)`,
          details: `Minimum required: v${MIN_GH_CLI_VERSION}`,
          suggestion: this.getGhUpgradeInstructions(),
          autoFixable: false
        };
      }
      return {
        id: "gh-cli-version",
        name: "GitHub CLI",
        group: "system",
        status: "pass",
        message: version ? `v${version}` : "Installed",
        autoFixable: true,
        fix: undefined
      };
    } catch {
      return {
        id: "gh-cli-version",
        name: "GitHub CLI",
        group: "system",
        status: "warn",
        message: "Not installed",
        suggestion: "Install: brew install gh (macOS) or winget install GitHub.cli (Windows)",
        autoFixable: true,
        fix: this.createGhCliFix()
      };
    }
  }
  getGhUpgradeInstructions() {
    return `Upgrade GitHub CLI to v${MIN_GH_CLI_VERSION}+:
  macOS:   brew upgrade gh
  Windows: winget upgrade GitHub.cli
  Linux:   sudo apt update && sudo apt upgrade gh
  Or visit: https://cli.github.com`;
  }
  createGhCliFix() {
    return {
      id: "install-gh-cli",
      description: "Install GitHub CLI",
      execute: async () => {
        const osInfo = await detectOS();
        let command;
        if (osInfo.platform === "darwin" && osInfo.hasHomebrew) {
          command = "brew install gh";
        } else if (osInfo.platform === "linux" && osInfo.hasApt) {
          command = "sudo apt install gh -y";
        } else if (osInfo.platform === "win32") {
          command = "winget install GitHub.cli";
        } else {
          return {
            success: false,
            message: "No auto-install method available",
            details: "Visit https://cli.github.com for installation"
          };
        }
        try {
          await execAsync4(command);
          return { success: true, message: "GitHub CLI installed successfully" };
        } catch (error) {
          return {
            success: false,
            message: `Installation failed: ${error instanceof Error ? error.message : "Unknown error"}`
          };
        }
      }
    };
  }
}
// src/services/file-operations/claudekit-scanner.ts
init_path_resolver();
import { join as join2 } from "node:path";

// src/shared/skip-directories.ts
var BUILD_ARTIFACT_DIRS = [
  "node_modules",
  ".venv",
  "venv",
  ".test-venv",
  "__pycache__",
  ".git",
  ".svn",
  "dist",
  "build"
];
var CLAUDE_CODE_INTERNAL_DIRS = [
  "debug",
  "projects",
  "shell-snapshots",
  "file-history",
  "todos",
  "session-env",
  "statsig",
  "telemetry",
  ".anthropic"
];
var SKIP_DIRS_ALL = [
  ...BUILD_ARTIFACT_DIRS,
  ...CLAUDE_CODE_INTERNAL_DIRS
];
var SKIP_DIRS_CLAUDE_INTERNAL = CLAUDE_CODE_INTERNAL_DIRS;

// src/services/file-operations/claudekit-scanner.ts
var import_fs_extra = __toESM(require_lib(), 1);
async function scanClaudeKitDirectory(directoryPath) {
  const counts = {
    agents: 0,
    commands: 0,
    rules: 0,
    skills: 0
  };
  try {
    if (!await import_fs_extra.pathExists(directoryPath)) {
      return counts;
    }
    const items = await import_fs_extra.readdir(directoryPath);
    if (items.includes("agents")) {
      const agentsPath = join2(directoryPath, "agents");
      const agentFiles = await import_fs_extra.readdir(agentsPath);
      counts.agents = agentFiles.filter((file) => file.endsWith(".md")).length;
    }
    if (items.includes("commands")) {
      const commandsPath = join2(directoryPath, "commands");
      const commandFiles = await import_fs_extra.readdir(commandsPath);
      counts.commands = commandFiles.filter((file) => file.endsWith(".md")).length;
    }
    if (items.includes("rules")) {
      const rulesPath = join2(directoryPath, "rules");
      const ruleFiles = await import_fs_extra.readdir(rulesPath);
      counts.rules = ruleFiles.filter((file) => file.endsWith(".md")).length;
    } else if (items.includes("workflows")) {
      const workflowsPath = join2(directoryPath, "workflows");
      const workflowFiles = await import_fs_extra.readdir(workflowsPath);
      counts.rules = workflowFiles.filter((file) => file.endsWith(".md")).length;
    }
    if (items.includes("skills")) {
      const skillsPath = join2(directoryPath, "skills");
      const skillItems = await import_fs_extra.readdir(skillsPath);
      let skillCount = 0;
      for (const item of skillItems) {
        if (SKIP_DIRS_CLAUDE_INTERNAL.includes(item)) {
          continue;
        }
        const itemPath = join2(skillsPath, item);
        const stat = await import_fs_extra.readdir(itemPath).catch(() => null);
        if (stat?.includes("SKILL.md")) {
          skillCount++;
        }
      }
      counts.skills = skillCount;
    }
  } catch (error) {}
  return counts;
}
async function readClaudeKitMetadata(metadataPath) {
  try {
    if (!await import_fs_extra.pathExists(metadataPath)) {
      return null;
    }
    const content = await import_fs_extra.readFile(metadataPath, "utf8");
    const metadata = JSON.parse(content);
    return metadata;
  } catch {
    return null;
  }
}
function getGlobalInstallDir() {
  return PathResolver.getGlobalKitDir();
}
async function getClaudeKitSetup(projectDir = process.cwd()) {
  const setup = {
    global: {
      path: "",
      metadata: null,
      components: { agents: 0, commands: 0, rules: 0, skills: 0 }
    },
    project: {
      path: "",
      metadata: null,
      components: { agents: 0, commands: 0, rules: 0, skills: 0 }
    }
  };
  const globalDir = getGlobalInstallDir();
  if (await import_fs_extra.pathExists(globalDir)) {
    setup.global.path = globalDir;
    setup.global.metadata = await readClaudeKitMetadata(join2(globalDir, "metadata.json"));
    setup.global.components = await scanClaudeKitDirectory(globalDir);
  }
  const projectClaudeDir = join2(projectDir, ".claude");
  const isLocalSameAsGlobal = projectClaudeDir === globalDir;
  if (!isLocalSameAsGlobal && await import_fs_extra.pathExists(projectClaudeDir)) {
    setup.project.path = projectClaudeDir;
    setup.project.metadata = await readClaudeKitMetadata(join2(projectClaudeDir, "metadata.json"));
    setup.project.components = await scanClaudeKitDirectory(projectClaudeDir);
  }
  return setup;
}

// src/domains/health-checks/claudekit-checker.ts
init_logger();

// src/domains/health-checks/utils/version-formatter.ts
function formatVersion(version) {
  if (!version)
    return "";
  return `v${version.replace(/^v/, "")}`;
}

// src/domains/health-checks/checkers/installation-checker.ts
function checkGlobalInstall(setup) {
  const hasGlobal = !!setup.global.path;
  const metadata = setup.global.metadata;
  const kitName = metadata?.name || "ClaudeKit";
  const version = formatVersion(metadata?.version);
  return {
    id: "ck-global-install",
    name: "Global CK",
    group: "claudekit",
    priority: "critical",
    status: hasGlobal ? "pass" : "warn",
    message: hasGlobal ? `${kitName} ${version}` : "Not installed",
    details: hasGlobal ? setup.global.path : undefined,
    suggestion: !hasGlobal ? "Install globally: ck init --global" : undefined,
    autoFixable: false
  };
}
function checkProjectInstall(setup) {
  const metadata = setup.project.metadata;
  const hasProject = !!metadata;
  const kitName = metadata?.name || "ClaudeKit";
  const version = formatVersion(metadata?.version);
  return {
    id: "ck-project-install",
    name: "Project CK",
    group: "claudekit",
    priority: "standard",
    status: hasProject ? "pass" : "info",
    message: hasProject ? `${kitName} ${version}` : "Not a ClaudeKit project",
    details: hasProject ? setup.project.path : undefined,
    suggestion: !hasProject ? "Initialize: ck new or ck init" : undefined,
    autoFixable: false
  };
}
// src/domains/installation/package-manager-detector.ts
init_logger();

// src/domains/installation/package-managers/detector-base.ts
import { exec as exec5 } from "node:child_process";
import { promisify as promisify5 } from "node:util";
var execAsync5 = promisify5(exec5);
function isValidPackageName(name) {
  return /^(@[a-z0-9-~][a-z0-9-._~]*\/)?[a-z0-9-~][a-z0-9-._~]*$/.test(name);
}
function isValidVersion(version) {
  return /^[a-zA-Z0-9._-]+$/.test(version);
}
// src/domains/installation/package-managers/npm-detector.ts
init_environment();
function getNpmQuery() {
  return {
    pm: "npm",
    cmd: isWindows() ? "npm.cmd ls -g claudekit-cli --depth=0 --json" : "npm ls -g claudekit-cli --depth=0 --json",
    checkFn: (stdout) => {
      try {
        const data = JSON.parse(stdout);
        return !!(data.dependencies?.["claudekit-cli"] || stdout.includes("claudekit-cli"));
      } catch {
        return stdout.includes("claudekit-cli");
      }
    }
  };
}
function getNpmVersionCommand() {
  return isWindows() ? "npm.cmd --version" : "npm --version";
}
async function getNpmVersion() {
  try {
    const { stdout } = await execAsync5(getNpmVersionCommand(), { timeout: 3000 });
    return stdout.trim();
  } catch {
    return null;
  }
}
function getNpmUpdateCommand(packageName, version) {
  if (!isValidPackageName(packageName)) {
    throw new Error(`Invalid package name: ${packageName}`);
  }
  if (version && !isValidVersion(version)) {
    throw new Error(`Invalid version: ${version}`);
  }
  const versionSuffix = version ? `@${version}` : "@latest";
  return isWindows() ? `npm.cmd install -g ${packageName}${versionSuffix}` : `npm install -g ${packageName}${versionSuffix}`;
}
// src/domains/installation/package-managers/bun-detector.ts
function getBunQuery() {
  return {
    pm: "bun",
    cmd: "bun pm ls -g",
    checkFn: (stdout) => stdout.includes("claudekit-cli")
  };
}
function getBunVersionCommand() {
  return "bun --version";
}
async function getBunVersion() {
  try {
    const { stdout } = await execAsync5(getBunVersionCommand(), { timeout: 3000 });
    return stdout.trim();
  } catch {
    return null;
  }
}
function getBunUpdateCommand(packageName, version) {
  if (!isValidPackageName(packageName)) {
    throw new Error(`Invalid package name: ${packageName}`);
  }
  if (version && !isValidVersion(version)) {
    throw new Error(`Invalid version: ${version}`);
  }
  const versionSuffix = version ? `@${version}` : "@latest";
  return `bun add -g ${packageName}${versionSuffix}`;
}
// src/domains/installation/package-managers/yarn-detector.ts
init_environment();
function getYarnQuery() {
  return {
    pm: "yarn",
    cmd: isWindows() ? "yarn.cmd global list --pattern claudekit-cli" : "yarn global list --pattern claudekit-cli",
    checkFn: (stdout) => stdout.includes("claudekit-cli")
  };
}
function getYarnVersionCommand() {
  return isWindows() ? "yarn.cmd --version" : "yarn --version";
}
async function getYarnVersion() {
  try {
    const { stdout } = await execAsync5(getYarnVersionCommand(), { timeout: 3000 });
    return stdout.trim();
  } catch {
    return null;
  }
}
function getYarnUpdateCommand(packageName, version) {
  if (!isValidPackageName(packageName)) {
    throw new Error(`Invalid package name: ${packageName}`);
  }
  if (version && !isValidVersion(version)) {
    throw new Error(`Invalid version: ${version}`);
  }
  const versionSuffix = version ? `@${version}` : "@latest";
  return isWindows() ? `yarn.cmd global add ${packageName}${versionSuffix}` : `yarn global add ${packageName}${versionSuffix}`;
}
// src/domains/installation/package-managers/pnpm-detector.ts
init_environment();
function getPnpmQuery() {
  return {
    pm: "pnpm",
    cmd: isWindows() ? "pnpm.cmd ls -g claudekit-cli" : "pnpm ls -g claudekit-cli",
    checkFn: (stdout) => stdout.includes("claudekit-cli")
  };
}
function getPnpmVersionCommand() {
  return isWindows() ? "pnpm.cmd --version" : "pnpm --version";
}
async function getPnpmVersion() {
  try {
    const { stdout } = await execAsync5(getPnpmVersionCommand(), { timeout: 3000 });
    return stdout.trim();
  } catch {
    return null;
  }
}
function getPnpmUpdateCommand(packageName, version) {
  if (!isValidPackageName(packageName)) {
    throw new Error(`Invalid package name: ${packageName}`);
  }
  if (version && !isValidVersion(version)) {
    throw new Error(`Invalid version: ${version}`);
  }
  const versionSuffix = version ? `@${version}` : "@latest";
  return isWindows() ? `pnpm.cmd add -g ${packageName}${versionSuffix}` : `pnpm add -g ${packageName}${versionSuffix}`;
}
// src/domains/installation/package-managers/detection-core.ts
init_logger();
init_path_resolver();
import { existsSync as existsSync3 } from "node:fs";
import { chmod, mkdir, readFile as readFile2, writeFile } from "node:fs/promises";
import { platform as platform2 } from "node:os";
import { join as join3 } from "node:path";
var CACHE_FILE = "install-info.json";
var CACHE_TTL = 30 * 24 * 60 * 60 * 1000;
var QUERY_TIMEOUT = 5000;
function detectFromEnv() {
  const userAgent = process.env.npm_config_user_agent;
  if (userAgent) {
    logger.debug(`Detected user agent: ${userAgent}`);
    if (userAgent.includes("bun/"))
      return "bun";
    if (userAgent.includes("yarn/"))
      return "yarn";
    if (userAgent.includes("pnpm/"))
      return "pnpm";
    if (userAgent.includes("npm/"))
      return "npm";
  }
  const execPath = process.env.npm_execpath;
  if (execPath) {
    logger.debug(`Detected exec path: ${execPath}`);
    if (execPath.includes("bun"))
      return "bun";
    if (execPath.includes("yarn"))
      return "yarn";
    if (execPath.includes("pnpm"))
      return "pnpm";
    if (execPath.includes("npm"))
      return "npm";
  }
  return "unknown";
}
async function readCachedPm() {
  try {
    const cacheFile = join3(PathResolver.getConfigDir(false), CACHE_FILE);
    if (!existsSync3(cacheFile)) {
      return null;
    }
    const content = await readFile2(cacheFile, "utf-8");
    const data = JSON.parse(content);
    if (!data.packageManager || !data.detectedAt) {
      logger.debug("Invalid cache structure, ignoring");
      return null;
    }
    const age = Date.now() - data.detectedAt;
    if (age > CACHE_TTL) {
      logger.debug("Cache expired, will re-detect");
      return null;
    }
    const validPms = ["npm", "bun", "yarn", "pnpm"];
    if (!validPms.includes(data.packageManager)) {
      logger.debug(`Invalid cached PM value: ${data.packageManager}`);
      return null;
    }
    return data.packageManager;
  } catch (error) {
    logger.debug(`Failed to read cache: ${error instanceof Error ? error.message : "Unknown error"}`);
    return null;
  }
}
async function saveCachedPm(pm, getVersion) {
  if (pm === "unknown")
    return;
  try {
    const configDir = PathResolver.getConfigDir(false);
    const cacheFile = join3(configDir, CACHE_FILE);
    if (!existsSync3(configDir)) {
      await mkdir(configDir, { recursive: true });
      if (platform2() !== "win32") {
        await chmod(configDir, 448);
      }
    }
    const version = await getVersion(pm);
    const data = {
      packageManager: pm,
      detectedAt: Date.now(),
      version: version ?? undefined
    };
    await writeFile(cacheFile, JSON.stringify(data, null, 2), "utf-8");
    if (platform2() !== "win32") {
      await chmod(cacheFile, 384);
    }
    logger.debug(`Cached package manager: ${pm}`);
  } catch (error) {
    logger.debug(`Failed to save cache: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}
async function findOwningPm() {
  const queries = [getNpmQuery(), getPnpmQuery(), getYarnQuery(), getBunQuery()];
  logger.verbose("PackageManagerDetector: Querying all PMs in parallel");
  logger.debug("Querying package managers for claudekit-cli ownership...");
  const results = await Promise.allSettled(queries.map(async ({ pm, cmd, checkFn }) => {
    try {
      logger.verbose(`PackageManagerDetector: Querying ${pm}`);
      const { stdout } = await execAsync5(cmd, {
        timeout: QUERY_TIMEOUT
      });
      if (checkFn(stdout)) {
        logger.verbose(`PackageManagerDetector: Found via ${pm}`);
        logger.debug(`Found claudekit-cli installed via ${pm}`);
        return pm;
      }
      logger.verbose(`PackageManagerDetector: Not found via ${pm}`);
    } catch {
      logger.verbose(`PackageManagerDetector: ${pm} query failed or not available`);
    }
    return null;
  }));
  logger.verbose("PackageManagerDetector: All PM queries complete");
  for (const result of results) {
    if (result.status === "fulfilled" && result.value) {
      return result.value;
    }
  }
  logger.debug("Could not determine which package manager installed claudekit-cli");
  return null;
}
async function clearCache() {
  try {
    const { unlink } = await import("node:fs/promises");
    const cacheFile = join3(PathResolver.getConfigDir(false), CACHE_FILE);
    if (existsSync3(cacheFile)) {
      await unlink(cacheFile);
      logger.debug("Package manager cache cleared");
    }
  } catch (error) {
    logger.debug(`Failed to clear cache: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}
// src/domains/installation/package-manager-detector.ts
class PackageManagerDetector {
  static async detect() {
    logger.verbose("PackageManagerDetector: Starting detection");
    const envPm = detectFromEnv();
    if (envPm !== "unknown") {
      logger.verbose(`PackageManagerDetector: Detected from env: ${envPm}`);
      return envPm;
    }
    logger.verbose("PackageManagerDetector: Checking cache");
    const cachedPm = await readCachedPm();
    if (cachedPm) {
      logger.verbose(`PackageManagerDetector: Using cached: ${cachedPm}`);
      return cachedPm;
    }
    logger.verbose("PackageManagerDetector: Querying package managers");
    const owningPm = await findOwningPm();
    if (owningPm) {
      logger.verbose(`PackageManagerDetector: Found owning PM: ${owningPm}`);
      await saveCachedPm(owningPm, PackageManagerDetector.getVersion);
      return owningPm;
    }
    logger.verbose("PackageManagerDetector: Defaulting to npm");
    logger.warning("Could not detect package manager that installed claudekit-cli, defaulting to npm");
    return "npm";
  }
  static readCachedPm = readCachedPm;
  static async saveCachedPm(pm) {
    return saveCachedPm(pm, PackageManagerDetector.getVersion);
  }
  static findOwningPm = findOwningPm;
  static async isAvailable(pm) {
    if (pm === "unknown")
      return false;
    try {
      await execAsync5(PackageManagerDetector.getVersionCommand(pm), { timeout: 3000 });
      return true;
    } catch {
      return false;
    }
  }
  static getVersionCommand(pm) {
    switch (pm) {
      case "npm":
        return getNpmVersionCommand();
      case "bun":
        return getBunVersionCommand();
      case "yarn":
        return getYarnVersionCommand();
      case "pnpm":
        return getPnpmVersionCommand();
      default:
        return "echo unknown";
    }
  }
  static getUpdateCommand(pm, packageName, version) {
    if (!isValidPackageName(packageName))
      throw new Error(`Invalid package name: ${packageName}`);
    if (version && !isValidVersion(version))
      throw new Error(`Invalid version: ${version}`);
    switch (pm) {
      case "bun":
        return getBunUpdateCommand(packageName, version);
      case "yarn":
        return getYarnUpdateCommand(packageName, version);
      case "pnpm":
        return getPnpmUpdateCommand(packageName, version);
      default:
        return getNpmUpdateCommand(packageName, version);
    }
  }
  static getInstallCommand(pm, packageName, version) {
    return PackageManagerDetector.getUpdateCommand(pm, packageName, version);
  }
  static getDisplayName(pm) {
    switch (pm) {
      case "npm":
        return "npm";
      case "bun":
        return "Bun";
      case "yarn":
        return "Yarn";
      case "pnpm":
        return "pnpm";
      default:
        return "Unknown";
    }
  }
  static async getVersion(pm) {
    switch (pm) {
      case "npm":
        return getNpmVersion();
      case "bun":
        return getBunVersion();
      case "yarn":
        return getYarnVersion();
      case "pnpm":
        return getPnpmVersion();
      default:
        return null;
    }
  }
  static clearCache = clearCache;
}

// src/domains/health-checks/checkers/cli-install-checker.ts
init_logger();
async function checkCliInstallMethod() {
  if (false) {}
  const pm = await PackageManagerDetector.detect();
  const pmVersion = await PackageManagerDetector.getVersion(pm);
  const displayName = PackageManagerDetector.getDisplayName(pm);
  return {
    id: "ck-cli-install-method",
    name: "CLI Installed Via",
    group: "claudekit",
    priority: "standard",
    status: pm !== "unknown" ? "pass" : "warn",
    message: pmVersion ? `${displayName} (v${pmVersion})` : displayName,
    suggestion: pm === "unknown" ? "Run: npm install -g claudekit-cli" : undefined,
    autoFixable: false
  };
}
// src/domains/health-checks/checkers/claude-md-checker.ts
import { existsSync as existsSync4, statSync } from "node:fs";
import { join as join4 } from "node:path";
function checkClaudeMd(setup, projectDir) {
  const results = [];
  if (setup.global.path) {
    const globalClaudeMd = join4(setup.global.path, "CLAUDE.md");
    results.push(checkClaudeMdFile(globalClaudeMd, "Global CLAUDE.md", "ck-global-claude-md"));
  }
  const projectClaudeMd = join4(projectDir, ".claude", "CLAUDE.md");
  results.push(checkClaudeMdFile(projectClaudeMd, "Project CLAUDE.md", "ck-project-claude-md"));
  return results;
}
function checkClaudeMdFile(path, name, id) {
  if (!existsSync4(path)) {
    return {
      id,
      name,
      group: "claudekit",
      priority: "standard",
      status: "warn",
      message: "Missing",
      suggestion: "Create CLAUDE.md with project instructions",
      autoFixable: false
    };
  }
  try {
    const stat = statSync(path);
    const sizeKB = (stat.size / 1024).toFixed(1);
    if (stat.size === 0) {
      return {
        id,
        name,
        group: "claudekit",
        priority: "standard",
        status: "warn",
        message: "Empty (0 bytes)",
        details: path,
        suggestion: "Add project instructions to CLAUDE.md",
        autoFixable: false
      };
    }
    return {
      id,
      name,
      group: "claudekit",
      priority: "standard",
      status: "pass",
      message: `Found (${sizeKB}KB)`,
      details: path,
      autoFixable: false
    };
  } catch {
    return {
      id,
      name,
      group: "claudekit",
      priority: "standard",
      status: "warn",
      message: "Unreadable",
      details: path,
      suggestion: "Check file permissions",
      autoFixable: false
    };
  }
}
// src/domains/health-checks/checkers/active-plan-checker.ts
import { existsSync as existsSync5, readFileSync as readFileSync4 } from "node:fs";
import { join as join5 } from "node:path";
function checkActivePlan(projectDir) {
  const activePlanPath = join5(projectDir, ".claude", "active-plan");
  if (!existsSync5(activePlanPath)) {
    return {
      id: "ck-active-plan",
      name: "Active Plan",
      group: "claudekit",
      priority: "standard",
      status: "info",
      message: "None",
      autoFixable: false
    };
  }
  try {
    const targetPath = readFileSync4(activePlanPath, "utf-8").trim();
    const fullPath = join5(projectDir, targetPath);
    if (!existsSync5(fullPath)) {
      return {
        id: "ck-active-plan",
        name: "Active Plan",
        group: "claudekit",
        priority: "standard",
        status: "warn",
        message: "Orphaned (target missing)",
        details: targetPath,
        suggestion: "Run: rm .claude/active-plan",
        autoFixable: false
      };
    }
    return {
      id: "ck-active-plan",
      name: "Active Plan",
      group: "claudekit",
      priority: "standard",
      status: "pass",
      message: targetPath,
      autoFixable: false
    };
  } catch {
    return {
      id: "ck-active-plan",
      name: "Active Plan",
      group: "claudekit",
      priority: "standard",
      status: "warn",
      message: "Unreadable",
      details: activePlanPath,
      autoFixable: false
    };
  }
}
// src/domains/health-checks/checkers/skills-checker.ts
import { existsSync as existsSync6 } from "node:fs";
import { join as join6 } from "node:path";
function checkSkillsScripts(setup) {
  const results = [];
  const platform3 = process.platform;
  const scriptName = platform3 === "win32" ? "install.ps1" : "install.sh";
  if (setup.global.path) {
    const globalScriptPath = join6(setup.global.path, "skills", scriptName);
    const hasGlobalScript = existsSync6(globalScriptPath);
    results.push({
      id: "ck-global-skills-script",
      name: "Global Skills Script",
      group: "claudekit",
      priority: "standard",
      status: hasGlobalScript ? "pass" : "info",
      message: hasGlobalScript ? "Available" : "Not found",
      details: hasGlobalScript ? globalScriptPath : undefined,
      suggestion: !hasGlobalScript ? "Run: ck init --global --install-skills" : undefined,
      autoFixable: false
    });
  }
  if (setup.project.metadata) {
    const projectScriptPath = join6(setup.project.path, "skills", scriptName);
    const hasProjectScript = existsSync6(projectScriptPath);
    results.push({
      id: "ck-project-skills-script",
      name: "Project Skills Script",
      group: "claudekit",
      priority: "standard",
      status: hasProjectScript ? "pass" : "info",
      message: hasProjectScript ? "Available" : "Not found",
      details: hasProjectScript ? projectScriptPath : undefined,
      suggestion: !hasProjectScript ? "Run: ck init --install-skills" : undefined,
      autoFixable: false
    });
  }
  return results;
}
function checkComponentCounts(setup) {
  const global2 = setup.global.components;
  const project = setup.project.components;
  const totalAgents = global2.agents + project.agents;
  const totalCommands = global2.commands + project.commands;
  const totalRules = global2.rules + project.rules;
  const totalSkills = global2.skills + project.skills;
  const totalComponents = totalAgents + totalCommands + totalRules + totalSkills;
  return {
    id: "ck-component-counts",
    name: "ClaudeKit Components",
    group: "claudekit",
    priority: "standard",
    status: totalComponents > 0 ? "info" : "warn",
    message: totalComponents > 0 ? `${totalAgents} agents, ${totalCommands} commands, ${totalRules} rules, ${totalSkills} skills` : "No components found",
    suggestion: totalComponents === 0 ? "Install ClaudeKit: ck new --kit engineer" : undefined,
    autoFixable: false
  };
}
// src/domains/health-checks/checkers/permissions-checker.ts
init_logger();
init_path_resolver();
import { constants, access, unlink, writeFile as writeFile2 } from "node:fs/promises";
import { join as join7 } from "node:path";

// src/domains/health-checks/checkers/shared.ts
function shouldSkipExpensiveOperations3() {
  if (process.env.CK_TEST_HOME) {
    return false;
  }
  return process.env.CI === "true" || process.env.CI_SAFE_MODE === "true";
}
var HOOK_EXTENSIONS = [".js", ".cjs", ".mjs", ".ts", ".sh", ".ps1"];

// src/domains/health-checks/checkers/permissions-checker.ts
async function checkGlobalDirReadable() {
  const globalDir = PathResolver.getGlobalKitDir();
  if (shouldSkipExpensiveOperations3()) {
    return {
      id: "ck-global-dir-readable",
      name: "Global Dir Readable",
      group: "claudekit",
      priority: "standard",
      status: "info",
      message: "Skipped in CI/test environment",
      details: globalDir,
      autoFixable: false
    };
  }
  try {
    await access(globalDir, constants.R_OK);
    return {
      id: "ck-global-dir-readable",
      name: "Global Dir Readable",
      group: "claudekit",
      priority: "standard",
      status: "pass",
      message: "Read access OK",
      details: globalDir,
      autoFixable: false
    };
  } catch (error) {
    return {
      id: "ck-global-dir-readable",
      name: "Global Dir Readable",
      group: "claudekit",
      priority: "standard",
      status: "fail",
      message: "Read access denied",
      details: globalDir,
      suggestion: "Check file permissions on ~/.claude/",
      autoFixable: false
    };
  }
}
async function checkGlobalDirWritable() {
  const globalDir = PathResolver.getGlobalKitDir();
  if (shouldSkipExpensiveOperations3()) {
    return {
      id: "ck-global-dir-writable",
      name: "Global Dir Writable",
      group: "claudekit",
      priority: "standard",
      status: "info",
      message: "Skipped in CI/test environment",
      details: globalDir,
      autoFixable: false
    };
  }
  const timestamp = Date.now();
  const random = Math.random().toString(36).substring(2);
  const testFile = join7(globalDir, `.ck-write-test-${timestamp}-${random}`);
  try {
    await writeFile2(testFile, "test", { encoding: "utf-8", flag: "wx" });
  } catch (error) {
    return {
      id: "ck-global-dir-writable",
      name: "Global Dir Writable",
      group: "claudekit",
      priority: "standard",
      status: "fail",
      message: "Write access denied",
      details: globalDir,
      suggestion: "Check file permissions on ~/.claude/",
      autoFixable: false
    };
  }
  try {
    await unlink(testFile);
  } catch (_error) {
    logger.verbose("Failed to cleanup write test file", { testFile });
  }
  return {
    id: "ck-global-dir-writable",
    name: "Global Dir Writable",
    group: "claudekit",
    priority: "standard",
    status: "pass",
    message: "Write access OK",
    details: globalDir,
    autoFixable: false
  };
}
// src/domains/health-checks/checkers/hooks-checker.ts
init_path_resolver();
import { existsSync as existsSync7 } from "node:fs";
import { readdir as readdir2 } from "node:fs/promises";
import { join as join8 } from "node:path";

// src/domains/health-checks/utils/path-normalizer.ts
import { normalize as normalize2 } from "node:path";
function normalizePath(filePath) {
  const normalized = normalize2(filePath);
  const isCaseInsensitive = process.platform === "win32" || process.platform === "darwin";
  return isCaseInsensitive ? normalized.toLowerCase() : normalized;
}

// src/domains/health-checks/checkers/hooks-checker.ts
async function checkHooksExist(projectDir) {
  const globalHooksDir = join8(PathResolver.getGlobalKitDir(), "hooks");
  const projectHooksDir = join8(projectDir, ".claude", "hooks");
  const globalExists = existsSync7(globalHooksDir);
  const projectExists = existsSync7(projectHooksDir);
  let hookCount = 0;
  const checkedFiles = new Set;
  if (globalExists) {
    const files = await readdir2(globalHooksDir, { withFileTypes: false });
    const hooks = files.filter((f) => HOOK_EXTENSIONS.some((ext) => f.endsWith(ext)));
    hooks.forEach((hook) => {
      const fullPath = join8(globalHooksDir, hook);
      checkedFiles.add(normalizePath(fullPath));
    });
  }
  const normalizedGlobal = normalizePath(globalHooksDir);
  const normalizedProject = normalizePath(projectHooksDir);
  if (projectExists && normalizedProject !== normalizedGlobal) {
    const files = await readdir2(projectHooksDir, { withFileTypes: false });
    const hooks = files.filter((f) => HOOK_EXTENSIONS.some((ext) => f.endsWith(ext)));
    hooks.forEach((hook) => {
      const fullPath = join8(projectHooksDir, hook);
      checkedFiles.add(normalizePath(fullPath));
    });
  }
  hookCount = checkedFiles.size;
  if (!globalExists && !projectExists) {
    return {
      id: "ck-hooks-exist",
      name: "Hooks Directory",
      group: "claudekit",
      priority: "standard",
      status: "info",
      message: "No hooks directory",
      autoFixable: false
    };
  }
  return {
    id: "ck-hooks-exist",
    name: "Hooks Directory",
    group: "claudekit",
    priority: "standard",
    status: "pass",
    message: `${hookCount} hook(s) found`,
    details: globalExists ? globalHooksDir : projectHooksDir,
    autoFixable: false
  };
}
// src/domains/health-checks/checkers/settings-checker.ts
init_logger();
init_path_resolver();
import { existsSync as existsSync8 } from "node:fs";
import { readFile as readFile3 } from "node:fs/promises";
import { join as join9 } from "node:path";
async function checkSettingsValid(projectDir) {
  const globalSettings = join9(PathResolver.getGlobalKitDir(), "settings.json");
  const projectSettings = join9(projectDir, ".claude", "settings.json");
  const settingsPath = existsSync8(globalSettings) ? globalSettings : existsSync8(projectSettings) ? projectSettings : null;
  if (!settingsPath) {
    return {
      id: "ck-settings-valid",
      name: "Settings.json",
      group: "claudekit",
      priority: "extended",
      status: "info",
      message: "No settings.json found",
      autoFixable: false
    };
  }
  try {
    const content = await readFile3(settingsPath, "utf-8");
    JSON.parse(content);
    return {
      id: "ck-settings-valid",
      name: "Settings.json",
      group: "claudekit",
      priority: "extended",
      status: "pass",
      message: "Valid JSON",
      details: settingsPath,
      autoFixable: false
    };
  } catch (error) {
    let message = "Invalid JSON";
    let suggestion = "Fix JSON syntax in settings.json";
    let details = settingsPath;
    if (error instanceof SyntaxError) {
      message = "JSON syntax error";
      details = `${settingsPath}: ${error.message}`;
      logger.verbose("Settings.json syntax error", {
        path: settingsPath,
        error: error.message
      });
    } else if (error instanceof Error) {
      if (error.message.includes("EACCES") || error.message.includes("EPERM")) {
        message = "Permission denied";
        suggestion = "Check file permissions on settings.json";
      } else if (error.message.includes("ENOENT")) {
        message = "File not found";
        suggestion = "Ensure settings.json exists at the expected location";
      } else {
        message = `Read error: ${error.message}`;
        suggestion = "Check file system and permissions";
      }
      logger.verbose("Settings.json read error", {
        path: settingsPath,
        error: error.message,
        code: error.code
      });
    }
    return {
      id: "ck-settings-valid",
      name: "Settings.json",
      group: "claudekit",
      priority: "extended",
      status: "fail",
      message,
      details,
      suggestion,
      autoFixable: false
    };
  }
}
// src/domains/health-checks/checkers/path-refs-checker.ts
init_logger();
init_path_resolver();
import { existsSync as existsSync9 } from "node:fs";
import { readFile as readFile4 } from "node:fs/promises";
import { homedir as homedir2 } from "node:os";
import { dirname, join as join10, normalize as normalize3, resolve } from "node:path";
async function checkPathRefsValid(projectDir) {
  const globalClaudeMd = join10(PathResolver.getGlobalKitDir(), "CLAUDE.md");
  const projectClaudeMd = join10(projectDir, ".claude", "CLAUDE.md");
  const claudeMdPath = existsSync9(globalClaudeMd) ? globalClaudeMd : existsSync9(projectClaudeMd) ? projectClaudeMd : null;
  if (!claudeMdPath) {
    return {
      id: "ck-path-refs-valid",
      name: "Path References",
      group: "claudekit",
      priority: "extended",
      status: "info",
      message: "No CLAUDE.md found",
      autoFixable: false
    };
  }
  try {
    const content = await readFile4(claudeMdPath, "utf-8");
    const refPattern = /@([^\s\)]+)/g;
    const refs = [...content.matchAll(refPattern)].map((m) => m[1]);
    if (refs.length === 0) {
      return {
        id: "ck-path-refs-valid",
        name: "Path References",
        group: "claudekit",
        priority: "extended",
        status: "info",
        message: "No @path references found",
        autoFixable: false
      };
    }
    const baseDir = dirname(claudeMdPath);
    const home = homedir2();
    const broken = [];
    for (const ref of refs) {
      let refPath;
      if (ref.startsWith("$HOME") || ref.startsWith("${HOME}") || ref.startsWith("%USERPROFILE%")) {
        refPath = normalize3(ref.replace(/^\$\{?HOME\}?/, home).replace("%USERPROFILE%", home));
      } else if (ref.startsWith("$CLAUDE_PROJECT_DIR") || ref.startsWith("${CLAUDE_PROJECT_DIR}") || ref.startsWith("%CLAUDE_PROJECT_DIR%")) {
        refPath = normalize3(ref.replace(/^\$\{?CLAUDE_PROJECT_DIR\}?/, projectDir).replace("%CLAUDE_PROJECT_DIR%", projectDir));
      } else if (ref.startsWith("~")) {
        refPath = normalize3(ref.replace(/^~/, home));
      } else if (ref.startsWith("/")) {
        refPath = normalize3(ref);
      } else if (/^[A-Za-z]:/.test(ref)) {
        refPath = normalize3(ref);
      } else {
        refPath = resolve(baseDir, ref);
      }
      const normalizedPath = normalize3(refPath);
      const isWithinHome = normalizedPath.startsWith(home);
      const isWithinBase = normalizedPath.startsWith(normalize3(baseDir));
      const isAbsoluteAllowed = ref.startsWith("/") || /^[A-Za-z]:/.test(ref);
      if (!isWithinHome && !isWithinBase && !isAbsoluteAllowed) {
        logger.verbose("Skipping potentially unsafe path reference", { ref, refPath });
        continue;
      }
      if (!existsSync9(normalizedPath)) {
        broken.push(ref);
      }
    }
    if (broken.length > 0) {
      return {
        id: "ck-path-refs-valid",
        name: "Path References",
        group: "claudekit",
        priority: "extended",
        status: "warn",
        message: `${broken.length}/${refs.length} broken`,
        details: broken.slice(0, 3).join(", "),
        suggestion: "Some @path references point to missing files",
        autoFixable: false
      };
    }
    return {
      id: "ck-path-refs-valid",
      name: "Path References",
      group: "claudekit",
      priority: "extended",
      status: "pass",
      message: `${refs.length} valid`,
      autoFixable: false
    };
  } catch (error) {
    return {
      id: "ck-path-refs-valid",
      name: "Path References",
      group: "claudekit",
      priority: "extended",
      status: "info",
      message: "Could not parse CLAUDE.md",
      autoFixable: false
    };
  }
}
// src/domains/health-checks/checkers/config-completeness-checker.ts
import { existsSync as existsSync10 } from "node:fs";
import { readdir as readdir3 } from "node:fs/promises";
import { join as join11 } from "node:path";
async function checkProjectConfigCompleteness(setup, projectDir) {
  if (setup.project.path === setup.global.path) {
    return {
      id: "ck-project-config-complete",
      name: "Project Config Completeness",
      group: "claudekit",
      priority: "standard",
      status: "info",
      message: "Not in a project directory",
      autoFixable: false
    };
  }
  const projectClaudeDir = join11(projectDir, ".claude");
  const requiredDirs = ["agents", "commands", "skills"];
  const missingDirs = [];
  for (const dir of requiredDirs) {
    const dirPath = join11(projectClaudeDir, dir);
    if (!existsSync10(dirPath)) {
      missingDirs.push(dir);
    }
  }
  const hasRulesOrWorkflows = existsSync10(join11(projectClaudeDir, "rules")) || existsSync10(join11(projectClaudeDir, "workflows"));
  if (!hasRulesOrWorkflows) {
    missingDirs.push("rules");
  }
  const files = await readdir3(projectClaudeDir).catch(() => []);
  const hasOnlyClaudeMd = files.length === 1 && files.includes("CLAUDE.md");
  const totalRequired = requiredDirs.length + 1;
  if (hasOnlyClaudeMd || missingDirs.length === totalRequired) {
    return {
      id: "ck-project-config-complete",
      name: "Project Config Completeness",
      group: "claudekit",
      priority: "standard",
      status: "fail",
      message: "Incomplete configuration",
      details: "Only CLAUDE.md found - missing agents, commands, rules, skills",
      suggestion: "Run 'ck init' to install complete ClaudeKit in project",
      autoFixable: false
    };
  }
  if (missingDirs.length > 0) {
    return {
      id: "ck-project-config-complete",
      name: "Project Config Completeness",
      group: "claudekit",
      priority: "standard",
      status: "warn",
      message: `Missing ${missingDirs.length} directories`,
      details: `Missing: ${missingDirs.join(", ")}`,
      suggestion: "Run 'ck init' to update project configuration",
      autoFixable: false
    };
  }
  return {
    id: "ck-project-config-complete",
    name: "Project Config Completeness",
    group: "claudekit",
    priority: "standard",
    status: "pass",
    message: "Complete configuration",
    details: projectClaudeDir,
    autoFixable: false
  };
}
// src/domains/health-checks/checkers/env-keys-checker.ts
import { join as join14 } from "node:path";

// src/domains/installation/setup-wizard.ts
import { join as join13 } from "node:path";

// src/domains/config/config-generator.ts
var import_fs_extra2 = __toESM(require_lib(), 1);
import { join as join12 } from "node:path";
async function generateEnvFile(targetDir, values) {
  const lines = [
    "# Generated by ClaudeKit CLI setup wizard",
    "# See .env.example for all available options",
    ""
  ];
  const geminiKeys = [];
  const otherValues = [];
  for (const [key, value] of Object.entries(values)) {
    if (value) {
      if (key.startsWith("GEMINI_API_KEY")) {
        geminiKeys.push([key, value]);
      } else {
        otherValues.push([key, value]);
      }
    }
  }
  if (geminiKeys.length > 0) {
    if (geminiKeys.length > 1) {
      lines.push("# Gemini API Keys (rotation enabled)");
      lines.push("# Keys auto-rotate on rate limit (429/RESOURCE_EXHAUSTED)");
    }
    geminiKeys.sort((a, b) => {
      const getKeyNumber = (key) => {
        if (key === "GEMINI_API_KEY")
          return 1;
        const match = key.match(/^GEMINI_API_KEY_(\d+)$/);
        return match ? Number.parseInt(match[1], 10) : 999;
      };
      return getKeyNumber(a[0]) - getKeyNumber(b[0]);
    });
    for (const [key, value] of geminiKeys) {
      lines.push(`${key}=${value}`);
    }
    if (otherValues.length > 0) {
      lines.push("");
    }
  }
  for (const [key, value] of otherValues) {
    lines.push(`${key}=${value}`);
  }
  const envPath = join12(targetDir, ".env");
  await import_fs_extra2.writeFile(envPath, `${lines.join(`
`)}
`, { mode: 384 });
}

// src/domains/config/config-validator.ts
var VALIDATION_PATTERNS = {
  GEMINI_API_KEY: /^AIza[0-9A-Za-z_-]{35}$/,
  DISCORD_WEBHOOK_URL: /^https:\/\/discord\.com\/api\/webhooks\//,
  TELEGRAM_BOT_TOKEN: /^\d+:[A-Za-z0-9_-]{35}$/
};
function validateApiKey(value, pattern) {
  return pattern.test(value);
}

// src/domains/installation/setup-wizard.ts
init_logger();
init_path_resolver();
init_dist2();
var import_fs_extra3 = __toESM(require_lib(), 1);
var REQUIRED_ENV_KEYS = [
  { key: "GEMINI_API_KEY", label: "Gemini API Key" }
];
async function checkRequiredKeysExist(envPath) {
  const envExists = await import_fs_extra3.pathExists(envPath);
  if (!envExists) {
    return { allPresent: false, missing: REQUIRED_ENV_KEYS, envExists: false };
  }
  const env = await parseEnvFile(envPath);
  const missing = [];
  for (const required of REQUIRED_ENV_KEYS) {
    const value = env[required.key];
    if (!value || value.trim() === "") {
      missing.push(required);
    }
  }
  return {
    allPresent: missing.length === 0,
    missing,
    envExists: true
  };
}
var ESSENTIAL_CONFIGS = [
  {
    key: "GEMINI_API_KEY",
    label: "Google Gemini API Key",
    hint: "Required for ai-multimodal skill. Get from: https://aistudio.google.com/apikey",
    required: true,
    validate: VALIDATION_PATTERNS.GEMINI_API_KEY,
    mask: true
  },
  {
    key: "DISCORD_WEBHOOK_URL",
    label: "Discord Webhook URL (optional)",
    hint: "For Discord notifications. Leave empty to skip.",
    required: false,
    validate: VALIDATION_PATTERNS.DISCORD_WEBHOOK_URL,
    mask: false
  },
  {
    key: "TELEGRAM_BOT_TOKEN",
    label: "Telegram Bot Token (optional)",
    hint: "For Telegram notifications. Leave empty to skip.",
    required: false,
    validate: VALIDATION_PATTERNS.TELEGRAM_BOT_TOKEN,
    mask: true
  }
];
async function parseEnvFile(path) {
  try {
    const content = await import_fs_extra3.readFile(path, "utf-8");
    const env = {};
    for (const line of content.split(`
`)) {
      let trimmed = line.trim();
      if (!trimmed || trimmed.startsWith("#"))
        continue;
      if (trimmed.startsWith("export ")) {
        trimmed = trimmed.slice(7);
      }
      const [key, ...valueParts] = trimmed.split("=");
      if (key) {
        let value = valueParts.join("=").trim();
        if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
          value = value.slice(1, -1);
        }
        env[key.trim()] = value.trim();
      }
    }
    return env;
  } catch (error) {
    logger.debug(`Failed to parse .env file at ${path}: ${error}`);
    return {};
  }
}
async function checkGlobalConfig() {
  const globalEnvPath = join13(PathResolver.getGlobalKitDir(), ".env");
  if (!await import_fs_extra3.pathExists(globalEnvPath))
    return false;
  const env = await parseEnvFile(globalEnvPath);
  return Object.keys(env).length > 0;
}
async function runSetupWizard(options) {
  const { targetDir, isGlobal } = options;
  if (isGlobal) {
    f2.info("Configuring global defaults (shared across all projects)");
  } else {
    f2.info("Configuring project-specific settings");
  }
  let globalEnv = {};
  const hasGlobalConfig = !isGlobal && await checkGlobalConfig();
  if (!isGlobal) {
    const globalEnvPath = join13(PathResolver.getGlobalKitDir(), ".env");
    if (await import_fs_extra3.pathExists(globalEnvPath)) {
      globalEnv = await parseEnvFile(globalEnvPath);
    }
  }
  if (hasGlobalConfig && Object.keys(globalEnv).length > 0) {
    f2.success("Global config detected - values will be inherited automatically");
  }
  const values = {};
  for (const config of ESSENTIAL_CONFIGS) {
    const globalValue = globalEnv[config.key] || "";
    const hasGlobalValue = !isGlobal && !!globalValue;
    if (hasGlobalValue) {
      const maskedValue = config.mask ? `${globalValue.slice(0, 8)}...` : globalValue;
      const useGlobal = await se({
        message: `${config.label}: Use global value? (${maskedValue})`,
        initialValue: true
      });
      if (lD(useGlobal)) {
        f2.warning("Setup cancelled");
        return false;
      }
      if (useGlobal) {
        values[config.key] = globalValue;
        f2.success(`${config.key}: inherited from global config`);
        continue;
      }
    }
    const result = await te({
      message: config.label,
      placeholder: config.hint,
      validate: (value) => {
        if (!value && !config.required) {
          return;
        }
        if (!value && config.required) {
          return "This field is required";
        }
        if (value && config.validate && !validateApiKey(value, config.validate)) {
          return "Invalid format. Please check and try again.";
        }
        return;
      }
    });
    if (lD(result)) {
      f2.warning("Setup cancelled");
      return false;
    }
    if (typeof result === "string" && result) {
      values[config.key] = result;
    }
  }
  if (values.GEMINI_API_KEY) {
    const additionalKeys = await promptForAdditionalGeminiKeys(values.GEMINI_API_KEY);
    for (let i = 0;i < additionalKeys.length; i++) {
      values[`GEMINI_API_KEY_${i + 2}`] = additionalKeys[i];
    }
    const totalKeys = 1 + additionalKeys.length;
    if (totalKeys > 1) {
      f2.success(` Configured ${totalKeys} Gemini API keys for rotation`);
    }
  }
  await generateEnvFile(targetDir, values);
  f2.success(`Configuration saved to ${join13(targetDir, ".env")}`);
  return true;
}
async function promptForAdditionalGeminiKeys(primaryKey) {
  const additionalKeys = [];
  const allKeys = new Set([primaryKey]);
  const wantMore = await se({
    message: "Add additional API keys for rotation? (recommended for high usage)",
    initialValue: false
  });
  if (lD(wantMore) || !wantMore) {
    return additionalKeys;
  }
  let keyNumber = 2;
  const maxKeys = 10;
  while (keyNumber <= maxKeys) {
    const result = await te({
      message: `Gemini API Key #${keyNumber} (press Enter to finish)`,
      placeholder: "AIza... or leave empty to finish",
      validate: (value) => {
        if (!value)
          return;
        const trimmed = value.trim();
        if (!trimmed)
          return;
        if (!validateApiKey(trimmed, VALIDATION_PATTERNS.GEMINI_API_KEY)) {
          return "Invalid format. Gemini keys start with 'AIza' and are 39 characters.";
        }
        if (allKeys.has(trimmed)) {
          return "This key was already added. Please enter a different key.";
        }
        return;
      }
    });
    if (lD(result)) {
      break;
    }
    if (!result || result.trim() === "") {
      break;
    }
    const trimmedKey = result.trim();
    additionalKeys.push(trimmedKey);
    allKeys.add(trimmedKey);
    keyNumber++;
  }
  return additionalKeys;
}
async function promptSetupWizardIfNeeded(options) {
  const { envPath, claudeDir, isGlobal, isNonInteractive: isNonInteractive2, prompts } = options;
  if (isNonInteractive2) {
    return;
  }
  const { allPresent, missing, envExists } = await checkRequiredKeysExist(envPath);
  if (allPresent) {
    return;
  }
  const missingKeys = missing.map((m2) => m2.label).join(", ");
  const promptMessage = envExists ? `Missing required: ${missingKeys}. Set up now?` : "Set up API keys now? (Gemini API key for ai-multimodal skill, optional webhooks)";
  const shouldSetup = await prompts.confirm(promptMessage);
  if (shouldSetup) {
    await runSetupWizard({
      targetDir: claudeDir,
      isGlobal
    });
  } else {
    prompts.note(`Create ${envPath} manually or run 'ck init' again.
Required: GEMINI_API_KEY
Optional: DISCORD_WEBHOOK_URL, TELEGRAM_BOT_TOKEN`, "Configuration skipped");
  }
}

// src/domains/health-checks/checkers/env-keys-checker.ts
async function checkEnvKeys(setup) {
  const results = [];
  if (setup.global.path) {
    const globalEnvPath = join14(setup.global.path, ".env");
    const globalCheck = await checkRequiredKeysExist(globalEnvPath);
    if (!globalCheck.allPresent) {
      const missingKeys = globalCheck.missing.map((m2) => m2.label).join(", ");
      results.push({
        id: "ck-global-env-keys",
        name: "Global Environment Keys",
        group: "claudekit",
        priority: "standard",
        status: "warn",
        message: globalCheck.envExists ? `Missing: ${missingKeys}` : ".env file not found",
        details: globalEnvPath,
        suggestion: "Run: ck init --global",
        autoFixable: false
      });
    } else {
      results.push({
        id: "ck-global-env-keys",
        name: "Global Environment Keys",
        group: "claudekit",
        priority: "standard",
        status: "pass",
        message: `${REQUIRED_ENV_KEYS.length} required key(s) configured`,
        details: globalEnvPath,
        autoFixable: false
      });
    }
  }
  if (setup.project.metadata) {
    const projectEnvPath = join14(setup.project.path, ".env");
    const projectCheck = await checkRequiredKeysExist(projectEnvPath);
    if (!projectCheck.allPresent) {
      const missingKeys = projectCheck.missing.map((m2) => m2.label).join(", ");
      results.push({
        id: "ck-project-env-keys",
        name: "Project Environment Keys",
        group: "claudekit",
        priority: "standard",
        status: "warn",
        message: projectCheck.envExists ? `Missing: ${missingKeys}` : ".env file not found",
        details: projectEnvPath,
        suggestion: "Run: ck init",
        autoFixable: false
      });
    } else {
      results.push({
        id: "ck-project-env-keys",
        name: "Project Environment Keys",
        group: "claudekit",
        priority: "standard",
        status: "pass",
        message: `${REQUIRED_ENV_KEYS.length} required key(s) configured`,
        details: projectEnvPath,
        autoFixable: false
      });
    }
  }
  return results;
}
// src/domains/health-checks/claudekit-checker.ts
class ClaudekitChecker {
  group = "claudekit";
  projectDir;
  constructor(projectDir = process.cwd()) {
    this.projectDir = projectDir;
  }
  async run() {
    logger.verbose("ClaudekitChecker: Scanning ClaudeKit setup", {
      projectDir: this.projectDir
    });
    const setup = await getClaudeKitSetup(this.projectDir);
    logger.verbose("ClaudekitChecker: Setup scan complete");
    const results = [];
    logger.verbose("ClaudekitChecker: Checking CLI install method");
    results.push(await checkCliInstallMethod());
    logger.verbose("ClaudekitChecker: Checking global install");
    results.push(checkGlobalInstall(setup));
    logger.verbose("ClaudekitChecker: Checking project install");
    results.push(checkProjectInstall(setup));
    logger.verbose("ClaudekitChecker: Checking CLAUDE.md files");
    results.push(...checkClaudeMd(setup, this.projectDir));
    logger.verbose("ClaudekitChecker: Checking active plan");
    results.push(checkActivePlan(this.projectDir));
    logger.verbose("ClaudekitChecker: Checking skills scripts");
    results.push(...checkSkillsScripts(setup));
    logger.verbose("ClaudekitChecker: Checking component counts");
    results.push(checkComponentCounts(setup));
    logger.verbose("ClaudekitChecker: Checking required environment keys");
    results.push(...await checkEnvKeys(setup));
    logger.verbose("ClaudekitChecker: Checking global dir readability");
    results.push(await checkGlobalDirReadable());
    logger.verbose("ClaudekitChecker: Checking global dir writability");
    results.push(await checkGlobalDirWritable());
    logger.verbose("ClaudekitChecker: Checking hooks directory");
    results.push(await checkHooksExist(this.projectDir));
    logger.verbose("ClaudekitChecker: Checking settings.json validity");
    results.push(await checkSettingsValid(this.projectDir));
    logger.verbose("ClaudekitChecker: Checking path references");
    results.push(await checkPathRefsValid(this.projectDir));
    logger.verbose("ClaudekitChecker: Checking project config completeness");
    results.push(await checkProjectConfigCompleteness(setup, this.projectDir));
    logger.verbose("ClaudekitChecker: All checks complete");
    return results;
  }
}
// src/domains/health-checks/auth-checker.ts
init_github_auth();
import { spawnSync as spawnSync2 } from "node:child_process";

// src/domains/installation/git-clone-manager.ts
init_logger();
import { execSync as execSync2 } from "node:child_process";
import * as fs2 from "node:fs";
import * as os from "node:os";
import * as path from "node:path";
var VALID_TAG_PATTERN = /^[a-zA-Z0-9._+\-]+$/;

class GitCloneManager {
  tempBaseDir;
  constructor() {
    const homeDir = process.env.HOME || process.env.USERPROFILE;
    this.tempBaseDir = process.env.TMPDIR || process.env.TEMP || process.env.TMP || (homeDir ? path.join(homeDir, ".claudekit", "tmp") : null) || path.join(os.tmpdir(), ".claudekit", "tmp");
  }
  validateTag(tag) {
    if (!VALID_TAG_PATTERN.test(tag)) {
      throw new Error(`Invalid tag format: "${tag}"

Tags must contain only letters, numbers, dots, hyphens, underscores, and plus signs.`);
    }
  }
  async clone(options) {
    const { kit, tag, preferSsh = true, timeout = 60000 } = options;
    this.validateTag(tag);
    try {
      await fs2.promises.mkdir(this.tempBaseDir, { recursive: true });
    } catch (error) {
      const msg = error instanceof Error ? error.message : String(error);
      throw new Error(`Failed to create temp directory: ${this.tempBaseDir}
Error: ${msg}

Check disk space and directory permissions.`);
    }
    const tempDir = await fs2.promises.mkdtemp(path.join(this.tempBaseDir, `ck-git-${kit.repo}-`));
    const url = preferSsh ? `git@github.com:${kit.owner}/${kit.repo}.git` : `https://github.com/${kit.owner}/${kit.repo}.git`;
    const method = preferSsh ? "ssh" : "https";
    logger.verbose("Git clone", { url, tag, tempDir, method });
    try {
      const quotedUrl = `"${url}"`;
      const quotedDir = `"${tempDir}"`;
      try {
        execSync2(`git clone --depth 1 --branch "${tag}" ${quotedUrl} ${quotedDir}`, {
          stdio: ["pipe", "pipe", "pipe"],
          timeout,
          encoding: "utf-8"
        });
      } catch (shallowError) {
        const stderr = shallowError?.stderr || "";
        if (stderr.includes("Could not find remote branch") || stderr.includes("fatal: Remote branch") || stderr.includes("warning: Could not find remote branch")) {
          logger.debug(`Shallow clone failed for tag ${tag}, trying full clone...`);
          await fs2.promises.rm(tempDir, { recursive: true, force: true }).catch(() => {});
          await fs2.promises.mkdir(tempDir, { recursive: true });
          execSync2(`git clone --no-checkout ${quotedUrl} ${quotedDir}`, {
            stdio: ["pipe", "pipe", "pipe"],
            timeout,
            encoding: "utf-8"
          });
          execSync2(`git -C ${quotedDir} checkout "tags/${tag}"`, {
            stdio: ["pipe", "pipe", "pipe"],
            timeout: 30000,
            encoding: "utf-8"
          });
        } else {
          throw shallowError;
        }
      }
      const gitDir = path.join(tempDir, ".git");
      await fs2.promises.rm(gitDir, { recursive: true, force: true });
      logger.debug(`Git clone successful: ${tempDir}`);
      return {
        cloneDir: tempDir,
        url,
        method
      };
    } catch (error) {
      await fs2.promises.rm(tempDir, { recursive: true, force: true }).catch((err) => logger.debug(`Failed to cleanup temp dir ${tempDir}: ${err.message}`));
      const errorMessage = error instanceof Error ? error.message : String(error);
      const stderr = error?.stderr || "";
      const errorCode = error?.code;
      if (errorCode === "ENOSPC" || stderr.includes("No space left")) {
        throw new Error(`Git clone failed: No disk space available.

` + `Free up disk space and try again, or use a different temp directory:
` + "  export TMPDIR=/path/to/larger/disk");
      }
      if (preferSsh && (stderr.includes("Permission denied") || stderr.includes("Host key verification"))) {
        logger.debug("SSH clone failed, user may need to add SSH key to GitHub");
        throw new Error(`Git clone failed: SSH authentication error.

Your SSH key may not be configured for GitHub.

Solutions:
  1. Add your SSH key to GitHub: github.com/settings/keys
  2. Use HTTPS instead: ck new --use-git=https
  3. Use GitHub CLI: gh auth login

Original error: ${stderr || errorMessage}`);
      }
      throw new Error(`Git clone failed: ${stderr || errorMessage}

Ensure you have access to the repository and your git credentials are configured.`);
    }
  }
  static isGitInstalled() {
    try {
      execSync2("git --version", { stdio: "ignore", timeout: 5000 });
      return true;
    } catch {
      return false;
    }
  }
  static hasSshKeys() {
    const homeDir = process.env.HOME || process.env.USERPROFILE;
    if (!homeDir)
      return false;
    const sshDir = path.join(homeDir, ".ssh");
    const keyFiles = ["id_rsa", "id_ed25519", "id_ecdsa", "id_rsa.pub", "id_ed25519.pub"];
    try {
      if (!fs2.existsSync(sshDir))
        return false;
      for (const keyFile of keyFiles) {
        if (fs2.existsSync(path.join(sshDir, keyFile))) {
          return true;
        }
      }
    } catch {}
    return false;
  }
  static async testSshConnection() {
    try {
      execSync2("ssh -T git@github.com 2>&1 || true", {
        encoding: "utf-8",
        timeout: 1e4
      });
      return true;
    } catch {
      return false;
    }
  }
}

// src/domains/health-checks/auth-checker.ts
init_logger();
var MIN_TOKEN_LENGTH_FOR_MASKING = 8;
var COMMAND_TIMEOUT_MS2 = 5000;
function maskToken(token) {
  if (!token || token.length < MIN_TOKEN_LENGTH_FOR_MASKING) {
    return "***";
  }
  return `${token.substring(0, 4)}${"*".repeat(4)}...`;
}

class AuthChecker {
  group = "auth";
  kits;
  constructor(kits = ["engineer"]) {
    this.kits = kits;
  }
  async run() {
    logger.verbose("AuthChecker: Starting authentication checks");
    const results = [];
    let apiCheckers;
    try {
      apiCheckers = await Promise.resolve().then(() => (init_github_api_checker(), exports_github_api_checker));
    } catch (importError) {
      logger.verbose("AuthChecker: Failed to import API checkers", { importError });
      results.push({
        id: "api-checkers-import",
        name: "API Checkers",
        group: "auth",
        status: "fail",
        message: "Failed to load API health checkers",
        details: importError instanceof Error ? importError.message : "Unknown import error",
        autoFixable: false
      });
      results.push(this.checkEnvAuth());
      results.push(this.checkGitAvailable());
      results.push(await this.checkGhAuth());
      results.push(await this.checkGhToken());
      return results;
    }
    logger.verbose("AuthChecker: Checking environment variable auth");
    results.push(this.checkEnvAuth());
    logger.verbose("AuthChecker: Checking git availability");
    results.push(this.checkGitAvailable());
    logger.verbose("AuthChecker: Checking GitHub CLI auth status");
    results.push(await this.checkGhAuth());
    logger.verbose("AuthChecker: Checking GitHub token");
    results.push(await this.checkGhToken());
    logger.verbose("AuthChecker: Running parallel API checks");
    const [rateLimitResult, tokenScopesResult, ...repoAccessResults] = await Promise.all([
      apiCheckers.checkRateLimit(),
      apiCheckers.checkTokenScopes(),
      ...this.kits.map((kit) => apiCheckers.checkRepositoryAccess(kit))
    ]);
    results.push(rateLimitResult);
    results.push(tokenScopesResult);
    results.push(...repoAccessResults);
    logger.verbose("AuthChecker: All auth checks complete");
    return results;
  }
  checkEnvAuth() {
    const hasToken = AuthManager.hasEnvToken();
    const envVar = process.env.GITHUB_TOKEN ? "GITHUB_TOKEN" : process.env.GH_TOKEN ? "GH_TOKEN" : null;
    if (hasToken && envVar) {
      const token = process.env[envVar] || "";
      return {
        id: "env-token",
        name: "Environment Token",
        group: "auth",
        status: "pass",
        message: `${envVar} is set`,
        details: `Token: ${maskToken(token)}`,
        autoFixable: false
      };
    }
    return {
      id: "env-token",
      name: "Environment Token",
      group: "auth",
      status: "info",
      message: "Not configured (optional)",
      suggestion: "Set GITHUB_TOKEN for CI/CD or when gh CLI is not available",
      autoFixable: false
    };
  }
  checkGitAvailable() {
    const gitInstalled = GitCloneManager.isGitInstalled();
    const hasSshKeys = GitCloneManager.hasSshKeys();
    if (!gitInstalled) {
      return {
        id: "git-available",
        name: "Git (for --use-git)",
        group: "auth",
        status: "info",
        message: "Git not installed",
        suggestion: "Install git to use --use-git flag: https://git-scm.com/downloads",
        autoFixable: false
      };
    }
    if (hasSshKeys) {
      return {
        id: "git-available",
        name: "Git (for --use-git)",
        group: "auth",
        status: "pass",
        message: "Git installed, SSH keys detected",
        details: "Can use --use-git for secure cloning",
        autoFixable: false
      };
    }
    return {
      id: "git-available",
      name: "Git (for --use-git)",
      group: "auth",
      status: "pass",
      message: "Git installed (no SSH keys)",
      details: "Will use HTTPS for --use-git",
      autoFixable: false
    };
  }
  async checkGhAuth() {
    if (false) {}
    try {
      logger.verbose("AuthChecker: Running 'gh auth status -h github.com' command");
      const result = spawnSync2("gh", ["auth", "status", "-h", "github.com"], {
        encoding: "utf8",
        timeout: COMMAND_TIMEOUT_MS2
      });
      if (result.status !== 0 || result.error) {
        throw new Error(result.stderr || result.stdout || "Not authenticated");
      }
      logger.verbose("AuthChecker: gh auth status succeeded");
      return {
        id: "gh-auth-status",
        name: "GitHub CLI Auth",
        group: "auth",
        status: "pass",
        message: "Authenticated via GitHub CLI",
        autoFixable: false
      };
    } catch {
      return {
        id: "gh-auth-status",
        name: "GitHub CLI Auth",
        group: "auth",
        status: "warn",
        message: "Not authenticated",
        suggestion: "Run: gh auth login -h github.com (select 'Login with a web browser')",
        autoFixable: true,
        fix: this.createGhAuthFix()
      };
    }
  }
  async checkGhToken() {
    if (false) {}
    try {
      logger.verbose("AuthChecker: Getting GitHub token via AuthManager");
      const { token } = await AuthManager.getToken();
      logger.verbose("AuthChecker: Token retrieved successfully");
      return {
        id: "gh-token",
        name: "GitHub Token",
        group: "auth",
        status: "pass",
        message: "Token available",
        details: `Token: ${maskToken(token)}`,
        autoFixable: false
      };
    } catch (error) {
      return {
        id: "gh-token",
        name: "GitHub Token",
        group: "auth",
        status: "fail",
        message: "Token not available",
        details: error instanceof Error ? error.message : "Unknown error",
        suggestion: "Run: gh auth login (select 'Login with a web browser')",
        autoFixable: true,
        fix: this.createGhAuthFix()
      };
    }
  }
  createGhAuthFix() {
    return {
      id: "gh-auth-login",
      description: "Authenticate with GitHub CLI",
      execute: async () => {
        return {
          success: false,
          message: "Run manually: gh auth login -h github.com (select 'Login with a web browser')",
          details: "This command requires interactive input. Use web browser login, not PAT."
        };
      }
    };
  }
}
// src/domains/health-checks/platform-checker.ts
import { platform as platform4 } from "node:os";

// src/domains/health-checks/platform/environment-checker.ts
init_path_resolver();
import { constants as constants2, access as access2, mkdir as mkdir3, readFile as readFile7, unlink as unlink3, writeFile as writeFile5 } from "node:fs/promises";
import { arch, homedir as homedir3, platform as platform3 } from "node:os";
import { join as join17, normalize as normalize4 } from "node:path";
var IS_WINDOWS = platform3() === "win32";
function shouldSkipExpensiveOperations4() {
  if (process.env.CK_TEST_HOME) {
    return false;
  }
  return process.env.CI === "true" || process.env.CI_SAFE_MODE === "true";
}
async function checkPlatformDetect() {
  const os2 = platform3();
  const architecture = arch();
  const wslDistro = process.env.WSL_DISTRO_NAME;
  let message = `${os2} (${architecture})`;
  if (wslDistro)
    message += ` - WSL: ${wslDistro}`;
  return {
    id: "platform-detect",
    name: "Platform",
    group: "platform",
    priority: "standard",
    status: "info",
    message,
    autoFixable: false
  };
}
async function checkHomeDirResolution() {
  const nodeHome = normalize4(homedir3());
  const envHome = normalize4(IS_WINDOWS ? process.env.USERPROFILE || "" : process.env.HOME || "");
  const match = nodeHome === envHome && envHome !== "";
  return {
    id: "home-dir-resolution",
    name: "Home Directory",
    group: "platform",
    priority: "standard",
    status: match ? "pass" : "warn",
    message: match ? nodeHome : `Mismatch: Node=${nodeHome}, Env=${envHome || "not set"}`,
    suggestion: !match ? "homedir() differs from environment. May cause path issues." : undefined,
    autoFixable: false
  };
}
async function checkEnvVarExpansion() {
  const userProfile = process.env.USERPROFILE;
  if (!userProfile) {
    return {
      id: "env-var-expansion",
      name: "Env Var Expansion",
      group: "platform",
      priority: "standard",
      status: "fail",
      message: "USERPROFILE not set",
      suggestion: "Environment variable USERPROFILE is not set",
      autoFixable: false
    };
  }
  try {
    await access2(userProfile, constants2.F_OK);
    return {
      id: "env-var-expansion",
      name: "Env Var Expansion",
      group: "platform",
      priority: "standard",
      status: "pass",
      message: "USERPROFILE expands correctly",
      details: userProfile,
      autoFixable: false
    };
  } catch {
    return {
      id: "env-var-expansion",
      name: "Env Var Expansion",
      group: "platform",
      priority: "standard",
      status: "fail",
      message: "USERPROFILE path not accessible",
      details: userProfile,
      suggestion: "Check if USERPROFILE directory exists and is accessible",
      autoFixable: false
    };
  }
}
async function checkGlobalDirAccess() {
  const globalDir = PathResolver.getGlobalKitDir();
  if (shouldSkipExpensiveOperations4()) {
    return {
      id: "global-dir-access",
      name: "Global Dir Access",
      group: "platform",
      priority: "critical",
      status: "info",
      message: "Skipped in CI/test environment",
      details: globalDir,
      autoFixable: false
    };
  }
  const testFile = join17(globalDir, ".ck-doctor-access-test");
  try {
    await mkdir3(globalDir, { recursive: true });
    await writeFile5(testFile, "test", "utf-8");
    const content = await readFile7(testFile, "utf-8");
    await unlink3(testFile);
    if (content !== "test")
      throw new Error("Read mismatch");
    return {
      id: "global-dir-access",
      name: "Global Dir Access",
      group: "platform",
      priority: "critical",
      status: "pass",
      message: "Read/write OK",
      details: globalDir,
      autoFixable: false
    };
  } catch (error) {
    return {
      id: "global-dir-access",
      name: "Global Dir Access",
      group: "platform",
      priority: "critical",
      status: "fail",
      message: `Access denied: ${error instanceof Error ? error.message : "unknown"}`,
      details: globalDir,
      suggestion: "Check file permissions on ~/.claude/ directory",
      autoFixable: false
    };
  }
}

// src/domains/health-checks/platform/shell-checker.ts
async function checkShellDetection() {
  const shell = process.env.SHELL || process.env.ComSpec || "unknown";
  let shellName = "Unknown";
  if (shell.includes("pwsh") || shell.includes("powershell")) {
    shellName = shell.includes("pwsh") ? "PowerShell Core" : "Windows PowerShell";
  } else if (shell.includes("cmd")) {
    shellName = "Command Prompt";
  } else if (shell.includes("bash")) {
    shellName = "Bash";
  } else if (shell.includes("zsh")) {
    shellName = "Zsh";
  } else if (shell.includes("fish")) {
    shellName = "Fish";
  }
  return {
    id: "shell-detection",
    name: "Shell",
    group: "platform",
    priority: "standard",
    status: "info",
    message: shellName,
    details: shell,
    autoFixable: false
  };
}
async function checkWSLBoundary() {
  const cwd = process.cwd();
  const accessingWindows = cwd.startsWith("/mnt/");
  return {
    id: "wsl-boundary",
    name: "WSL Boundary",
    group: "platform",
    priority: "standard",
    status: accessingWindows ? "warn" : "pass",
    message: accessingWindows ? "Working in Windows filesystem from WSL" : "Working in native Linux filesystem",
    details: cwd,
    suggestion: accessingWindows ? "Performance may be slower. Consider using native Linux paths." : undefined,
    autoFixable: false
  };
}

// src/domains/health-checks/platform/windows-checker.ts
init_path_resolver();
import { mkdir as mkdir4, symlink, unlink as unlink4, writeFile as writeFile6 } from "node:fs/promises";
import { join as join18 } from "node:path";
async function checkLongPathSupport() {
  if (shouldSkipExpensiveOperations4()) {
    return {
      id: "long-path-support",
      name: "Long Path Support",
      group: "platform",
      priority: "extended",
      status: "info",
      message: "Skipped in CI/test environment",
      autoFixable: false
    };
  }
  try {
    const { execSync: execSync3 } = await import("node:child_process");
    const result = execSync3('reg query "HKLM\\SYSTEM\\CurrentControlSet\\Control\\FileSystem" /v LongPathsEnabled', { encoding: "utf-8", timeout: 2000 });
    const enabled = result.includes("0x1");
    return {
      id: "long-path-support",
      name: "Long Path Support",
      group: "platform",
      priority: "extended",
      status: enabled ? "pass" : "warn",
      message: enabled ? "Enabled" : "Disabled (260 char limit)",
      suggestion: !enabled ? 'Enable long paths: run as admin: reg add "HKLM\\SYSTEM\\CurrentControlSet\\Control\\FileSystem" /v LongPathsEnabled /t REG_DWORD /d 1 /f' : undefined,
      autoFixable: false
    };
  } catch {
    return {
      id: "long-path-support",
      name: "Long Path Support",
      group: "platform",
      priority: "extended",
      status: "info",
      message: "Could not determine (requires admin)",
      autoFixable: false
    };
  }
}
async function checkSymlinkSupport() {
  if (shouldSkipExpensiveOperations4()) {
    return {
      id: "symlink-support",
      name: "Symlink Support",
      group: "platform",
      priority: "extended",
      status: "info",
      message: "Skipped in CI/test environment",
      autoFixable: false
    };
  }
  const testDir = PathResolver.getGlobalKitDir();
  const target = join18(testDir, ".ck-symlink-test-target");
  const link = join18(testDir, ".ck-symlink-test-link");
  try {
    await mkdir4(testDir, { recursive: true });
    await writeFile6(target, "test", "utf-8");
    await symlink(target, link);
    await unlink4(link);
    await unlink4(target);
    return {
      id: "symlink-support",
      name: "Symlink Support",
      group: "platform",
      priority: "extended",
      status: "pass",
      message: "Symlinks work",
      autoFixable: false
    };
  } catch (error) {
    try {
      await unlink4(link).catch(() => {});
      await unlink4(target).catch(() => {});
    } catch {}
    return {
      id: "symlink-support",
      name: "Symlink Support",
      group: "platform",
      priority: "extended",
      status: "warn",
      message: "Symlinks not available",
      suggestion: "Enable Developer Mode or run as admin for symlink support",
      details: error instanceof Error ? error.message : "unknown error",
      autoFixable: false
    };
  }
}

// src/domains/health-checks/platform-checker.ts
var IS_WINDOWS2 = platform4() === "win32";

class PlatformChecker {
  group = "platform";
  async run() {
    const results = [];
    results.push(await checkPlatformDetect());
    results.push(await checkHomeDirResolution());
    if (IS_WINDOWS2) {
      results.push(await checkEnvVarExpansion());
    }
    results.push(await checkGlobalDirAccess());
    results.push(await checkShellDetection());
    if (this.isWSL()) {
      results.push(await checkWSLBoundary());
    }
    if (IS_WINDOWS2) {
      results.push(await checkLongPathSupport());
      results.push(await checkSymlinkSupport());
    }
    return results;
  }
  isWSL() {
    return !!process.env.WSL_DISTRO_NAME || process.env.WSLENV !== undefined;
  }
}
// src/domains/health-checks/network-checker.ts
init_logger();
var NETWORK_TIMEOUT = Number.parseInt(process.env.CLAUDEKIT_NETWORK_TIMEOUT || "3000", 10);

class NetworkChecker {
  group = "network";
  async run() {
    if (this.isCI()) {
      logger.verbose("NetworkChecker: Skipping in CI environment");
      return [];
    }
    const results = [];
    results.push(this.checkProxyDetected());
    results.push(await this.checkGitHubReachable());
    results.push(await this.checkApiGitHub());
    return results;
  }
  isCI() {
    return process.env.CI === "true" || process.env.CI_SAFE_MODE === "true" || false || process.env.VITEST === "true" || process.env.JEST_WORKER_ID !== undefined || process.env.TEST === "true";
  }
  checkProxyDetected() {
    const httpProxy = process.env.HTTP_PROXY || process.env.http_proxy;
    const httpsProxy = process.env.HTTPS_PROXY || process.env.https_proxy;
    const noProxy = process.env.NO_PROXY || process.env.no_proxy;
    const hasProxy = !!(httpProxy || httpsProxy);
    if (!hasProxy) {
      return {
        id: "net-proxy-detected",
        name: "Proxy",
        group: "network",
        priority: "standard",
        status: "info",
        message: "No proxy configured",
        autoFixable: false
      };
    }
    const details = [];
    if (httpProxy)
      details.push(`HTTP_PROXY=${httpProxy}`);
    if (httpsProxy)
      details.push(`HTTPS_PROXY=${httpsProxy}`);
    if (noProxy)
      details.push(`NO_PROXY=${noProxy}`);
    return {
      id: "net-proxy-detected",
      name: "Proxy",
      group: "network",
      priority: "standard",
      status: "warn",
      message: "Proxy detected",
      details: details.join(", "),
      suggestion: "Ensure proxy settings allow access to github.com",
      autoFixable: false
    };
  }
  async checkGitHubReachable() {
    const startTime = Date.now();
    try {
      const response = await fetch("https://github.com", {
        method: "HEAD",
        signal: AbortSignal.timeout(NETWORK_TIMEOUT)
      });
      const latency = Date.now() - startTime;
      if (response.ok || response.status === 301 || response.status === 302) {
        return {
          id: "net-github-reachable",
          name: "GitHub",
          group: "network",
          priority: "standard",
          status: "pass",
          message: `Connected (${latency}ms)`,
          autoFixable: false
        };
      }
      return {
        id: "net-github-reachable",
        name: "GitHub",
        group: "network",
        priority: "standard",
        status: "warn",
        message: `HTTP ${response.status}`,
        suggestion: "GitHub returned unexpected status",
        autoFixable: false
      };
    } catch (error) {
      const isTimeout = error instanceof Error && error.name === "AbortError";
      return {
        id: "net-github-reachable",
        name: "GitHub",
        group: "network",
        priority: "standard",
        status: "fail",
        message: isTimeout ? `Timeout (>${NETWORK_TIMEOUT}ms)` : "Connection failed",
        suggestion: "Check internet connection or proxy settings",
        autoFixable: false
      };
    }
  }
  async checkApiGitHub() {
    const startTime = Date.now();
    try {
      const response = await fetch("https://api.github.com/rate_limit", {
        method: "GET",
        headers: {
          Accept: "application/vnd.github.v3+json",
          "User-Agent": "claudekit-cli"
        },
        signal: AbortSignal.timeout(NETWORK_TIMEOUT)
      });
      const latency = Date.now() - startTime;
      if (response.ok) {
        return {
          id: "net-api-github",
          name: "GitHub API",
          group: "network",
          priority: "standard",
          status: "pass",
          message: `Connected (${latency}ms)`,
          autoFixable: false
        };
      }
      return {
        id: "net-api-github",
        name: "GitHub API",
        group: "network",
        priority: "standard",
        status: "warn",
        message: `HTTP ${response.status}`,
        suggestion: response.status === 403 ? "Rate limited - wait or authenticate" : "API returned unexpected status",
        autoFixable: false
      };
    } catch (error) {
      const isTimeout = error instanceof Error && error.name === "AbortError";
      return {
        id: "net-api-github",
        name: "GitHub API",
        group: "network",
        priority: "standard",
        status: "fail",
        message: isTimeout ? `Timeout (>${NETWORK_TIMEOUT}ms)` : "Connection failed",
        suggestion: "Check internet connection or proxy settings for api.github.com",
        autoFixable: false
      };
    }
  }
}
// src/domains/health-checks/auto-healer.ts
class AutoHealer {
  timeout;
  constructor(options = {}) {
    this.timeout = options.timeout ?? 30000;
  }
  async healAll(checks) {
    const fixable = checks.filter((c2) => c2.autoFixable && c2.fix && c2.status !== "pass");
    const fixes = [];
    for (const check of fixable) {
      const attempt = await this.executeFix(check);
      fixes.push(attempt);
      check.fixed = attempt.success;
      if (!attempt.success && attempt.error) {
        check.fixError = attempt.error;
      }
    }
    return {
      totalFixable: fixable.length,
      attempted: fixes.length,
      succeeded: fixes.filter((f3) => f3.success).length,
      failed: fixes.filter((f3) => !f3.success).length,
      fixes
    };
  }
  async executeFix(check) {
    const fix = check.fix;
    if (!fix) {
      return {
        checkId: check.id,
        checkName: check.name,
        fixId: "unknown",
        success: false,
        message: "No fix available",
        error: "Fix action not defined",
        duration: 0
      };
    }
    const start = Date.now();
    try {
      const result = await Promise.race([fix.execute(), this.createTimeout()]);
      const attempt = this.buildAttempt(check, fix.id, result);
      attempt.duration = Date.now() - start;
      return attempt;
    } catch (e2) {
      const err = e2 instanceof Error ? e2.message : "Unknown error";
      return {
        checkId: check.id,
        checkName: check.name,
        fixId: fix.id,
        success: false,
        message: "Fix failed",
        error: err,
        duration: Date.now() - start
      };
    }
  }
  buildAttempt(check, fixId, result) {
    return {
      checkId: check.id,
      checkName: check.name,
      fixId,
      success: result.success,
      message: result.message,
      error: result.success ? undefined : result.message,
      duration: 0
    };
  }
  createTimeout() {
    return new Promise((_3, reject) => {
      setTimeout(() => reject(new Error(`Fix timed out after ${this.timeout}ms`)), this.timeout);
    });
  }
}
// src/domains/health-checks/report-generator.ts
import { execSync as execSync3, spawnSync as spawnSync3 } from "node:child_process";
import { readFileSync as readFileSync5, unlinkSync, writeFileSync } from "node:fs";
import { tmpdir as tmpdir2 } from "node:os";
import { dirname as dirname2, join as join19 } from "node:path";
import { fileURLToPath } from "node:url";
init_environment();
init_logger();
init_dist2();
function getCliVersion() {
  try {
    const __dirname2 = dirname2(fileURLToPath(import.meta.url));
    const pkgPath = join19(__dirname2, "../../../package.json");
    const pkg = JSON.parse(readFileSync5(pkgPath, "utf-8"));
    return pkg.version || "unknown";
  } catch (err) {
    logger.debug(`Failed to read CLI version: ${err}`);
    return "unknown";
  }
}

class ReportGenerator {
  generate(summary, options) {
    return options.format === "json" ? this.generateJsonReport(summary) : this.generateTextReport(summary);
  }
  generateTextReport(summary) {
    const lines = [];
    const divider = "=".repeat(65);
    const sectionDivider = "".repeat(65);
    lines.push(divider);
    lines.push("CLAUDEKIT DIAGNOSTIC REPORT");
    lines.push(`Generated: ${summary.timestamp}`);
    lines.push(`CLI Version: ${this.getSystemInfo().cliVersion}`);
    lines.push(divider);
    const issues = summary.checks.filter((c2) => c2.status === "warn" || c2.status === "fail");
    if (issues.length > 0) {
      lines.push("");
      lines.push("  ISSUES FOUND");
      lines.push(sectionDivider);
      for (const issue of issues) {
        const icon = this.getStatusIcon(issue.status);
        lines.push(`  ${icon} ${issue.name}: ${issue.message}`);
        if (issue.details) {
          lines.push(`         Path: ${this.scrubPath(issue.details)}`);
        }
        if (issue.suggestion) {
          lines.push(`         Fix:  ${issue.suggestion}`);
        }
      }
    }
    const system = this.getSystemInfo();
    lines.push("");
    lines.push("ENVIRONMENT");
    lines.push(sectionDivider);
    lines.push(`  OS:       ${system.os} ${system.osVersion}`);
    lines.push(`  Node:     ${system.node}`);
    lines.push(`  CWD:      ${this.scrubPath(system.cwd)}`);
    const groups = this.groupChecks(summary.checks);
    for (const [groupName, checks] of groups) {
      lines.push("");
      lines.push(groupName.toUpperCase());
      lines.push(sectionDivider);
      for (const check of checks) {
        const icon = this.getStatusSymbol(check.status);
        lines.push(`  ${icon} ${check.name.padEnd(22)} ${check.message}`);
        if (check.details) {
          lines.push(`${"".padEnd(27)}Path: ${this.scrubPath(check.details)}`);
        }
        if (check.status !== "pass" && check.suggestion) {
          lines.push(`${"".padEnd(27)}Fix:  ${check.suggestion}`);
        }
      }
    }
    lines.push("");
    lines.push(divider);
    lines.push(`SUMMARY: ${summary.passed}  passed, ${summary.warnings}  warnings, ${summary.failed}  failed`);
    lines.push(divider);
    return lines.join(`
`);
  }
  groupChecks(checks) {
    const groups = new Map;
    for (const check of checks) {
      const group = groups.get(check.group) || [];
      group.push(check);
      groups.set(check.group, group);
    }
    return groups;
  }
  getStatusSymbol(status) {
    switch (status) {
      case "pass":
        return "";
      case "warn":
        return "";
      case "fail":
        return "";
      default:
        return "";
    }
  }
  generateJsonReport(summary) {
    const report = {
      version: "1.0",
      timestamp: summary.timestamp,
      system: this.getSystemInfo(),
      summary: {
        timestamp: summary.timestamp,
        total: summary.total,
        passed: summary.passed,
        warnings: summary.warnings,
        failed: summary.failed,
        fixed: summary.fixed,
        checks: summary.checks.map((c2) => ({
          id: c2.id,
          name: c2.name,
          group: c2.group,
          status: c2.status,
          message: c2.message,
          details: c2.details,
          suggestion: c2.suggestion,
          autoFixable: c2.autoFixable,
          fixed: c2.fixed,
          fixError: c2.fixError
        }))
      },
      errors: summary.checks.filter((c2) => c2.status === "fail").map((c2) => ({
        checkId: c2.id,
        checkName: c2.name,
        message: c2.message,
        suggestion: c2.suggestion
      }))
    };
    return JSON.stringify(report, null, 2);
  }
  async uploadToGist(report) {
    try {
      execSync3("gh --version", { stdio: "ignore" });
    } catch {
      logger.warning("GitHub CLI not installed, skipping gist upload");
      return null;
    }
    if (!isNonInteractive()) {
      const confirm = await se({
        message: "Upload to GitHub Gist? (secret gist)",
        initialValue: false
      });
      if (lD(confirm) || !confirm) {
        return null;
      }
    }
    const tmpFile = join19(tmpdir2(), `ck-report-${Date.now()}.txt`);
    writeFileSync(tmpFile, report);
    try {
      const result = spawnSync3("gh", ["gist", "create", tmpFile, "--desc", "ClaudeKit Diagnostic Report"], {
        encoding: "utf-8"
      });
      if (result.status !== 0) {
        const errorMsg = result.stderr || result.error?.message || "Unknown error";
        logger.error(`Failed to create gist: ${errorMsg}`);
        return null;
      }
      return { url: result.stdout.trim() };
    } catch (e2) {
      logger.error(`Failed to create gist: ${e2 instanceof Error ? e2.message : "Unknown error"}`);
      return null;
    } finally {
      try {
        unlinkSync(tmpFile);
      } catch {}
    }
  }
  getSystemInfo() {
    const osInfo = getOSInfo();
    return {
      os: osInfo.platform,
      osVersion: osInfo.details,
      node: process.version,
      cwd: this.scrubPath(process.cwd()),
      cliVersion: getCliVersion()
    };
  }
  scrubPath(path2) {
    const home = process.env.HOME || process.env.USERPROFILE || "";
    return home ? path2.replace(home, "~") : path2;
  }
  getStatusIcon(status) {
    switch (status) {
      case "pass":
        return "[PASS]";
      case "warn":
        return "[WARN]";
      case "fail":
        return "[FAIL]";
      default:
        return "[INFO]";
    }
  }
}
// src/domains/health-checks/doctor-ui-renderer.ts
init_terminal_utils();
var import_picocolors6 = __toESM(require_picocolors(), 1);

class DoctorUIRenderer {
  symbols = getStatusSymbols();
  renderResults(summary) {
    const groups = this.groupChecks(summary.checks);
    for (const [groupName, checks] of groups) {
      console.log("");
      console.log(`  ${import_picocolors6.default.bold(import_picocolors6.default.cyan(groupName.toUpperCase()))}`);
      console.log(`  ${import_picocolors6.default.dim("".repeat(50))}`);
      const maxNameLen = Math.max(...checks.map((c2) => c2.name.length));
      const maxMsgLen = Math.max(...checks.map((c2) => c2.message.length));
      for (const check of checks) {
        this.renderCheck(check, maxNameLen, maxMsgLen);
      }
    }
    console.log("");
    this.renderSummaryLine(summary);
  }
  renderCheck(check, maxNameLen, maxMsgLen) {
    const symbol = this.getColoredSymbol(check.status);
    const name = import_picocolors6.default.bold(check.name.padEnd(maxNameLen));
    const paddedMsg = check.message.padEnd(maxMsgLen);
    const value = this.colorizeValue(check.status, paddedMsg);
    let line = `  ${symbol} ${name}  ${value}`;
    if (check.details) {
      line += `  ${import_picocolors6.default.dim(this.shortenPath(check.details))}`;
    }
    console.log(line);
    if (check.status !== "pass" && check.suggestion) {
      const indent = " ".repeat(maxNameLen + 5);
      console.log(`  ${indent}${import_picocolors6.default.dim(` ${check.suggestion}`)}`);
    }
  }
  getColoredSymbol(status) {
    switch (status) {
      case "pass":
        return import_picocolors6.default.green(this.symbols.pass);
      case "warn":
        return import_picocolors6.default.yellow(this.symbols.warn);
      case "fail":
        return import_picocolors6.default.red(this.symbols.fail);
      default:
        return import_picocolors6.default.blue(this.symbols.info);
    }
  }
  renderHealingSummary(healSummary) {
    console.log("");
    console.log(`  ${import_picocolors6.default.bold(import_picocolors6.default.cyan("AUTO-HEAL RESULTS"))}`);
    console.log(`  ${import_picocolors6.default.dim("".repeat(50))}`);
    for (const fix of healSummary.fixes) {
      const symbol = fix.success ? import_picocolors6.default.green(this.symbols.pass) : import_picocolors6.default.red(this.symbols.fail);
      console.log(`  ${symbol} ${import_picocolors6.default.bold(fix.checkName)}  ${import_picocolors6.default.dim(fix.message)}`);
      if (!fix.success && fix.error) {
        console.log(`     ${import_picocolors6.default.red(`Error: ${fix.error}`)}`);
      }
    }
    console.log("");
    console.log(`  Fixed: ${import_picocolors6.default.green(String(healSummary.succeeded))}, Failed: ${import_picocolors6.default.red(String(healSummary.failed))}`);
  }
  groupChecks(checks) {
    const groups = new Map;
    for (const check of checks) {
      const group = groups.get(check.group) || [];
      group.push(check);
      groups.set(check.group, group);
    }
    return groups;
  }
  colorizeValue(status, message) {
    switch (status) {
      case "pass":
        return import_picocolors6.default.green(message);
      case "warn":
        return import_picocolors6.default.yellow(message);
      case "fail":
        return import_picocolors6.default.red(message);
      default:
        return message;
    }
  }
  shortenPath(path2) {
    const home = process.env.HOME || process.env.USERPROFILE || "";
    let shortened = home ? path2.replace(home, "~") : path2;
    const maxLen = 50;
    if (shortened.length > maxLen) {
      const start = shortened.slice(0, 20);
      const end = shortened.slice(-27);
      shortened = `${start}...${end}`;
    }
    return shortened;
  }
  renderSummaryLine(summary) {
    const parts = [];
    if (summary.passed > 0) {
      parts.push(import_picocolors6.default.green(`${summary.passed} ${this.symbols.pass}`));
    }
    if (summary.warnings > 0) {
      parts.push(import_picocolors6.default.yellow(`${summary.warnings} ${this.symbols.warn}`));
    }
    if (summary.failed > 0) {
      parts.push(import_picocolors6.default.red(`${summary.failed} ${this.symbols.fail}`));
    }
    console.log(`  ${import_picocolors6.default.dim("".repeat(50))}`);
    console.log(`  Summary: ${parts.join("  ")}`);
    console.log("");
    console.log(`  ${import_picocolors6.default.dim("Quick Commands:")}`);
    console.log(`  ${import_picocolors6.default.dim("  ck init        Install/update ClaudeKit in project")}`);
    console.log(`  ${import_picocolors6.default.dim("  ck init -g     Install/update ClaudeKit globally")}`);
    console.log(`  ${import_picocolors6.default.dim("  ck update      Update the CLI tool")}`);
    console.log(`  ${import_picocolors6.default.dim("  ck uninstall   Remove ClaudeKit from project/global")}`);
    console.log(`  ${import_picocolors6.default.dim("  ck --help      Show all commands")}`);
  }
}
// src/commands/doctor.ts
init_environment();
init_logger();

// src/shared/safe-prompts.ts
init_dist2();
var import_picocolors7 = __toESM(require_picocolors(), 1);
init_output_manager();
init_dist2();
function getSymbols() {
  return output.getSymbols();
}
function intro(message) {
  if (output.isJson())
    return;
  console.log();
  console.log(import_picocolors7.default.cyan(`${getSymbols().pointer} ${message}`));
  console.log();
}
function outro(message) {
  if (output.isJson())
    return;
  console.log();
  console.log(import_picocolors7.default.green(`${getSymbols().success} ${message}`));
  console.log();
}
function note(message, title) {
  if (output.isJson())
    return;
  console.log();
  if (title) {
    console.log(import_picocolors7.default.cyan(`  ${title}:`));
    console.log();
  }
  const lines = message.split(`
`);
  for (const line of lines) {
    console.log(`  ${line}`);
  }
  console.log();
}
var log = {
  info: (message) => {
    if (output.isJson())
      return;
    console.log(import_picocolors7.default.blue(`${getSymbols().info} ${message}`));
  },
  success: (message) => {
    if (output.isJson())
      return;
    console.log(import_picocolors7.default.green(`${getSymbols().success} ${message}`));
  },
  warn: (message) => {
    if (output.isJson())
      return;
    console.log(import_picocolors7.default.yellow(`${getSymbols().warning} ${message}`));
  },
  warning: (message) => {
    if (output.isJson())
      return;
    console.log(import_picocolors7.default.yellow(`${getSymbols().warning} ${message}`));
  },
  error: (message) => {
    if (output.isJson())
      return;
    console.log(import_picocolors7.default.red(`${getSymbols().error} ${message}`));
  },
  step: (message) => {
    if (output.isJson())
      return;
    console.log(import_picocolors7.default.cyan(`${getSymbols().pointer} ${message}`));
  },
  message: (message) => {
    if (output.isJson())
      return;
    console.log(`    ${message}`);
  }
};

// src/commands/doctor.ts
async function doctorCommand(options = {}) {
  const { report, fix, checkOnly, json, full } = options;
  const runnerOptions = {
    fix: fix ?? false,
    checkOnly: checkOnly ?? false,
    json: json ?? false,
    verbose: logger.isVerbose(),
    full: full ?? false
  };
  if (!json && !report) {
    intro("ClaudeKit Health Check");
  }
  const runner = new CheckRunner(runnerOptions);
  runner.registerChecker(new SystemChecker);
  runner.registerChecker(new ClaudekitChecker);
  runner.registerChecker(new AuthChecker);
  runner.registerChecker(new PlatformChecker);
  runner.registerChecker(new NetworkChecker);
  const summary = await runner.run();
  if (json) {
    const generator = new ReportGenerator;
    console.log(generator.generateJsonReport(summary));
    process.exitCode = summary.failed > 0 && checkOnly ? 1 : 0;
    return;
  }
  if (report) {
    const generator = new ReportGenerator;
    const textReport = generator.generateTextReport(summary);
    console.log(textReport);
    const gistResult = await generator.uploadToGist(textReport);
    if (gistResult) {
      logger.info(`Report uploaded: ${gistResult.url}`);
    }
    return;
  }
  const renderer = new DoctorUIRenderer;
  renderer.renderResults(summary);
  if (fix) {
    const healer = new AutoHealer;
    const healSummary = await healer.healAll(summary.checks);
    renderer.renderHealingSummary(healSummary);
    if (healSummary.failed === 0 && healSummary.succeeded > 0) {
      outro("All fixable issues resolved!");
      return;
    }
  }
  if (checkOnly && summary.failed > 0) {
    process.exitCode = 1;
  }
  if (!checkOnly && !fix && summary.failed > 0) {
    const fixable = summary.checks.filter((c2) => c2.autoFixable && c2.status !== "pass" && c2.fix);
    if (fixable.length > 0 && !isNonInteractive()) {
      const shouldFix = await se({
        message: `${fixable.length} issue(s) can be fixed automatically. Fix now?`,
        initialValue: true
      });
      if (!lD(shouldFix) && shouldFix) {
        const healer = new AutoHealer;
        const healSummary = await healer.healAll(summary.checks);
        renderer.renderHealingSummary(healSummary);
      }
    }
  }
  if (summary.failed === 0) {
    outro("All checks passed!");
  } else {
    outro(`${summary.failed} issue(s) found`);
  }
}

// src/commands/easter-egg.ts
init_logger();
var import_picocolors8 = __toESM(require_picocolors(), 1);
var API_URL = "https://claudekit.cc/api/egg";
function getRarityColor(rarity) {
  switch (rarity) {
    case "Legendary":
      return import_picocolors8.default.magenta;
    case "Epic":
      return import_picocolors8.default.yellow;
    case "Rare":
      return import_picocolors8.default.blue;
    case "Uncommon":
      return import_picocolors8.default.green;
    default:
      return import_picocolors8.default.gray;
  }
}
async function easterEggCommand() {
  intro("\uD83E\uDD5A Code Hunt 2025 - Easter Egg");
  try {
    console.log(import_picocolors8.default.dim(`
  Rolling for a discount code...
`));
    const response = await fetch(API_URL);
    if (!response.ok) {
      if (response.status === 429) {
        console.log(import_picocolors8.default.yellow("  \uD83D\uDC30 Slow down! The eggs aren't going anywhere."));
        console.log(import_picocolors8.default.dim(`  Wait a minute and try again.
`));
        outro("\uD83E\uDD5A Rate limited");
        return;
      }
      throw new Error(`API returned ${response.status}`);
    }
    const data = await response.json();
    const rarityColor = getRarityColor(data.rarity);
    console.log(`   ${import_picocolors8.default.bold(data.message)}`);
    console.log();
    console.log(`  ${import_picocolors8.default.bold("Code:")}     ${import_picocolors8.default.green(import_picocolors8.default.bold(data.code))}`);
    console.log(`  ${import_picocolors8.default.bold("Discount:")} ${import_picocolors8.default.cyan(data.discount)} off`);
    console.log(`  ${import_picocolors8.default.bold("Rarity:")}   ${rarityColor(data.rarity)}`);
    console.log(`  ${import_picocolors8.default.bold("Hint:")}     ${import_picocolors8.default.dim(data.hint)}`);
    console.log();
    console.log(`  ${import_picocolors8.default.dim("Redeem at:")} ${import_picocolors8.default.underline(data.checkout)}`);
    console.log(`  ${import_picocolors8.default.dim("Expires:")}   ${data.expires.split("T")[0]}`);
    console.log();
    outro("\uD83C\uDF84 Happy Holidays from ClaudeKit!");
  } catch (error) {
    logger.error(error instanceof Error ? error.message : "Failed to fetch easter egg");
    console.log(import_picocolors8.default.red(`
  Failed to connect to the egg API.`));
    console.log(import_picocolors8.default.dim(`  Make sure you have internet access.
`));
    process.exit(1);
  }
}

// src/commands/init/init-command.ts
init_github_client();

// src/domains/sync/config-version-checker.ts
init_logger();
init_path_resolver();
var import_compare_versions2 = __toESM(require_umd(), 1);
import { mkdir as mkdir5, readFile as readFile8, unlink as unlink5, writeFile as writeFile7 } from "node:fs/promises";
import { join as join20 } from "node:path";
var CACHE_TTL_HOURS = 24;
var DEFAULT_CACHE_TTL_MS = CACHE_TTL_HOURS * 60 * 60 * 1000;
var MIN_CACHE_TTL_MS = 60 * 1000;
var MAX_CACHE_TTL_MS = 7 * 24 * 60 * 60 * 1000;
function parseCacheTtl() {
  const envValue = process.env.CK_SYNC_CACHE_TTL;
  if (!envValue) {
    return DEFAULT_CACHE_TTL_MS;
  }
  const parsed = Number.parseInt(envValue, 10);
  if (Number.isNaN(parsed) || parsed < 0) {
    logger.warning(`Invalid CK_SYNC_CACHE_TTL value "${envValue}", using default (${CACHE_TTL_HOURS}h)`);
    return DEFAULT_CACHE_TTL_MS;
  }
  const ttlMs = parsed * 1000;
  if (ttlMs < MIN_CACHE_TTL_MS) {
    logger.warning(`CK_SYNC_CACHE_TTL too low (${parsed}s), using minimum (60s)`);
    return MIN_CACHE_TTL_MS;
  }
  if (ttlMs > MAX_CACHE_TTL_MS) {
    logger.warning(`CK_SYNC_CACHE_TTL too high (${parsed}s), using maximum (7 days)`);
    return MAX_CACHE_TTL_MS;
  }
  return ttlMs;
}
var CACHE_TTL_MS = parseCacheTtl();
var GITHUB_API_TIMEOUT_MS = 1e4;
var CACHE_FILENAME = "config-update-cache.json";
var KIT_REPOS = {
  engineer: { owner: "hungtq-inisoft", repo: "claudekit-engineer" },
  marketing: { owner: "hungtq-inisoft", repo: "claudekit-marketing" }
};

class ConfigVersionChecker {
  static getCacheFilePath(kitType, global2) {
    const cacheDir = PathResolver.getCacheDir(global2);
    return join20(cacheDir, `${kitType}-${CACHE_FILENAME}`);
  }
  static async loadCache(kitType, global2) {
    try {
      const cachePath = ConfigVersionChecker.getCacheFilePath(kitType, global2);
      const data = await readFile8(cachePath, "utf8");
      const parsed = JSON.parse(data);
      if (typeof parsed !== "object" || parsed === null || typeof parsed.lastCheck !== "number" || typeof parsed.latestVersion !== "string" || !parsed.latestVersion || parsed.lastCheck < 0 || parsed.lastCheck > Date.now() + 7 * 24 * 60 * 60 * 1000) {
        logger.debug("Invalid cache structure, ignoring");
        return null;
      }
      return parsed;
    } catch {
      return null;
    }
  }
  static async saveCache(kitType, global2, cache) {
    try {
      const cachePath = ConfigVersionChecker.getCacheFilePath(kitType, global2);
      const cacheDir = PathResolver.getCacheDir(global2);
      await mkdir5(cacheDir, { recursive: true });
      await writeFile7(cachePath, JSON.stringify(cache, null, 2));
    } catch (error) {
      logger.debug(`Cache write failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  static async fetchLatestVersion(kitType, etag) {
    const repoInfo = KIT_REPOS[kitType];
    if (!repoInfo)
      return null;
    const url = `https://api.github.com/repos/${repoInfo.owner}/${repoInfo.repo}/releases/latest`;
    const maxRetries = 3;
    const baseBackoff = 1000;
    for (let attempt = 0;attempt < maxRetries; attempt++) {
      try {
        const headers = {
          Accept: "application/vnd.github.v3+json",
          "User-Agent": "claudekit-cli"
        };
        const githubToken = process.env.GITHUB_TOKEN;
        if (githubToken) {
          headers.Authorization = `Bearer ${githubToken}`;
        }
        if (etag) {
          headers["If-None-Match"] = etag;
        }
        const response = await fetch(url, {
          headers,
          signal: AbortSignal.timeout(GITHUB_API_TIMEOUT_MS)
        });
        const remaining = response.headers.get("x-ratelimit-remaining");
        if (remaining && Number.parseInt(remaining, 10) < 10) {
          logger.warning(`GitHub API rate limit low: ${remaining} remaining. Set GITHUB_TOKEN env var for higher limits (5000/hr vs 60/hr).`);
        }
        if (response.status === 304) {
          return "not-modified";
        }
        if (!response.ok) {
          if (response.status === 403) {
            logger.warning("GitHub API rate limit exceeded. " + "Set GITHUB_TOKEN env var for higher limits (5000/hr vs 60/hr).");
            return null;
          }
          throw new Error(`GitHub API returned ${response.status}`);
        }
        const data = await response.json();
        const version = data.tag_name?.replace(/^v/, "") || null;
        if (!version || version.length > 256) {
          logger.debug(`Invalid version format from GitHub: ${data.tag_name}`);
          return null;
        }
        const semverParts = version.split(/[-+]/);
        const coreParts = semverParts[0].split(".");
        if (coreParts.length !== 3 || !coreParts.every((p) => /^\d+$/.test(p))) {
          logger.debug(`Invalid version format from GitHub: ${data.tag_name}`);
          return null;
        }
        return {
          version,
          etag: response.headers.get("etag") || undefined
        };
      } catch (error) {
        const isLastAttempt = attempt === maxRetries - 1;
        if (isLastAttempt) {
          logger.debug(`Version check failed after ${maxRetries} attempts: ${error}`);
          return null;
        }
        const delay = baseBackoff * 2 ** attempt;
        await new Promise((resolve2) => setTimeout(resolve2, delay));
      }
    }
    return null;
  }
  static async checkForUpdates(kitType, currentVersion, global2 = false) {
    const normalizedCurrent = currentVersion.replace(/^v/, "");
    const cache = await ConfigVersionChecker.loadCache(kitType, global2);
    const now = Date.now();
    if (cache && now - cache.lastCheck < CACHE_TTL_MS) {
      const hasUpdates = import_compare_versions2.compareVersions(cache.latestVersion, normalizedCurrent) > 0;
      return {
        hasUpdates,
        currentVersion: normalizedCurrent,
        latestVersion: cache.latestVersion,
        fromCache: true
      };
    }
    const result = await ConfigVersionChecker.fetchLatestVersion(kitType, cache?.etag);
    if (result === "not-modified" && cache) {
      await ConfigVersionChecker.saveCache(kitType, global2, {
        ...cache,
        lastCheck: now
      });
      const hasUpdates = import_compare_versions2.compareVersions(cache.latestVersion, normalizedCurrent) > 0;
      return {
        hasUpdates,
        currentVersion: normalizedCurrent,
        latestVersion: cache.latestVersion,
        fromCache: false
      };
    }
    if (result && result !== "not-modified") {
      await ConfigVersionChecker.saveCache(kitType, global2, {
        lastCheck: now,
        latestVersion: result.version,
        etag: result.etag
      });
      const hasUpdates = import_compare_versions2.compareVersions(result.version, normalizedCurrent) > 0;
      return {
        hasUpdates,
        currentVersion: normalizedCurrent,
        latestVersion: result.version,
        fromCache: false
      };
    }
    if (cache) {
      const hasUpdates = import_compare_versions2.compareVersions(cache.latestVersion, normalizedCurrent) > 0;
      return {
        hasUpdates,
        currentVersion: normalizedCurrent,
        latestVersion: cache.latestVersion,
        fromCache: true
      };
    }
    return {
      hasUpdates: false,
      currentVersion: normalizedCurrent,
      latestVersion: normalizedCurrent,
      fromCache: false
    };
  }
  static async clearCache(kitType, global2 = false) {
    const cachePath = ConfigVersionChecker.getCacheFilePath(kitType, global2);
    try {
      await unlink5(cachePath);
      logger.debug(`Cleared sync cache for ${kitType}`);
    } catch (error) {
      if (error.code !== "ENOENT") {
        throw error;
      }
    }
  }
}
// src/domains/sync/sync-engine.ts
import { lstat, readFile as readFile10, readlink, realpath, stat as stat2 } from "node:fs/promises";
import { isAbsolute, join as join22, normalize as normalize5, relative as relative2 } from "node:path";

// src/services/file-operations/ownership-checker.ts
import { createHash } from "node:crypto";
import { createReadStream } from "node:fs";
import { stat } from "node:fs/promises";
import { relative } from "node:path";

// src/domains/migration/metadata-migration.ts
init_logger();
var import_fs_extra4 = __toESM(require_lib(), 1);
import { join as join21 } from "node:path";
async function detectMetadataFormat(claudeDir) {
  const metadataPath = join21(claudeDir, "metadata.json");
  if (!await import_fs_extra4.pathExists(metadataPath)) {
    return { format: "none", metadata: null, detectedKit: null };
  }
  try {
    const content = await import_fs_extra4.readFile(metadataPath, "utf-8");
    const parsed = JSON.parse(content);
    if (parsed.kits && Object.keys(parsed.kits).length > 0) {
      const installedKits = Object.keys(parsed.kits);
      return {
        format: "multi-kit",
        metadata: parsed,
        detectedKit: installedKits[0] || null
      };
    }
    if (parsed.name || parsed.version || parsed.files) {
      let detectedKit = null;
      const nameToCheck = parsed.name || "";
      if (/\bengineer\b/i.test(nameToCheck)) {
        detectedKit = "engineer";
      } else if (/\bmarketing\b/i.test(nameToCheck)) {
        detectedKit = "marketing";
      } else {
        detectedKit = "engineer";
      }
      return { format: "legacy", metadata: parsed, detectedKit };
    }
    logger.warning("Metadata file exists but has unrecognized format (missing kits, name, version, or files)");
    return { format: "none", metadata: null, detectedKit: null };
  } catch (error) {
    logger.warning(`Failed to read metadata file (may be corrupted): ${error}`);
    return { format: "none", metadata: null, detectedKit: null };
  }
}
async function migrateToMultiKit(claudeDir) {
  const detection = await detectMetadataFormat(claudeDir);
  if (detection.format === "multi-kit") {
    return {
      success: true,
      migrated: false,
      fromFormat: "multi-kit",
      toFormat: "multi-kit"
    };
  }
  if (detection.format === "none") {
    return {
      success: true,
      migrated: false,
      fromFormat: "none",
      toFormat: "multi-kit"
    };
  }
  const metadataPath = join21(claudeDir, "metadata.json");
  const legacy = detection.metadata;
  if (!legacy) {
    return {
      success: false,
      migrated: false,
      fromFormat: "legacy",
      toFormat: "multi-kit",
      error: "Metadata exists but could not be read"
    };
  }
  const legacyKit = detection.detectedKit || "engineer";
  try {
    const kitMetadata = {
      version: legacy.version || "unknown",
      installedAt: legacy.installedAt || new Date().toISOString(),
      files: legacy.files || []
    };
    const multiKit = {
      kits: {
        [legacyKit]: kitMetadata
      },
      scope: legacy.scope,
      name: legacy.name,
      version: legacy.version,
      installedAt: legacy.installedAt,
      installedFiles: legacy.installedFiles,
      userConfigFiles: legacy.userConfigFiles,
      files: legacy.files
    };
    await import_fs_extra4.writeFile(metadataPath, JSON.stringify(multiKit, null, 2), "utf-8");
    logger.info(`Migrated metadata from legacy format to multi-kit (detected: ${legacyKit})`);
    return {
      success: true,
      migrated: true,
      fromFormat: "legacy",
      toFormat: "multi-kit"
    };
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : "Unknown error";
    logger.error(`Metadata migration failed: ${errorMsg}`);
    return {
      success: false,
      migrated: false,
      fromFormat: "legacy",
      toFormat: "multi-kit",
      error: errorMsg
    };
  }
}
function getKitMetadata(metadata, kit) {
  if (metadata.kits?.[kit]) {
    return metadata.kits[kit];
  }
  if (!metadata.kits && metadata.version) {
    return {
      version: metadata.version,
      installedAt: metadata.installedAt || "",
      files: metadata.files
    };
  }
  return null;
}
function getAllTrackedFiles(metadata) {
  if (metadata.kits) {
    const allFiles = [];
    for (const kit of Object.values(metadata.kits)) {
      if (kit.files) {
        allFiles.push(...kit.files);
      }
    }
    return allFiles;
  }
  return metadata.files || [];
}
function getInstalledKits(metadata) {
  if (metadata.kits) {
    return Object.keys(metadata.kits);
  }
  const nameToCheck = metadata.name || "";
  const kits = [];
  if (/\bengineer\b/i.test(nameToCheck)) {
    kits.push("engineer");
  }
  if (/\bmarketing\b/i.test(nameToCheck)) {
    kits.push("marketing");
  }
  if (kits.length > 0) {
    return kits;
  }
  if (metadata.version) {
    return ["engineer"];
  }
  return [];
}

// node_modules/yocto-queue/index.js
class Node {
  value;
  next;
  constructor(value) {
    this.value = value;
  }
}

class Queue {
  #head;
  #tail;
  #size;
  constructor() {
    this.clear();
  }
  enqueue(value) {
    const node = new Node(value);
    if (this.#head) {
      this.#tail.next = node;
      this.#tail = node;
    } else {
      this.#head = node;
      this.#tail = node;
    }
    this.#size++;
  }
  dequeue() {
    const current = this.#head;
    if (!current) {
      return;
    }
    this.#head = this.#head.next;
    this.#size--;
    if (!this.#head) {
      this.#tail = undefined;
    }
    return current.value;
  }
  peek() {
    if (!this.#head) {
      return;
    }
    return this.#head.value;
  }
  clear() {
    this.#head = undefined;
    this.#tail = undefined;
    this.#size = 0;
  }
  get size() {
    return this.#size;
  }
  *[Symbol.iterator]() {
    let current = this.#head;
    while (current) {
      yield current.value;
      current = current.next;
    }
  }
  *drain() {
    while (this.#head) {
      yield this.dequeue();
    }
  }
}

// node_modules/p-limit/index.js
function pLimit(concurrency) {
  validateConcurrency(concurrency);
  const queue = new Queue;
  let activeCount = 0;
  const resumeNext = () => {
    if (activeCount < concurrency && queue.size > 0) {
      activeCount++;
      queue.dequeue()();
    }
  };
  const next = () => {
    activeCount--;
    resumeNext();
  };
  const run = async (function_, resolve2, arguments_) => {
    const result = (async () => function_(...arguments_))();
    resolve2(result);
    try {
      await result;
    } catch {}
    next();
  };
  const enqueue = (function_, resolve2, arguments_) => {
    new Promise((internalResolve) => {
      queue.enqueue(internalResolve);
    }).then(run.bind(undefined, function_, resolve2, arguments_));
    if (activeCount < concurrency) {
      resumeNext();
    }
  };
  const generator = (function_, ...arguments_) => new Promise((resolve2) => {
    enqueue(function_, resolve2, arguments_);
  });
  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue.size
    },
    clearQueue: {
      value() {
        queue.clear();
      }
    },
    concurrency: {
      get: () => concurrency,
      set(newConcurrency) {
        validateConcurrency(newConcurrency);
        concurrency = newConcurrency;
        queueMicrotask(() => {
          while (activeCount < concurrency && queue.size > 0) {
            resumeNext();
          }
        });
      }
    },
    map: {
      async value(iterable, function_) {
        const promises2 = Array.from(iterable, (value, index) => this(function_, value, index));
        return Promise.all(promises2);
      }
    }
  });
  return generator;
}
function validateConcurrency(concurrency) {
  if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
    throw new TypeError("Expected `concurrency` to be a number from 1 and up");
  }
}

// src/shared/concurrent-file-ops.ts
var DEFAULT_CONCURRENCY = 50;
async function mapWithLimit(items, fn, concurrency = DEFAULT_CONCURRENCY) {
  const limit = pLimit(concurrency);
  return Promise.all(items.map((item) => limit(() => fn(item))));
}

// src/services/file-operations/ownership-checker.ts
class OwnershipChecker {
  static async calculateChecksum(filePath) {
    return new Promise((resolve2, reject) => {
      const hash = createHash("sha256");
      const stream = createReadStream(filePath);
      stream.on("data", (chunk) => hash.update(chunk));
      stream.on("end", () => {
        resolve2(hash.digest("hex"));
      });
      stream.on("error", (err) => {
        stream.destroy();
        reject(new Error(operationError("Checksum calculation", filePath, err.message)));
      });
    });
  }
  static async checkOwnership(filePath, metadata, claudeDir) {
    try {
      await stat(filePath);
    } catch {
      return { path: filePath, ownership: "user", exists: false };
    }
    const allTrackedFiles = metadata ? getAllTrackedFiles(metadata) : [];
    if (!metadata || allTrackedFiles.length === 0) {
      return { path: filePath, ownership: "user", exists: true };
    }
    const relativePath = relative(claudeDir, filePath).replace(/\\/g, "/");
    const tracked = allTrackedFiles.find((f3) => f3.path === relativePath);
    if (!tracked) {
      return { path: filePath, ownership: "user", exists: true };
    }
    const actualChecksum = await OwnershipChecker.calculateChecksum(filePath);
    if (actualChecksum === tracked.checksum) {
      return {
        path: filePath,
        ownership: "ck",
        expectedChecksum: tracked.checksum,
        actualChecksum,
        exists: true
      };
    }
    return {
      path: filePath,
      ownership: "ck-modified",
      expectedChecksum: tracked.checksum,
      actualChecksum,
      exists: true
    };
  }
  static async checkBatch(filePaths, metadata, claudeDir) {
    const results = await mapWithLimit(filePaths, (path2) => OwnershipChecker.checkOwnership(path2, metadata, claudeDir));
    return new Map(results.map((r2) => [r2.path, r2]));
  }
}

// src/domains/sync/sync-engine.ts
init_logger();

// node_modules/diff/libesm/diff/base.js
class Diff {
  diff(oldStr, newStr, options = {}) {
    let callback;
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else if ("callback" in options) {
      callback = options.callback;
    }
    const oldString = this.castInput(oldStr, options);
    const newString = this.castInput(newStr, options);
    const oldTokens = this.removeEmpty(this.tokenize(oldString, options));
    const newTokens = this.removeEmpty(this.tokenize(newString, options));
    return this.diffWithOptionsObj(oldTokens, newTokens, options, callback);
  }
  diffWithOptionsObj(oldTokens, newTokens, options, callback) {
    var _a;
    const done = (value) => {
      value = this.postProcess(value, options);
      if (callback) {
        setTimeout(function() {
          callback(value);
        }, 0);
        return;
      } else {
        return value;
      }
    };
    const newLen = newTokens.length, oldLen = oldTokens.length;
    let editLength = 1;
    let maxEditLength = newLen + oldLen;
    if (options.maxEditLength != null) {
      maxEditLength = Math.min(maxEditLength, options.maxEditLength);
    }
    const maxExecutionTime = (_a = options.timeout) !== null && _a !== undefined ? _a : Infinity;
    const abortAfterTimestamp = Date.now() + maxExecutionTime;
    const bestPath = [{ oldPos: -1, lastComponent: undefined }];
    let newPos = this.extractCommon(bestPath[0], newTokens, oldTokens, 0, options);
    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
      return done(this.buildValues(bestPath[0].lastComponent, newTokens, oldTokens));
    }
    let minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;
    const execEditLength = () => {
      for (let diagonalPath = Math.max(minDiagonalToConsider, -editLength);diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
        let basePath;
        const removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
        if (removePath) {
          bestPath[diagonalPath - 1] = undefined;
        }
        let canAdd = false;
        if (addPath) {
          const addPathNewPos = addPath.oldPos - diagonalPath;
          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
        }
        const canRemove = removePath && removePath.oldPos + 1 < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = undefined;
          continue;
        }
        if (!canRemove || canAdd && removePath.oldPos < addPath.oldPos) {
          basePath = this.addToPath(addPath, true, false, 0, options);
        } else {
          basePath = this.addToPath(removePath, false, true, 1, options);
        }
        newPos = this.extractCommon(basePath, newTokens, oldTokens, diagonalPath, options);
        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
          return done(this.buildValues(basePath.lastComponent, newTokens, oldTokens)) || true;
        } else {
          bestPath[diagonalPath] = basePath;
          if (basePath.oldPos + 1 >= oldLen) {
            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
          }
          if (newPos + 1 >= newLen) {
            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
          }
        }
      }
      editLength++;
    };
    if (callback) {
      (function exec() {
        setTimeout(function() {
          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
            return callback(undefined);
          }
          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
        const ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    }
  }
  addToPath(path2, added, removed, oldPosInc, options) {
    const last = path2.lastComponent;
    if (last && !options.oneChangePerToken && last.added === added && last.removed === removed) {
      return {
        oldPos: path2.oldPos + oldPosInc,
        lastComponent: { count: last.count + 1, added, removed, previousComponent: last.previousComponent }
      };
    } else {
      return {
        oldPos: path2.oldPos + oldPosInc,
        lastComponent: { count: 1, added, removed, previousComponent: last }
      };
    }
  }
  extractCommon(basePath, newTokens, oldTokens, diagonalPath, options) {
    const newLen = newTokens.length, oldLen = oldTokens.length;
    let oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldTokens[oldPos + 1], newTokens[newPos + 1], options)) {
      newPos++;
      oldPos++;
      commonCount++;
      if (options.oneChangePerToken) {
        basePath.lastComponent = { count: 1, previousComponent: basePath.lastComponent, added: false, removed: false };
      }
    }
    if (commonCount && !options.oneChangePerToken) {
      basePath.lastComponent = { count: commonCount, previousComponent: basePath.lastComponent, added: false, removed: false };
    }
    basePath.oldPos = oldPos;
    return newPos;
  }
  equals(left, right, options) {
    if (options.comparator) {
      return options.comparator(left, right);
    } else {
      return left === right || !!options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  }
  removeEmpty(array) {
    const ret = [];
    for (let i = 0;i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }
    return ret;
  }
  castInput(value, options) {
    return value;
  }
  tokenize(value, options) {
    return Array.from(value);
  }
  join(chars) {
    return chars.join("");
  }
  postProcess(changeObjects, options) {
    return changeObjects;
  }
  get useLongestToken() {
    return false;
  }
  buildValues(lastComponent, newTokens, oldTokens) {
    const components = [];
    let nextComponent;
    while (lastComponent) {
      components.push(lastComponent);
      nextComponent = lastComponent.previousComponent;
      delete lastComponent.previousComponent;
      lastComponent = nextComponent;
    }
    components.reverse();
    const componentLen = components.length;
    let componentPos = 0, newPos = 0, oldPos = 0;
    for (;componentPos < componentLen; componentPos++) {
      const component = components[componentPos];
      if (!component.removed) {
        if (!component.added && this.useLongestToken) {
          let value = newTokens.slice(newPos, newPos + component.count);
          value = value.map(function(value2, i) {
            const oldValue = oldTokens[oldPos + i];
            return oldValue.length > value2.length ? oldValue : value2;
          });
          component.value = this.join(value);
        } else {
          component.value = this.join(newTokens.slice(newPos, newPos + component.count));
        }
        newPos += component.count;
        if (!component.added) {
          oldPos += component.count;
        }
      } else {
        component.value = this.join(oldTokens.slice(oldPos, oldPos + component.count));
        oldPos += component.count;
      }
    }
    return components;
  }
}

// node_modules/diff/libesm/diff/character.js
class CharacterDiff extends Diff {
}
var characterDiff = new CharacterDiff;

// node_modules/diff/libesm/util/string.js
function longestCommonPrefix(str1, str2) {
  let i;
  for (i = 0;i < str1.length && i < str2.length; i++) {
    if (str1[i] != str2[i]) {
      return str1.slice(0, i);
    }
  }
  return str1.slice(0, i);
}
function longestCommonSuffix(str1, str2) {
  let i;
  if (!str1 || !str2 || str1[str1.length - 1] != str2[str2.length - 1]) {
    return "";
  }
  for (i = 0;i < str1.length && i < str2.length; i++) {
    if (str1[str1.length - (i + 1)] != str2[str2.length - (i + 1)]) {
      return str1.slice(-i);
    }
  }
  return str1.slice(-i);
}
function replacePrefix(string, oldPrefix, newPrefix) {
  if (string.slice(0, oldPrefix.length) != oldPrefix) {
    throw Error(`string ${JSON.stringify(string)} doesn't start with prefix ${JSON.stringify(oldPrefix)}; this is a bug`);
  }
  return newPrefix + string.slice(oldPrefix.length);
}
function replaceSuffix(string, oldSuffix, newSuffix) {
  if (!oldSuffix) {
    return string + newSuffix;
  }
  if (string.slice(-oldSuffix.length) != oldSuffix) {
    throw Error(`string ${JSON.stringify(string)} doesn't end with suffix ${JSON.stringify(oldSuffix)}; this is a bug`);
  }
  return string.slice(0, -oldSuffix.length) + newSuffix;
}
function removePrefix(string, oldPrefix) {
  return replacePrefix(string, oldPrefix, "");
}
function removeSuffix(string, oldSuffix) {
  return replaceSuffix(string, oldSuffix, "");
}
function maximumOverlap(string1, string2) {
  return string2.slice(0, overlapCount(string1, string2));
}
function overlapCount(a3, b3) {
  let startA = 0;
  if (a3.length > b3.length) {
    startA = a3.length - b3.length;
  }
  let endB = b3.length;
  if (a3.length < b3.length) {
    endB = a3.length;
  }
  const map = Array(endB);
  let k2 = 0;
  map[0] = 0;
  for (let j2 = 1;j2 < endB; j2++) {
    if (b3[j2] == b3[k2]) {
      map[j2] = map[k2];
    } else {
      map[j2] = k2;
    }
    while (k2 > 0 && b3[j2] != b3[k2]) {
      k2 = map[k2];
    }
    if (b3[j2] == b3[k2]) {
      k2++;
    }
  }
  k2 = 0;
  for (let i = startA;i < a3.length; i++) {
    while (k2 > 0 && a3[i] != b3[k2]) {
      k2 = map[k2];
    }
    if (a3[i] == b3[k2]) {
      k2++;
    }
  }
  return k2;
}
function hasOnlyWinLineEndings(string) {
  return string.includes(`\r
`) && !string.startsWith(`
`) && !string.match(/[^\r]\n/);
}
function hasOnlyUnixLineEndings(string) {
  return !string.includes(`\r
`) && string.includes(`
`);
}
function trailingWs(string) {
  let i;
  for (i = string.length - 1;i >= 0; i--) {
    if (!string[i].match(/\s/)) {
      break;
    }
  }
  return string.substring(i + 1);
}
function leadingWs(string) {
  const match = string.match(/^\s*/);
  return match ? match[0] : "";
}

// node_modules/diff/libesm/diff/word.js
var extendedWordChars = "a-zA-Z0-9_\\u{AD}\\u{C0}-\\u{D6}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}";
var tokenizeIncludingWhitespace = new RegExp(`[${extendedWordChars}]+|\\s+|[^${extendedWordChars}]`, "ug");

class WordDiff extends Diff {
  equals(left, right, options) {
    if (options.ignoreCase) {
      left = left.toLowerCase();
      right = right.toLowerCase();
    }
    return left.trim() === right.trim();
  }
  tokenize(value, options = {}) {
    let parts;
    if (options.intlSegmenter) {
      const segmenter = options.intlSegmenter;
      if (segmenter.resolvedOptions().granularity != "word") {
        throw new Error('The segmenter passed must have a granularity of "word"');
      }
      parts = [];
      for (const segmentObj of Array.from(segmenter.segment(value))) {
        const segment = segmentObj.segment;
        if (parts.length && /\s/.test(parts[parts.length - 1]) && /\s/.test(segment)) {
          parts[parts.length - 1] += segment;
        } else {
          parts.push(segment);
        }
      }
    } else {
      parts = value.match(tokenizeIncludingWhitespace) || [];
    }
    const tokens = [];
    let prevPart = null;
    parts.forEach((part) => {
      if (/\s/.test(part)) {
        if (prevPart == null) {
          tokens.push(part);
        } else {
          tokens.push(tokens.pop() + part);
        }
      } else if (prevPart != null && /\s/.test(prevPart)) {
        if (tokens[tokens.length - 1] == prevPart) {
          tokens.push(tokens.pop() + part);
        } else {
          tokens.push(prevPart + part);
        }
      } else {
        tokens.push(part);
      }
      prevPart = part;
    });
    return tokens;
  }
  join(tokens) {
    return tokens.map((token, i) => {
      if (i == 0) {
        return token;
      } else {
        return token.replace(/^\s+/, "");
      }
    }).join("");
  }
  postProcess(changes, options) {
    if (!changes || options.oneChangePerToken) {
      return changes;
    }
    let lastKeep = null;
    let insertion = null;
    let deletion = null;
    changes.forEach((change) => {
      if (change.added) {
        insertion = change;
      } else if (change.removed) {
        deletion = change;
      } else {
        if (insertion || deletion) {
          dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, change);
        }
        lastKeep = change;
        insertion = null;
        deletion = null;
      }
    });
    if (insertion || deletion) {
      dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, null);
    }
    return changes;
  }
}
var wordDiff = new WordDiff;
function dedupeWhitespaceInChangeObjects(startKeep, deletion, insertion, endKeep) {
  if (deletion && insertion) {
    const oldWsPrefix = leadingWs(deletion.value);
    const oldWsSuffix = trailingWs(deletion.value);
    const newWsPrefix = leadingWs(insertion.value);
    const newWsSuffix = trailingWs(insertion.value);
    if (startKeep) {
      const commonWsPrefix = longestCommonPrefix(oldWsPrefix, newWsPrefix);
      startKeep.value = replaceSuffix(startKeep.value, newWsPrefix, commonWsPrefix);
      deletion.value = removePrefix(deletion.value, commonWsPrefix);
      insertion.value = removePrefix(insertion.value, commonWsPrefix);
    }
    if (endKeep) {
      const commonWsSuffix = longestCommonSuffix(oldWsSuffix, newWsSuffix);
      endKeep.value = replacePrefix(endKeep.value, newWsSuffix, commonWsSuffix);
      deletion.value = removeSuffix(deletion.value, commonWsSuffix);
      insertion.value = removeSuffix(insertion.value, commonWsSuffix);
    }
  } else if (insertion) {
    if (startKeep) {
      const ws = leadingWs(insertion.value);
      insertion.value = insertion.value.substring(ws.length);
    }
    if (endKeep) {
      const ws = leadingWs(endKeep.value);
      endKeep.value = endKeep.value.substring(ws.length);
    }
  } else if (startKeep && endKeep) {
    const newWsFull = leadingWs(endKeep.value), delWsStart = leadingWs(deletion.value), delWsEnd = trailingWs(deletion.value);
    const newWsStart = longestCommonPrefix(newWsFull, delWsStart);
    deletion.value = removePrefix(deletion.value, newWsStart);
    const newWsEnd = longestCommonSuffix(removePrefix(newWsFull, newWsStart), delWsEnd);
    deletion.value = removeSuffix(deletion.value, newWsEnd);
    endKeep.value = replacePrefix(endKeep.value, newWsFull, newWsEnd);
    startKeep.value = replaceSuffix(startKeep.value, newWsFull, newWsFull.slice(0, newWsFull.length - newWsEnd.length));
  } else if (endKeep) {
    const endKeepWsPrefix = leadingWs(endKeep.value);
    const deletionWsSuffix = trailingWs(deletion.value);
    const overlap = maximumOverlap(deletionWsSuffix, endKeepWsPrefix);
    deletion.value = removeSuffix(deletion.value, overlap);
  } else if (startKeep) {
    const startKeepWsSuffix = trailingWs(startKeep.value);
    const deletionWsPrefix = leadingWs(deletion.value);
    const overlap = maximumOverlap(startKeepWsSuffix, deletionWsPrefix);
    deletion.value = removePrefix(deletion.value, overlap);
  }
}

class WordsWithSpaceDiff extends Diff {
  tokenize(value) {
    const regex = new RegExp(`(\\r?\\n)|[${extendedWordChars}]+|[^\\S\\n\\r]+|[^${extendedWordChars}]`, "ug");
    return value.match(regex) || [];
  }
}
var wordsWithSpaceDiff = new WordsWithSpaceDiff;

// node_modules/diff/libesm/diff/line.js
class LineDiff extends Diff {
  constructor() {
    super(...arguments);
    this.tokenize = tokenize;
  }
  equals(left, right, options) {
    if (options.ignoreWhitespace) {
      if (!options.newlineIsToken || !left.includes(`
`)) {
        left = left.trim();
      }
      if (!options.newlineIsToken || !right.includes(`
`)) {
        right = right.trim();
      }
    } else if (options.ignoreNewlineAtEof && !options.newlineIsToken) {
      if (left.endsWith(`
`)) {
        left = left.slice(0, -1);
      }
      if (right.endsWith(`
`)) {
        right = right.slice(0, -1);
      }
    }
    return super.equals(left, right, options);
  }
}
var lineDiff = new LineDiff;
function diffLines(oldStr, newStr, options) {
  return lineDiff.diff(oldStr, newStr, options);
}
function tokenize(value, options) {
  if (options.stripTrailingCr) {
    value = value.replace(/\r\n/g, `
`);
  }
  const retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  }
  for (let i = 0;i < linesAndNewlines.length; i++) {
    const line = linesAndNewlines[i];
    if (i % 2 && !options.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      retLines.push(line);
    }
  }
  return retLines;
}

// node_modules/diff/libesm/diff/sentence.js
function isSentenceEndPunct(char) {
  return char == "." || char == "!" || char == "?";
}

class SentenceDiff extends Diff {
  tokenize(value) {
    var _a;
    const result = [];
    let tokenStartI = 0;
    for (let i = 0;i < value.length; i++) {
      if (i == value.length - 1) {
        result.push(value.slice(tokenStartI));
        break;
      }
      if (isSentenceEndPunct(value[i]) && value[i + 1].match(/\s/)) {
        result.push(value.slice(tokenStartI, i + 1));
        i = tokenStartI = i + 1;
        while ((_a = value[i + 1]) === null || _a === undefined ? undefined : _a.match(/\s/)) {
          i++;
        }
        result.push(value.slice(tokenStartI, i + 1));
        tokenStartI = i + 1;
      }
    }
    return result;
  }
}
var sentenceDiff = new SentenceDiff;

// node_modules/diff/libesm/diff/css.js
class CssDiff extends Diff {
  tokenize(value) {
    return value.split(/([{}:;,]|\s+)/);
  }
}
var cssDiff = new CssDiff;

// node_modules/diff/libesm/diff/json.js
class JsonDiff extends Diff {
  constructor() {
    super(...arguments);
    this.tokenize = tokenize;
  }
  get useLongestToken() {
    return true;
  }
  castInput(value, options) {
    const { undefinedReplacement, stringifyReplacer = (k2, v2) => typeof v2 === "undefined" ? undefinedReplacement : v2 } = options;
    return typeof value === "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), null, "  ");
  }
  equals(left, right, options) {
    return super.equals(left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"), options);
  }
}
var jsonDiff = new JsonDiff;
function canonicalize(obj, stack, replacementStack, replacer, key) {
  stack = stack || [];
  replacementStack = replacementStack || [];
  if (replacer) {
    obj = replacer(key === undefined ? "" : key, obj);
  }
  let i;
  for (i = 0;i < stack.length; i += 1) {
    if (stack[i] === obj) {
      return replacementStack[i];
    }
  }
  let canonicalizedObj;
  if (Object.prototype.toString.call(obj) === "[object Array]") {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);
    for (i = 0;i < obj.length; i += 1) {
      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, String(i));
    }
    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }
  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }
  if (typeof obj === "object" && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);
    const sortedKeys = [];
    let key2;
    for (key2 in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key2)) {
        sortedKeys.push(key2);
      }
    }
    sortedKeys.sort();
    for (i = 0;i < sortedKeys.length; i += 1) {
      key2 = sortedKeys[i];
      canonicalizedObj[key2] = canonicalize(obj[key2], stack, replacementStack, replacer, key2);
    }
    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }
  return canonicalizedObj;
}

// node_modules/diff/libesm/diff/array.js
class ArrayDiff extends Diff {
  tokenize(value) {
    return value.slice();
  }
  join(value) {
    return value;
  }
  removeEmpty(value) {
    return value;
  }
}
var arrayDiff = new ArrayDiff;

// node_modules/diff/libesm/patch/line-endings.js
function unixToWin(patch) {
  if (Array.isArray(patch)) {
    return patch.map((p) => unixToWin(p));
  }
  return Object.assign(Object.assign({}, patch), { hunks: patch.hunks.map((hunk) => Object.assign(Object.assign({}, hunk), { lines: hunk.lines.map((line, i) => {
    var _a;
    return line.startsWith("\\") || line.endsWith("\r") || ((_a = hunk.lines[i + 1]) === null || _a === undefined ? undefined : _a.startsWith("\\")) ? line : line + "\r";
  }) })) });
}
function winToUnix(patch) {
  if (Array.isArray(patch)) {
    return patch.map((p) => winToUnix(p));
  }
  return Object.assign(Object.assign({}, patch), { hunks: patch.hunks.map((hunk) => Object.assign(Object.assign({}, hunk), { lines: hunk.lines.map((line) => line.endsWith("\r") ? line.substring(0, line.length - 1) : line) })) });
}
function isUnix(patch) {
  if (!Array.isArray(patch)) {
    patch = [patch];
  }
  return !patch.some((index) => index.hunks.some((hunk) => hunk.lines.some((line) => !line.startsWith("\\") && line.endsWith("\r"))));
}
function isWin(patch) {
  if (!Array.isArray(patch)) {
    patch = [patch];
  }
  return patch.some((index) => index.hunks.some((hunk) => hunk.lines.some((line) => line.endsWith("\r")))) && patch.every((index) => index.hunks.every((hunk) => hunk.lines.every((line, i) => {
    var _a;
    return line.startsWith("\\") || line.endsWith("\r") || ((_a = hunk.lines[i + 1]) === null || _a === undefined ? undefined : _a.startsWith("\\"));
  })));
}

// node_modules/diff/libesm/patch/parse.js
function parsePatch(uniDiff) {
  const diffstr = uniDiff.split(/\n/), list = [];
  let i = 0;
  function parseIndex() {
    const index = {};
    list.push(index);
    while (i < diffstr.length) {
      const line = diffstr[i];
      if (/^(---|\+\+\+|@@)\s/.test(line)) {
        break;
      }
      const headerMatch = /^(?:Index:|diff(?: -r \w+)+)\s+/.exec(line);
      if (headerMatch) {
        index.index = line.substring(headerMatch[0].length).trim();
      }
      i++;
    }
    parseFileHeader(index);
    parseFileHeader(index);
    index.hunks = [];
    while (i < diffstr.length) {
      const line = diffstr[i];
      if (/^(Index:\s|diff\s|---\s|\+\+\+\s|===================================================================)/.test(line)) {
        break;
      } else if (/^@@/.test(line)) {
        index.hunks.push(parseHunk());
      } else if (line) {
        throw new Error("Unknown line " + (i + 1) + " " + JSON.stringify(line));
      } else {
        i++;
      }
    }
  }
  function parseFileHeader(index) {
    const fileHeaderMatch = /^(---|\+\+\+)\s+/.exec(diffstr[i]);
    if (fileHeaderMatch) {
      const prefix = fileHeaderMatch[1], data = diffstr[i].substring(3).trim().split("\t", 2), header = (data[1] || "").trim();
      let fileName = data[0].replace(/\\\\/g, "\\");
      if (fileName.startsWith('"') && fileName.endsWith('"')) {
        fileName = fileName.substr(1, fileName.length - 2);
      }
      if (prefix === "---") {
        index.oldFileName = fileName;
        index.oldHeader = header;
      } else {
        index.newFileName = fileName;
        index.newHeader = header;
      }
      i++;
    }
  }
  function parseHunk() {
    var _a;
    const chunkHeaderIndex = i, chunkHeaderLine = diffstr[i++], chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
    const hunk = {
      oldStart: +chunkHeader[1],
      oldLines: typeof chunkHeader[2] === "undefined" ? 1 : +chunkHeader[2],
      newStart: +chunkHeader[3],
      newLines: typeof chunkHeader[4] === "undefined" ? 1 : +chunkHeader[4],
      lines: []
    };
    if (hunk.oldLines === 0) {
      hunk.oldStart += 1;
    }
    if (hunk.newLines === 0) {
      hunk.newStart += 1;
    }
    let addCount = 0, removeCount = 0;
    for (;i < diffstr.length && (removeCount < hunk.oldLines || addCount < hunk.newLines || ((_a = diffstr[i]) === null || _a === undefined ? undefined : _a.startsWith("\\"))); i++) {
      const operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? " " : diffstr[i][0];
      if (operation === "+" || operation === "-" || operation === " " || operation === "\\") {
        hunk.lines.push(diffstr[i]);
        if (operation === "+") {
          addCount++;
        } else if (operation === "-") {
          removeCount++;
        } else if (operation === " ") {
          addCount++;
          removeCount++;
        }
      } else {
        throw new Error(`Hunk at line ${chunkHeaderIndex + 1} contained invalid line ${diffstr[i]}`);
      }
    }
    if (!addCount && hunk.newLines === 1) {
      hunk.newLines = 0;
    }
    if (!removeCount && hunk.oldLines === 1) {
      hunk.oldLines = 0;
    }
    if (addCount !== hunk.newLines) {
      throw new Error("Added line count did not match for hunk at line " + (chunkHeaderIndex + 1));
    }
    if (removeCount !== hunk.oldLines) {
      throw new Error("Removed line count did not match for hunk at line " + (chunkHeaderIndex + 1));
    }
    return hunk;
  }
  while (i < diffstr.length) {
    parseIndex();
  }
  return list;
}

// node_modules/diff/libesm/util/distance-iterator.js
function distance_iterator_default(start, minLine, maxLine) {
  let wantForward = true, backwardExhausted = false, forwardExhausted = false, localOffset = 1;
  return function iterator() {
    if (wantForward && !forwardExhausted) {
      if (backwardExhausted) {
        localOffset++;
      } else {
        wantForward = false;
      }
      if (start + localOffset <= maxLine) {
        return start + localOffset;
      }
      forwardExhausted = true;
    }
    if (!backwardExhausted) {
      if (!forwardExhausted) {
        wantForward = true;
      }
      if (minLine <= start - localOffset) {
        return start - localOffset++;
      }
      backwardExhausted = true;
      return iterator();
    }
    return;
  };
}

// node_modules/diff/libesm/patch/apply.js
function applyPatch(source, patch, options = {}) {
  let patches;
  if (typeof patch === "string") {
    patches = parsePatch(patch);
  } else if (Array.isArray(patch)) {
    patches = patch;
  } else {
    patches = [patch];
  }
  if (patches.length > 1) {
    throw new Error("applyPatch only works with a single input.");
  }
  return applyStructuredPatch(source, patches[0], options);
}
function applyStructuredPatch(source, patch, options = {}) {
  if (options.autoConvertLineEndings || options.autoConvertLineEndings == null) {
    if (hasOnlyWinLineEndings(source) && isUnix(patch)) {
      patch = unixToWin(patch);
    } else if (hasOnlyUnixLineEndings(source) && isWin(patch)) {
      patch = winToUnix(patch);
    }
  }
  const lines = source.split(`
`), hunks = patch.hunks, compareLine = options.compareLine || ((lineNumber, line, operation, patchContent) => line === patchContent), fuzzFactor = options.fuzzFactor || 0;
  let minLine = 0;
  if (fuzzFactor < 0 || !Number.isInteger(fuzzFactor)) {
    throw new Error("fuzzFactor must be a non-negative integer");
  }
  if (!hunks.length) {
    return source;
  }
  let prevLine = "", removeEOFNL = false, addEOFNL = false;
  for (let i = 0;i < hunks[hunks.length - 1].lines.length; i++) {
    const line = hunks[hunks.length - 1].lines[i];
    if (line[0] == "\\") {
      if (prevLine[0] == "+") {
        removeEOFNL = true;
      } else if (prevLine[0] == "-") {
        addEOFNL = true;
      }
    }
    prevLine = line;
  }
  if (removeEOFNL) {
    if (addEOFNL) {
      if (!fuzzFactor && lines[lines.length - 1] == "") {
        return false;
      }
    } else if (lines[lines.length - 1] == "") {
      lines.pop();
    } else if (!fuzzFactor) {
      return false;
    }
  } else if (addEOFNL) {
    if (lines[lines.length - 1] != "") {
      lines.push("");
    } else if (!fuzzFactor) {
      return false;
    }
  }
  function applyHunk(hunkLines, toPos, maxErrors, hunkLinesI = 0, lastContextLineMatched = true, patchedLines = [], patchedLinesLength = 0) {
    let nConsecutiveOldContextLines = 0;
    let nextContextLineMustMatch = false;
    for (;hunkLinesI < hunkLines.length; hunkLinesI++) {
      const hunkLine = hunkLines[hunkLinesI], operation = hunkLine.length > 0 ? hunkLine[0] : " ", content = hunkLine.length > 0 ? hunkLine.substr(1) : hunkLine;
      if (operation === "-") {
        if (compareLine(toPos + 1, lines[toPos], operation, content)) {
          toPos++;
          nConsecutiveOldContextLines = 0;
        } else {
          if (!maxErrors || lines[toPos] == null) {
            return null;
          }
          patchedLines[patchedLinesLength] = lines[toPos];
          return applyHunk(hunkLines, toPos + 1, maxErrors - 1, hunkLinesI, false, patchedLines, patchedLinesLength + 1);
        }
      }
      if (operation === "+") {
        if (!lastContextLineMatched) {
          return null;
        }
        patchedLines[patchedLinesLength] = content;
        patchedLinesLength++;
        nConsecutiveOldContextLines = 0;
        nextContextLineMustMatch = true;
      }
      if (operation === " ") {
        nConsecutiveOldContextLines++;
        patchedLines[patchedLinesLength] = lines[toPos];
        if (compareLine(toPos + 1, lines[toPos], operation, content)) {
          patchedLinesLength++;
          lastContextLineMatched = true;
          nextContextLineMustMatch = false;
          toPos++;
        } else {
          if (nextContextLineMustMatch || !maxErrors) {
            return null;
          }
          return lines[toPos] && (applyHunk(hunkLines, toPos + 1, maxErrors - 1, hunkLinesI + 1, false, patchedLines, patchedLinesLength + 1) || applyHunk(hunkLines, toPos + 1, maxErrors - 1, hunkLinesI, false, patchedLines, patchedLinesLength + 1)) || applyHunk(hunkLines, toPos, maxErrors - 1, hunkLinesI + 1, false, patchedLines, patchedLinesLength);
        }
      }
    }
    patchedLinesLength -= nConsecutiveOldContextLines;
    toPos -= nConsecutiveOldContextLines;
    patchedLines.length = patchedLinesLength;
    return {
      patchedLines,
      oldLineLastI: toPos - 1
    };
  }
  const resultLines = [];
  let prevHunkOffset = 0;
  for (let i = 0;i < hunks.length; i++) {
    const hunk = hunks[i];
    let hunkResult;
    const maxLine = lines.length - hunk.oldLines + fuzzFactor;
    let toPos;
    for (let maxErrors = 0;maxErrors <= fuzzFactor; maxErrors++) {
      toPos = hunk.oldStart + prevHunkOffset - 1;
      const iterator = distance_iterator_default(toPos, minLine, maxLine);
      for (;toPos !== undefined; toPos = iterator()) {
        hunkResult = applyHunk(hunk.lines, toPos, maxErrors);
        if (hunkResult) {
          break;
        }
      }
      if (hunkResult) {
        break;
      }
    }
    if (!hunkResult) {
      return false;
    }
    for (let i2 = minLine;i2 < toPos; i2++) {
      resultLines.push(lines[i2]);
    }
    for (let i2 = 0;i2 < hunkResult.patchedLines.length; i2++) {
      const line = hunkResult.patchedLines[i2];
      resultLines.push(line);
    }
    minLine = hunkResult.oldLineLastI + 1;
    prevHunkOffset = toPos + 1 - hunk.oldStart;
  }
  for (let i = minLine;i < lines.length; i++) {
    resultLines.push(lines[i]);
  }
  return resultLines.join(`
`);
}

// node_modules/diff/libesm/patch/create.js
function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  let optionsObj;
  if (!options) {
    optionsObj = {};
  } else if (typeof options === "function") {
    optionsObj = { callback: options };
  } else {
    optionsObj = options;
  }
  if (typeof optionsObj.context === "undefined") {
    optionsObj.context = 4;
  }
  const context = optionsObj.context;
  if (optionsObj.newlineIsToken) {
    throw new Error("newlineIsToken may not be used with patch-generation functions, only with diffing functions");
  }
  if (!optionsObj.callback) {
    return diffLinesResultToPatch(diffLines(oldStr, newStr, optionsObj));
  } else {
    const { callback } = optionsObj;
    diffLines(oldStr, newStr, Object.assign(Object.assign({}, optionsObj), { callback: (diff) => {
      const patch = diffLinesResultToPatch(diff);
      callback(patch);
    } }));
  }
  function diffLinesResultToPatch(diff) {
    if (!diff) {
      return;
    }
    diff.push({ value: "", lines: [] });
    function contextLines(lines) {
      return lines.map(function(entry) {
        return " " + entry;
      });
    }
    const hunks = [];
    let oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;
    for (let i = 0;i < diff.length; i++) {
      const current = diff[i], lines = current.lines || splitLines(current.value);
      current.lines = lines;
      if (current.added || current.removed) {
        if (!oldRangeStart) {
          const prev = diff[i - 1];
          oldRangeStart = oldLine;
          newRangeStart = newLine;
          if (prev) {
            curRange = context > 0 ? contextLines(prev.lines.slice(-context)) : [];
            oldRangeStart -= curRange.length;
            newRangeStart -= curRange.length;
          }
        }
        for (const line of lines) {
          curRange.push((current.added ? "+" : "-") + line);
        }
        if (current.added) {
          newLine += lines.length;
        } else {
          oldLine += lines.length;
        }
      } else {
        if (oldRangeStart) {
          if (lines.length <= context * 2 && i < diff.length - 2) {
            for (const line of contextLines(lines)) {
              curRange.push(line);
            }
          } else {
            const contextSize = Math.min(lines.length, context);
            for (const line of contextLines(lines.slice(0, contextSize))) {
              curRange.push(line);
            }
            const hunk = {
              oldStart: oldRangeStart,
              oldLines: oldLine - oldRangeStart + contextSize,
              newStart: newRangeStart,
              newLines: newLine - newRangeStart + contextSize,
              lines: curRange
            };
            hunks.push(hunk);
            oldRangeStart = 0;
            newRangeStart = 0;
            curRange = [];
          }
        }
        oldLine += lines.length;
        newLine += lines.length;
      }
    }
    for (const hunk of hunks) {
      for (let i = 0;i < hunk.lines.length; i++) {
        if (hunk.lines[i].endsWith(`
`)) {
          hunk.lines[i] = hunk.lines[i].slice(0, -1);
        } else {
          hunk.lines.splice(i + 1, 0, "\\ No newline at end of file");
          i++;
        }
      }
    }
    return {
      oldFileName,
      newFileName,
      oldHeader,
      newHeader,
      hunks
    };
  }
}
function splitLines(text) {
  const hasTrailingNl = text.endsWith(`
`);
  const result = text.split(`
`).map((line) => line + `
`);
  if (hasTrailingNl) {
    result.pop();
  } else {
    result.push(result.pop().slice(0, -1));
  }
  return result;
}

// src/domains/sync/sync-engine.ts
var MAX_SYNC_FILE_SIZE = 10 * 1024 * 1024;
var MAX_SYMLINK_DEPTH = 20;
async function validateSymlinkChain(path2, basePath, maxDepth = MAX_SYMLINK_DEPTH) {
  let current = path2;
  let depth = 0;
  while (depth < maxDepth) {
    try {
      const stats = await lstat(current);
      if (!stats.isSymbolicLink())
        break;
      const target = await readlink(current);
      const resolvedTarget = isAbsolute(target) ? target : join22(current, "..", target);
      const normalizedTarget = normalize5(resolvedTarget);
      const rel = relative2(basePath, normalizedTarget);
      if (rel.startsWith("..") || isAbsolute(rel)) {
        throw new Error(`Symlink chain escapes base directory at depth ${depth}: ${path2}`);
      }
      current = normalizedTarget;
      depth++;
    } catch (error) {
      if (error instanceof Error && error.message.includes("Symlink chain")) {
        throw error;
      }
      break;
    }
  }
  if (depth >= maxDepth) {
    throw new Error(`Symlink chain too deep (>${maxDepth}): ${path2}`);
  }
}
async function validateSyncPath(basePath, filePath) {
  if (!filePath || filePath.trim() === "") {
    throw new Error("Empty file path not allowed");
  }
  if (filePath.includes("\x00")) {
    throw new Error(`Invalid file path (null byte): ${filePath}`);
  }
  if (filePath.length > 1024) {
    throw new Error(`Path too long: ${filePath.slice(0, 50)}...`);
  }
  const normalized = normalize5(filePath);
  if (isAbsolute(normalized)) {
    throw new Error(`Absolute paths not allowed: ${filePath}`);
  }
  if (normalized.startsWith("..") || normalized.includes("/../")) {
    throw new Error(`Path traversal not allowed: ${filePath}`);
  }
  const fullPath = join22(basePath, normalized);
  const rel = relative2(basePath, fullPath);
  if (rel.startsWith("..") || isAbsolute(rel)) {
    throw new Error(`Path escapes base directory: ${filePath}`);
  }
  await validateSymlinkChain(fullPath, basePath);
  try {
    const resolvedBase = await realpath(basePath);
    const resolvedFull = await realpath(fullPath);
    const resolvedRel = relative2(resolvedBase, resolvedFull);
    if (resolvedRel.startsWith("..") || isAbsolute(resolvedRel)) {
      throw new Error(`Symlink escapes base directory: ${filePath}`);
    }
  } catch (error) {
    if (error.code === "ENOENT") {
      const parentPath = join22(fullPath, "..");
      try {
        const resolvedBase = await realpath(basePath);
        const resolvedParent = await realpath(parentPath);
        const resolvedRel = relative2(resolvedBase, resolvedParent);
        if (resolvedRel.startsWith("..") || isAbsolute(resolvedRel)) {
          throw new Error(`Parent symlink escapes base directory: ${filePath}`);
        }
      } catch (parentError) {
        if (parentError.code !== "ENOENT") {
          throw parentError;
        }
      }
    } else {
      throw error;
    }
  }
  return fullPath;
}

class SyncEngine {
  static async createSyncPlan(trackedFiles, claudeDir, upstreamDir) {
    const plan = { autoUpdate: [], needsReview: [], skipped: [] };
    for (const file of trackedFiles) {
      if (file.ownership === "user") {
        plan.skipped.push(file);
        continue;
      }
      let upstreamPath;
      try {
        upstreamPath = await validateSyncPath(upstreamDir, file.path);
      } catch (error) {
        logger.warning(`Skipping invalid path: ${file.path}`);
        plan.skipped.push(file);
        continue;
      }
      try {
        await stat2(upstreamPath);
      } catch {
        plan.skipped.push(file);
        continue;
      }
      let localPath;
      try {
        localPath = await validateSyncPath(claudeDir, file.path);
      } catch (error) {
        logger.warning(`Skipping invalid local path: ${file.path}`);
        plan.skipped.push(file);
        continue;
      }
      try {
        await stat2(localPath);
      } catch {
        plan.autoUpdate.push(file);
        continue;
      }
      if (file.ownership === "ck") {
        plan.autoUpdate.push(file);
        continue;
      }
      const currentChecksum = await OwnershipChecker.calculateChecksum(localPath);
      const baseChecksum = file.baseChecksum || file.checksum;
      if (currentChecksum === baseChecksum) {
        plan.autoUpdate.push(file);
      } else {
        plan.needsReview.push(file);
      }
    }
    return plan;
  }
  static generateHunks(currentContent, newContent, filename, contextLines = 3) {
    const patch = structuredPatch(filename, filename, currentContent, newContent, "", "", {
      context: contextLines
    });
    return patch.hunks.map((hunk) => ({
      oldStart: hunk.oldStart,
      oldLines: hunk.oldLines,
      newStart: hunk.newStart,
      newLines: hunk.newLines,
      lines: hunk.lines
    }));
  }
  static applyHunks(content, hunks, accepted) {
    const acceptedHunks = hunks.filter((_3, i) => accepted[i]);
    if (acceptedHunks.length === 0) {
      return content;
    }
    const patchStr = SyncEngine.buildUnifiedDiff(content, acceptedHunks);
    const result = applyPatch(content, patchStr);
    if (result === false) {
      try {
        return SyncEngine.applyHunksManually(content, acceptedHunks);
      } catch (fallbackError) {
        throw new Error(`Failed to apply ${acceptedHunks.length} hunk(s): patch and manual methods both failed. ` + `Manual error: ${fallbackError instanceof Error ? fallbackError.message : String(fallbackError)}`);
      }
    }
    return result;
  }
  static buildUnifiedDiff(_content, hunks) {
    let diff = `--- a
+++ b
`;
    for (const hunk of hunks) {
      diff += `@@ -${hunk.oldStart},${hunk.oldLines} +${hunk.newStart},${hunk.newLines} @@
`;
      for (const line of hunk.lines) {
        diff += `${line}
`;
      }
    }
    return diff;
  }
  static applyHunksManually(content, hunks) {
    const lines = content.split(`
`);
    const sortedHunks = [...hunks].sort((a3, b3) => b3.oldStart - a3.oldStart);
    for (const hunk of sortedHunks) {
      const startIndex = hunk.oldStart - 1;
      if (startIndex < 0 || startIndex > lines.length) {
        logger.warning(`Hunk start ${hunk.oldStart} out of bounds (file has ${lines.length} lines)`);
        continue;
      }
      const newLines = [];
      let deleteCount = 0;
      for (const line of hunk.lines) {
        if (!line || line.length === 0) {
          continue;
        }
        const prefix = line[0];
        const lineContent = line.slice(1);
        if (prefix === "-") {
          deleteCount++;
        } else if (prefix === "+" || prefix === " ") {
          newLines.push(lineContent);
        }
      }
      if (startIndex + deleteCount > lines.length) {
        logger.warning(`Hunk would delete past EOF (start: ${startIndex}, delete: ${deleteCount}, lines: ${lines.length})`);
        continue;
      }
      lines.splice(startIndex, deleteCount, ...newLines);
    }
    return lines.join(`
`);
  }
  static isBinaryFile(content) {
    if (content.length === 0) {
      return false;
    }
    const sampleSize = Math.min(content.length, 8192);
    let nonPrintableCount = 0;
    for (let i = 0;i < sampleSize; i++) {
      const code = content.charCodeAt(i);
      if (code === 0) {
        return true;
      }
      if (code < 32 && code !== 9 && code !== 10 && code !== 13) {
        nonPrintableCount++;
      }
    }
    return nonPrintableCount / sampleSize > 0.1;
  }
  static async loadFileContent(filePath) {
    try {
      const lstats = await lstat(filePath);
      if (lstats.isSymbolicLink()) {
        throw new Error(`Symlink not allowed for sync: ${filePath}`);
      }
      if (lstats.size > MAX_SYNC_FILE_SIZE) {
        throw new Error(`File too large for sync (${Math.round(lstats.size / 1024 / 1024)}MB > ${MAX_SYNC_FILE_SIZE / 1024 / 1024}MB limit)`);
      }
      const buffer = await readFile10(filePath);
      if (buffer.includes(0)) {
        return { content: "", isBinary: true };
      }
      const content = buffer.toString("utf8");
      if (content.includes("")) {
        return { content: "", isBinary: true };
      }
      if (SyncEngine.isBinaryFile(content)) {
        return { content: "", isBinary: true };
      }
      return { content, isBinary: false };
    } catch (error) {
      const errMsg = error instanceof Error ? error.message : "Unknown error";
      throw new Error(`Cannot read file for sync: ${filePath} - ${errMsg}`);
    }
  }
}
// src/domains/sync/merge-ui.ts
init_dist2();
var import_picocolors9 = __toESM(require_picocolors(), 1);
var HUNK_SEPARATOR_WIDTH = 50;
var EXTENDED_CONTEXT_LINES = 10;
var MAX_LINE_DISPLAY_LENGTH = 120;
function requireTTY() {
  if (!process.stdin.isTTY || !process.stdout.isTTY) {
    throw new Error("Interactive merge requires a TTY terminal. " + "Use --yes flag for non-interactive mode, or run in a terminal.");
  }
}
function truncateLine(line) {
  if (line.length <= MAX_LINE_DISPLAY_LENGTH)
    return line;
  return `${line.slice(0, MAX_LINE_DISPLAY_LENGTH - 3)}...`;
}

class MergeUI {
  static async promptHunk(hunk, hunkIndex, totalHunks, _filename) {
    requireTTY();
    const lineRange = `${hunk.oldStart}-${hunk.oldStart + hunk.oldLines - 1}`;
    console.log(import_picocolors9.default.cyan(`
Hunk ${hunkIndex + 1}/${totalHunks}: Lines ${lineRange}`));
    console.log(import_picocolors9.default.dim("".repeat(HUNK_SEPARATOR_WIDTH)));
    for (const line of hunk.lines) {
      const displayLine = truncateLine(line);
      const prefix = line[0];
      if (prefix === "+") {
        console.log(import_picocolors9.default.green(displayLine));
      } else if (prefix === "-") {
        console.log(import_picocolors9.default.red(displayLine));
      } else {
        console.log(import_picocolors9.default.dim(displayLine));
      }
    }
    console.log(import_picocolors9.default.dim("".repeat(HUNK_SEPARATOR_WIDTH)));
    const action = await ie({
      message: "Action?",
      options: [
        { value: "accept", label: "[a]ccept - Apply this change" },
        { value: "reject", label: "[r]eject - Keep current" },
        { value: "view", label: "[v]iew - More context" },
        { value: "skip", label: "[s]kip - Skip entire file" }
      ]
    });
    if (lD(action)) {
      return "skip";
    }
    return action;
  }
  static showExtendedContext(currentContent, hunk, contextLines = EXTENDED_CONTEXT_LINES) {
    const lines = currentContent.split(`
`);
    const startLine = Math.max(0, hunk.oldStart - 1 - contextLines);
    const endLine = Math.min(lines.length, hunk.oldStart + hunk.oldLines - 1 + contextLines);
    console.log(import_picocolors9.default.cyan(`
Extended context (lines ${startLine + 1}-${endLine}):`));
    console.log(import_picocolors9.default.dim("".repeat(HUNK_SEPARATOR_WIDTH)));
    for (let i = startLine;i < endLine; i++) {
      const lineNum = String(i + 1).padStart(4, " ");
      const isInHunk = i >= hunk.oldStart - 1 && i < hunk.oldStart - 1 + hunk.oldLines;
      const prefix = isInHunk ? import_picocolors9.default.yellow("*") : " ";
      console.log(`${import_picocolors9.default.dim(lineNum)} ${prefix} ${lines[i]}`);
    }
    console.log(import_picocolors9.default.dim("".repeat(HUNK_SEPARATOR_WIDTH)));
  }
  static async mergeFile(filename, currentContent, _newContent, hunks) {
    console.log(import_picocolors9.default.bold(`
 ${filename} `));
    console.log(import_picocolors9.default.dim(`${hunks.length} change${hunks.length === 1 ? "" : "s"} to review
`));
    const decisions = [];
    for (let i = 0;i < hunks.length; i++) {
      let action;
      do {
        action = await MergeUI.promptHunk(hunks[i], i, hunks.length, filename);
        if (action === "view") {
          MergeUI.showExtendedContext(currentContent, hunks[i]);
        }
      } while (action === "view");
      if (action === "skip") {
        return "skipped";
      }
      decisions.push(action === "accept");
    }
    const result = SyncEngine.applyHunks(currentContent, hunks, decisions);
    const applied = decisions.filter(Boolean).length;
    const rejected = decisions.length - applied;
    return { result, applied, rejected };
  }
  static displayMergeSummary(filename, applied, rejected) {
    if (applied > 0 && rejected > 0) {
      console.log(import_picocolors9.default.dim(`  ${filename}: `) + import_picocolors9.default.green(`${applied} applied`) + import_picocolors9.default.dim(", ") + import_picocolors9.default.yellow(`${rejected} rejected`));
    } else if (applied > 0) {
      console.log(import_picocolors9.default.dim(`  ${filename}: `) + import_picocolors9.default.green(`${applied} applied`));
    } else {
      console.log(import_picocolors9.default.dim(`  ${filename}: `) + import_picocolors9.default.yellow(`${rejected} rejected`));
    }
  }
  static displaySkipped(filename) {
    console.log(import_picocolors9.default.dim(`  ${filename}: `) + import_picocolors9.default.yellow("skipped"));
  }
}
// src/domains/sync/notification-display.ts
var import_picocolors10 = __toESM(require_picocolors(), 1);
import { stdout } from "node:process";
function createNotificationBox(borderColor, boxWidth) {
  const contentWidth = boxWidth - 2;
  const topBorder = borderColor(`${"".repeat(contentWidth)}`);
  const bottomBorder = borderColor(`${"".repeat(contentWidth)}`);
  const emptyLine = borderColor("") + " ".repeat(contentWidth) + borderColor("");
  const padLine = (text, visibleLen) => {
    const len = visibleLen ?? text.length;
    const displayText = len > contentWidth ? `${text.slice(0, contentWidth - 3)}...` : text;
    const actualLen = visibleLen ?? displayText.length;
    const totalPadding = contentWidth - actualLen;
    const leftPadding = Math.max(0, Math.floor(totalPadding / 2));
    const rightPadding = Math.max(0, totalPadding - leftPadding);
    return borderColor("") + " ".repeat(leftPadding) + displayText + " ".repeat(rightPadding) + borderColor("");
  };
  return { topBorder, bottomBorder, emptyLine, padLine };
}
function displayConfigUpdateNotification(currentVersion, latestVersion, isGlobal = false) {
  const displayCurrent = currentVersion.replace(/^v/, "");
  const displayLatest = latestVersion.replace(/^v/, "");
  const terminalWidth = stdout.columns || 80;
  const boxWidth = Math.min(52, terminalWidth - 4);
  const { topBorder, bottomBorder, emptyLine, padLine } = createNotificationBox(import_picocolors10.default.cyan, boxWidth);
  const headerText = import_picocolors10.default.bold(import_picocolors10.default.yellow("\uD83D\uDCE6 Config Updates Available"));
  const headerLen = "\uD83D\uDCE6 Config Updates Available".length;
  const versionText = `${import_picocolors10.default.dim(displayCurrent)} ${import_picocolors10.default.white("")} ${import_picocolors10.default.green(import_picocolors10.default.bold(displayLatest))}`;
  const versionLen = displayCurrent.length + 3 + displayLatest.length;
  const updateCmd = isGlobal ? "ck init -g --sync" : "ck init --sync";
  const commandText = `Run: ${import_picocolors10.default.cyan(import_picocolors10.default.bold(updateCmd))}`;
  const commandLen = `Run: ${updateCmd}`.length;
  console.log("");
  console.log(topBorder);
  console.log(emptyLine);
  console.log(padLine(headerText, headerLen));
  console.log(padLine(versionText, versionLen));
  console.log(emptyLine);
  console.log(padLine(commandText, commandLen));
  console.log(emptyLine);
  console.log(bottomBorder);
  console.log("");
}
// src/domains/sync/passive-update-check.ts
init_logger();
async function maybeShowConfigUpdateNotification(claudeDir, global2) {
  try {
    const detection = await detectMetadataFormat(claudeDir);
    if (detection.format === "none" || !detection.metadata) {
      logger.debug("No metadata found, skipping update check");
      return false;
    }
    const kitsToCheck = [];
    if (detection.format === "multi-kit" && detection.metadata.kits) {
      for (const [kitType, kitInfo] of Object.entries(detection.metadata.kits)) {
        if (kitInfo?.version) {
          kitsToCheck.push({ kit: kitType, version: kitInfo.version });
        }
      }
    } else if (detection.format === "legacy" && detection.detectedKit && detection.metadata.version) {
      kitsToCheck.push({
        kit: detection.detectedKit,
        version: detection.metadata.version
      });
    }
    if (kitsToCheck.length === 0) {
      logger.debug("No kits with versions found, skipping update check");
      return false;
    }
    for (const { kit, version } of kitsToCheck) {
      const result = await ConfigVersionChecker.checkForUpdates(kit, version, global2);
      if (result.hasUpdates) {
        displayConfigUpdateNotification(result.currentVersion, result.latestVersion, global2);
        return true;
      }
    }
    return false;
  } catch (error) {
    logger.debug(`Passive update check failed: ${error instanceof Error ? error.message : error}`);
    return false;
  }
}
// src/domains/ui/prompts.ts
init_package_installer();
init_logger();

// src/domains/ui/prompts/kit-prompts.ts
init_types2();
var MIN_KITS_FOR_MULTISELECT = 2;
async function selectKit(defaultKit, accessibleKits) {
  const kits = accessibleKits ?? Object.keys(AVAILABLE_KITS);
  const kit = await ie({
    message: "Select a ClaudeKit:",
    options: kits.map((key) => ({
      value: key,
      label: AVAILABLE_KITS[key].name,
      hint: AVAILABLE_KITS[key].description
    })),
    initialValue: defaultKit
  });
  if (lD(kit)) {
    throw new Error("Kit selection cancelled");
  }
  return kit;
}
async function selectKits(accessibleKits) {
  if (accessibleKits.length < MIN_KITS_FOR_MULTISELECT) {
    throw new Error(`selectKits requires at least ${MIN_KITS_FOR_MULTISELECT} accessible kits`);
  }
  const selected = await ae({
    message: "Select ClaudeKit(s) to install:",
    options: accessibleKits.map((key) => ({
      value: key,
      label: AVAILABLE_KITS[key].name,
      hint: AVAILABLE_KITS[key].description
    })),
    required: true
  });
  if (lD(selected)) {
    throw new Error("Kit selection cancelled");
  }
  return selected;
}
async function getDirectory(defaultDir = ".") {
  const dir = await te({
    message: "Enter target directory:",
    placeholder: `Press Enter for "${defaultDir}"`,
    validate: () => {
      return;
    }
  });
  if (lD(dir)) {
    throw new Error("Directory input cancelled");
  }
  const trimmed = (dir ?? "").trim();
  return trimmed.length > 0 ? trimmed : defaultDir;
}
// src/domains/versioning/version-selector.ts
init_github_client();
init_logger();
init_dist2();
var import_picocolors13 = __toESM(require_picocolors(), 1);

// src/domains/versioning/selection/version-filter.ts
var VERSION_PATTERN = /^v?\d+\.\d+\.\d+/;
function isValidVersionFormat(version) {
  return VERSION_PATTERN.test(version.trim());
}
function normalizeVersionTag(version) {
  const trimmed = version.trim();
  return trimmed.startsWith("v") ? trimmed : `v${trimmed}`;
}
// src/domains/versioning/selection/selection-ui.ts
init_environment();
init_logger();
init_dist2();
var import_picocolors12 = __toESM(require_picocolors(), 1);

// src/domains/versioning/version-display.ts
var import_picocolors11 = __toESM(require_picocolors(), 1);

class VersionDisplayFormatter {
  static createBadges(release) {
    const badges = [];
    if (release.isLatestStable) {
      badges.push(import_picocolors11.default.bold(import_picocolors11.default.yellow("[latest]")));
    }
    if (release.prerelease || release.isLatestBeta) {
      if (release.isLatestBeta) {
        badges.push(import_picocolors11.default.bold(import_picocolors11.default.magenta("[beta]")));
      } else {
        badges.push(import_picocolors11.default.magenta("[prerelease]"));
      }
    } else if (!release.draft) {
      badges.push(import_picocolors11.default.blue("[stable]"));
    }
    if (release.draft) {
      badges.push(import_picocolors11.default.gray("[draft]"));
    }
    return badges.length > 0 ? ` ${badges.join(" ")}` : "";
  }
  static formatChoiceLabel(release) {
    const version = import_picocolors11.default.green(release.displayVersion);
    const badges = VersionDisplayFormatter.createBadges(release);
    const name = release.name || "Release";
    return `${version}${badges} ${import_picocolors11.default.dim(name)}`;
  }
  static formatChoiceHint(release) {
    const parts = [];
    if (release.relativeTime && release.relativeTime !== "Unknown") {
      parts.push(release.relativeTime);
    }
    if (release.assetCount > 0) {
      const assetText = release.assetCount === 1 ? "asset" : "assets";
      parts.push(`${release.assetCount} ${assetText}`);
    }
    if (release.normalizedVersion !== release.displayVersion) {
      parts.push(`(${release.normalizedVersion})`);
    }
    return parts.length > 0 ? parts.join(", ") : "";
  }
  static createSpecialOptions(releases) {
    const options = [];
    const latestStable = releases.find((r2) => r2.isLatestStable && !r2.prerelease);
    if (latestStable) {
      options.push({
        value: latestStable.tag_name,
        label: `${import_picocolors11.default.bold(import_picocolors11.default.green("Latest Stable"))} (${latestStable.displayVersion})`,
        hint: "recommended version",
        isLatest: true,
        isPrerelease: false
      });
    }
    const latestBeta = releases.find((r2) => r2.isLatestBeta || r2.prerelease && !r2.draft);
    if (latestBeta) {
      options.push({
        value: latestBeta.tag_name,
        label: `${import_picocolors11.default.bold(import_picocolors11.default.magenta("Latest Beta"))} (${latestBeta.displayVersion})`,
        hint: "latest features, may be unstable",
        isLatest: false,
        isPrerelease: true
      });
    }
    return options;
  }
  static createSeparator() {
    return {
      value: "separator",
      label: import_picocolors11.default.dim("".repeat(50)),
      hint: undefined,
      isLatest: false,
      isPrerelease: false
    };
  }
  static createCancelOption() {
    return {
      value: "cancel",
      label: import_picocolors11.default.red("Cancel"),
      hint: "exit version selection",
      isLatest: false,
      isPrerelease: false
    };
  }
  static formatVersionChoice(release) {
    return {
      value: release.tag_name,
      label: VersionDisplayFormatter.formatChoiceLabel(release),
      hint: VersionDisplayFormatter.formatChoiceHint(release),
      isLatest: release.isLatestStable,
      isPrerelease: release.prerelease
    };
  }
  static formatReleasesToChoices(releases, includeSpecialOptions = true, limit = 30) {
    const choices = [];
    if (includeSpecialOptions) {
      const specialOptions = VersionDisplayFormatter.createSpecialOptions(releases);
      choices.push(...specialOptions);
      if (specialOptions.length > 0 && releases.length > 0) {
        choices.push(VersionDisplayFormatter.createSeparator());
      }
    }
    const limitedReleases = releases.slice(0, limit);
    for (const release of limitedReleases) {
      choices.push(VersionDisplayFormatter.formatVersionChoice(release));
    }
    if (includeSpecialOptions) {
      choices.push(VersionDisplayFormatter.createSeparator());
      choices.push(VersionDisplayFormatter.createCancelOption());
    }
    return choices;
  }
  static getDefaultChoiceIndex(choices) {
    for (let i = 0;i < choices.length; i++) {
      const choice = choices[i];
      if (choice.isLatest && !choice.isPrerelease) {
        return i;
      }
    }
    for (let i = 0;i < choices.length; i++) {
      if (choices[i].value !== "separator") {
        return i;
      }
    }
    return 0;
  }
  static isValidVersionChoice(value) {
    return value !== "separator" && value !== "cancel" && value.trim().length > 0;
  }
  static formatError(message, suggestion) {
    let output2 = import_picocolors11.default.red(`Error: ${message}`);
    if (suggestion) {
      output2 += `
${import_picocolors11.default.dim(suggestion)}`;
    }
    return output2;
  }
  static formatSuccess(version, kitName) {
    return `${import_picocolors11.default.green("")} Selected ${import_picocolors11.default.bold(version)} for ${import_picocolors11.default.bold(kitName)}`;
  }
}

// src/domains/versioning/selection/selection-ui.ts
async function handleNoReleases(kit, allowManualEntry) {
  le(`No releases found for ${kit.name}.
This could be due to:
 No releases published yet
 Network connectivity issues
 Repository access permissions`, import_picocolors12.default.yellow("No Releases Available"));
  if (!allowManualEntry) {
    throw new Error(`No releases available for ${kit.name}`);
  }
  if (isNonInteractive()) {
    logger.warning(`Non-interactive mode: no releases found for ${kit.name}`);
    logger.info("Provide a specific version with --version flag or run in interactive mode");
    return null;
  }
  const tryManual = await se({
    message: "Would you like to enter a version manually?"
  });
  if (lD(tryManual) || !tryManual) {
    return null;
  }
  return await getManualVersion(kit);
}
async function getManualVersion(kit) {
  if (isNonInteractive()) {
    logger.warning("Non-interactive mode: cannot prompt for manual version entry");
    logger.info("Provide a specific version with --version flag");
    return null;
  }
  const version = await te({
    message: `Enter version tag for ${kit.name}:`,
    placeholder: "v1.0.0",
    validate: (value) => {
      if (!value || value.trim().length === 0) {
        return "Version is required";
      }
      if (!isValidVersionFormat(value)) {
        return "Please enter a valid version (e.g., v1.0.0)";
      }
      return;
    }
  });
  if (lD(version)) {
    return null;
  }
  return normalizeVersionTag(version);
}
async function createVersionPrompt(kit, choices, _defaultIndex, allowManualEntry, releases, currentVersion = null) {
  if (isNonInteractive()) {
    const latestStable2 = releases.find((r2) => r2.isLatestStable && !r2.prerelease);
    if (latestStable2) {
      logger.info(`Non-interactive mode: selecting latest stable version ${latestStable2.tag_name}`);
      return latestStable2.tag_name;
    }
    if (releases.length > 0) {
      logger.info(`Non-interactive mode: selecting version ${releases[0].tag_name}`);
      return releases[0].tag_name;
    }
    logger.warning("Non-interactive mode: no versions available");
    return null;
  }
  const clackChoices = [];
  const latestStable = releases.find((r2) => r2.isLatestStable && !r2.prerelease);
  if (latestStable) {
    clackChoices.push({
      value: latestStable.tag_name,
      label: `${import_picocolors12.default.bold(import_picocolors12.default.green("Latest Stable"))} (${latestStable.displayVersion})`,
      hint: "recommended"
    });
  }
  if (allowManualEntry) {
    clackChoices.push({
      value: "manual-entry",
      label: import_picocolors12.default.cyan(" Enter Version Manually"),
      hint: "for older versions"
    });
  }
  clackChoices.push({
    value: "cancel",
    label: import_picocolors12.default.red(" Cancel")
  });
  const versionChoices = choices.filter((choice) => choice.value !== "separator" && choice.value !== "cancel");
  for (const choice of versionChoices) {
    const isCurrentlyInstalled = currentVersion && (choice.value === currentVersion || choice.value === `v${currentVersion}`);
    const installedMarker = isCurrentlyInstalled ? import_picocolors12.default.cyan(" (installed)") : "";
    clackChoices.push({
      value: choice.value,
      label: `${choice.label}${installedMarker}`,
      hint: choice.hint
    });
  }
  const currentVersionHint = currentVersion ? import_picocolors12.default.dim(` (current: ${currentVersion})`) : "";
  const selected = await ie({
    message: `Select version for ${import_picocolors12.default.bold(kit.name)}${currentVersionHint}:`,
    options: clackChoices,
    initialValue: latestStable?.tag_name
  });
  if (lD(selected)) {
    return null;
  }
  if (selected === "manual-entry") {
    return await getManualVersion(kit);
  }
  if (selected === "cancel") {
    return null;
  }
  if (!VersionDisplayFormatter.isValidVersionChoice(selected)) {
    throw new Error(`Invalid version selection: ${selected}`);
  }
  const selectedChoice = choices.find((c2) => c2.value === selected);
  if (selectedChoice && !selectedChoice.isLatest) {
    le(VersionDisplayFormatter.formatSuccess(selected, kit.name), "Version Selected");
  }
  return selected;
}
async function handleSelectionError(error, kit, allowManualEntry, retryCallback) {
  logger.error(`Version selection error: ${error.message}`);
  if (error.message.includes("401") || error.message.includes("403")) {
    le(VersionDisplayFormatter.formatError("Authentication failed", "Please check your GitHub token with: ck auth"), import_picocolors12.default.red("Authentication Error"));
  } else if (error.message.includes("404")) {
    le(VersionDisplayFormatter.formatError("Repository access denied", "Make sure you have access to the repository"), import_picocolors12.default.red("Access Error"));
  } else if (error.message.includes("rate limit") || error.message.includes("403")) {
    le(VersionDisplayFormatter.formatError("GitHub API rate limit exceeded", "Please wait a moment and try again"), import_picocolors12.default.yellow("Rate Limited"));
  } else if (error.message.includes("network") || error.message.includes("ENOTFOUND")) {
    le(VersionDisplayFormatter.formatError("Network connection failed", "Please check your internet connection"), import_picocolors12.default.yellow("Network Error"));
  } else {
    le(VersionDisplayFormatter.formatError(error.message || "Unknown error occurred", "Please try again or contact support"), import_picocolors12.default.red("Error"));
  }
  if (isNonInteractive()) {
    logger.warning("Non-interactive mode: version selection failed, cannot retry");
    return null;
  }
  if (allowManualEntry) {
    const retry2 = await se({
      message: "Would you like to try entering a version manually?"
    });
    if (lD(retry2) || !retry2) {
      return null;
    }
    return await getManualVersion(kit);
  }
  const retry = await se({
    message: "Would you like to retry?"
  });
  if (lD(retry) || !retry) {
    return null;
  }
  return retryCallback();
}
function getDefaultIndex(choices, defaultValue) {
  if (defaultValue) {
    const index = choices.findIndex((c2) => c2.value === defaultValue);
    if (index >= 0) {
      return index;
    }
  }
  return VersionDisplayFormatter.getDefaultChoiceIndex(choices);
}
// src/domains/versioning/version-selector.ts
class VersionSelector {
  githubClient;
  constructor(githubClient) {
    this.githubClient = githubClient ?? new GitHubClient;
  }
  async selectVersion(options) {
    const {
      kit,
      includePrereleases = false,
      limit = 10,
      defaultValue,
      allowManualEntry = false,
      forceRefresh = false,
      currentVersion = null
    } = options;
    try {
      const loadingSpinner = de();
      loadingSpinner.start(`Fetching versions for ${import_picocolors13.default.bold(kit.name)}...`);
      const releases = await this.githubClient.listReleasesWithCache(kit, {
        limit: limit * 2,
        includePrereleases,
        forceRefresh
      });
      loadingSpinner.stop();
      if (releases.length === 0) {
        return handleNoReleases(kit, allowManualEntry);
      }
      const choices = VersionDisplayFormatter.formatReleasesToChoices(releases, false, limit);
      const defaultIndex = getDefaultIndex(choices, defaultValue);
      return await createVersionPrompt(kit, choices, defaultIndex, allowManualEntry, releases, currentVersion);
    } catch (error) {
      logger.error(`Version selection failed for ${kit.name}: ${error.message}`);
      return handleSelectionError(error, kit, allowManualEntry, () => this.selectVersion({ kit, includePrereleases: false, allowManualEntry }));
    }
  }
  async getLatestVersion(kit, includePrereleases = false, forceRefresh = false) {
    try {
      const releases = await this.githubClient.listReleasesWithCache(kit, {
        limit: 5,
        includePrereleases,
        forceRefresh
      });
      if (releases.length === 0) {
        return null;
      }
      return releases[0].tag_name;
    } catch (error) {
      logger.error(`Failed to get latest version for ${kit.name}: ${error}`);
      return null;
    }
  }
}

// src/domains/ui/prompts/version-prompts.ts
async function selectVersion(versions, defaultVersion) {
  if (versions.length === 0) {
    throw new Error("No versions available");
  }
  if (versions.length === 1 || !defaultVersion) {
    return versions[0];
  }
  const version = await ie({
    message: "Select a version:",
    options: versions.map((v2) => ({
      value: v2,
      label: v2
    })),
    initialValue: defaultVersion
  });
  if (lD(version)) {
    throw new Error("Version selection cancelled");
  }
  return version;
}
async function selectVersionEnhanced(options) {
  const selector = new VersionSelector;
  return await selector.selectVersion(options);
}
async function getLatestVersion(kit, includePrereleases = false) {
  const selector = new VersionSelector;
  return await selector.getLatestVersion(kit, includePrereleases);
}
// src/domains/ui/prompts/installation-prompts.ts
init_logger();
init_path_resolver();
async function promptUpdateMode() {
  const updateEverything = await se({
    message: "Do you want to update everything?"
  });
  if (lD(updateEverything)) {
    throw new Error("Update cancelled");
  }
  return updateEverything;
}
async function promptDirectorySelection(global2 = false) {
  log.step("Select directories to update");
  const prefix = PathResolver.getPathPrefix(global2);
  const categories = [
    { key: "agents", label: "Agents", pattern: prefix ? `${prefix}/agents` : "agents" },
    { key: "commands", label: "Commands", pattern: prefix ? `${prefix}/commands` : "commands" },
    {
      key: "rules",
      label: "Rules",
      pattern: prefix ? `${prefix}/rules` : "rules"
    },
    { key: "skills", label: "Skills", pattern: prefix ? `${prefix}/skills` : "skills" },
    { key: "hooks", label: "Hooks", pattern: prefix ? `${prefix}/hooks` : "hooks" }
  ];
  const selectedCategories = [];
  for (const category of categories) {
    const shouldInclude = await se({
      message: `Include ${category.label}?`
    });
    if (lD(shouldInclude)) {
      throw new Error("Update cancelled");
    }
    if (shouldInclude) {
      selectedCategories.push(category.pattern);
    }
  }
  if (selectedCategories.length === 0) {
    throw new Error("No directories selected for update");
  }
  return selectedCategories;
}
async function promptFreshConfirmation(targetPath, analysis) {
  logger.warning("[!] Fresh installation will remove ClaudeKit files:");
  logger.info(`Path: ${targetPath}`);
  if (analysis?.hasMetadata) {
    const ckCount = analysis.ckFiles.length + analysis.ckModifiedFiles.length;
    const userCount = analysis.userFiles.length;
    logger.info(`  Remove: ${ckCount} CK-owned files`);
    logger.info(`  Preserve: ${userCount} user-created files`);
    if (userCount > 0) {
      const samples = analysis.userFiles.slice(0, 3).map((f3) => f3.path);
      const remaining = userCount - samples.length;
      logger.info(`  Examples preserved: ${samples.join(", ")}${remaining > 0 ? ` (+${remaining} more)` : ""}`);
    }
  } else {
    logger.info("  Remove: commands/, agents/, skills/, rules/, hooks/");
    logger.info("  Preserve: settings.json, Claude Code data");
  }
  const confirmation = await te({
    message: "Type 'yes' to confirm:",
    placeholder: "yes",
    validate: (value) => {
      if (value.toLowerCase() !== "yes") {
        return "You must type 'yes' to confirm";
      }
      return;
    }
  });
  if (lD(confirmation)) {
    return false;
  }
  return confirmation.toLowerCase() === "yes";
}
// src/domains/ui/prompts/confirmation-prompts.ts
init_output_manager();
import { platform as platform5 } from "node:os";

// src/types/skills-dependencies.ts
var SKILLS_DEPENDENCIES = {
  python: [
    { name: "google-genai", description: "Required for ai-multimodal skill (Gemini API)" },
    { name: "pillow, pypdf", description: "Image/PDF processing" },
    { name: "python-dotenv", description: "Environment variable management" }
  ],
  system: [
    { name: "ffmpeg", description: "Audio/video processing" },
    { name: "imagemagick", description: "Image manipulation" }
  ],
  node: [{ name: "repomix, pnpm", description: "Development utilities" }]
};
function formatDependencyList(deps) {
  return deps.map((d3) => `    - ${d3.name.padEnd(16)} ${d3.description}`).join(`
`);
}
function getVenvPath(isWindows2) {
  return isWindows2 ? "%USERPROFILE%\\.claude\\skills\\.venv\\" : "~/.claude/skills/.venv/";
}
function getInstallCommand(isWindows2) {
  return isWindows2 ? "powershell %USERPROFILE%\\.claude\\skills\\install.ps1" : "bash ~/.claude/skills/install.sh";
}

// src/domains/ui/prompts/confirmation-prompts.ts
async function confirmAction(message) {
  const result = await se({
    message
  });
  if (lD(result)) {
    return false;
  }
  return result;
}
async function promptLocalMigration() {
  const result = await ie({
    message: "Local ClaudeKit installation detected. Local settings take precedence over global.",
    options: [
      {
        value: "remove",
        label: "Remove local installation",
        hint: "Delete .claude/ and use global only"
      },
      {
        value: "keep",
        label: "Keep both installations",
        hint: "Local will take precedence"
      },
      { value: "cancel", label: "Cancel", hint: "Abort global installation" }
    ]
  });
  if (lD(result)) {
    return "cancel";
  }
  return result;
}
async function promptSkillsInstallation() {
  if (output.isJson()) {
    return false;
  }
  const isWindows2 = platform5() === "win32";
  const pythonDeps = formatDependencyList(SKILLS_DEPENDENCIES.python);
  const systemDeps = formatDependencyList(SKILLS_DEPENDENCIES.system);
  const nodeDeps = formatDependencyList(SKILLS_DEPENDENCIES.node);
  note(`This installs dependencies required by ClaudeKit skills:

  Python packages (into ${getVenvPath(isWindows2)}):
${pythonDeps}

  System tools (optional${isWindows2 ? "" : " - may require sudo"}):
${systemDeps}

  Node.js packages:
${nodeDeps}`, "Skills Dependencies");
  log.info(`Run '${getInstallCommand(isWindows2)}' to install/update later.`);
  console.log();
  const installSkills = await se({
    message: "Install skills dependencies now?",
    initialValue: false
  });
  if (lD(installSkills)) {
    return false;
  }
  return installSkills;
}
// src/domains/ui/prompts.ts
class PromptsManager {
  async selectKit(defaultKit, accessibleKits) {
    return selectKit(defaultKit, accessibleKits);
  }
  async selectKits(accessibleKits) {
    return selectKits(accessibleKits);
  }
  async selectVersion(versions, defaultVersion) {
    return selectVersion(versions, defaultVersion);
  }
  async selectVersionEnhanced(options) {
    return selectVersionEnhanced(options);
  }
  async getLatestVersion(kit, includePrereleases = false) {
    return getLatestVersion(kit, includePrereleases);
  }
  async getDirectory(defaultDir = ".") {
    return getDirectory(defaultDir);
  }
  async confirm(message) {
    return confirmAction(message);
  }
  intro(message) {
    intro(message);
  }
  outro(message) {
    outro(message);
  }
  note(message, title) {
    note(message, title);
  }
  async text(message, placeholder) {
    const result = await te({
      message,
      placeholder
    });
    if (lD(result)) {
      return;
    }
    return result;
  }
  async promptPackageInstallations() {
    log.step("Optional Package Installations");
    const [openCodeInstalled, geminiInstalled] = await Promise.all([
      isOpenCodeInstalled(),
      isGeminiInstalled()
    ]);
    let installOpenCode2 = false;
    let installGemini2 = false;
    if (openCodeInstalled) {
      logger.success("OpenCode CLI is already installed");
    } else {
      const shouldInstallOpenCode = await se({
        message: "Install OpenCode CLI for enhanced code analysis? (Recommended for better code understanding and generation)"
      });
      if (lD(shouldInstallOpenCode)) {
        throw new Error("Package installation cancelled");
      }
      installOpenCode2 = shouldInstallOpenCode;
    }
    if (geminiInstalled) {
      logger.success("Google Gemini CLI is already installed");
    } else {
      const shouldInstallGemini = await se({
        message: "Install Google Gemini CLI for AI-powered assistance? (Optional additional AI capabilities)"
      });
      if (lD(shouldInstallGemini)) {
        throw new Error("Package installation cancelled");
      }
      installGemini2 = shouldInstallGemini;
    }
    return {
      installOpenCode: installOpenCode2,
      installGemini: installGemini2
    };
  }
  async promptSkillsInstallation() {
    return promptSkillsInstallation();
  }
  showPackageInstallationResults(results) {
    const successfulInstalls = [];
    const failedInstalls = [];
    if (results.opencode) {
      if (results.opencode.success) {
        successfulInstalls.push(`${results.opencode.package}${results.opencode.version ? ` v${results.opencode.version}` : ""}`);
      } else {
        failedInstalls.push(`${results.opencode.package}: ${results.opencode.error || "Installation failed"}`);
      }
    }
    if (results.gemini) {
      if (results.gemini.success) {
        successfulInstalls.push(`${results.gemini.package}${results.gemini.version ? ` v${results.gemini.version}` : ""}`);
      } else {
        failedInstalls.push(`${results.gemini.package}: ${results.gemini.error || "Installation failed"}`);
      }
    }
    if (successfulInstalls.length > 0) {
      logger.success(`Installed: ${successfulInstalls.join(", ")}`);
    }
    if (failedInstalls.length > 0) {
      logger.warning(`Failed to install: ${failedInstalls.join(", ")}`);
      logger.info("You can install these manually later using npm install -g <package>");
    }
  }
  async promptFreshConfirmation(targetPath, analysis) {
    return promptFreshConfirmation(targetPath, analysis);
  }
  async promptUpdateMode() {
    return promptUpdateMode();
  }
  async promptLocalMigration() {
    return promptLocalMigration();
  }
  async promptDirectorySelection(global2 = false) {
    return promptDirectorySelection(global2);
  }
  async selectScope() {
    const options = [
      {
        value: "global",
        label: "Install globally",
        hint: "Continue installing to ~/.claude/"
      },
      {
        value: "different",
        label: "Use a different directory",
        hint: "Cancel and run from a project directory"
      }
    ];
    const selected = await ie({
      message: "What would you like to do?",
      options
    });
    if (lD(selected)) {
      return "cancel";
    }
    return selected;
  }
}

// src/commands/init/init-command.ts
init_logger();

// src/shared/process-lock.ts
var import_proper_lockfile = __toESM(require_proper_lockfile(), 1);
import { mkdir as mkdir8 } from "node:fs/promises";
import os2 from "node:os";
import { join as join29 } from "node:path";
var LOCK_CONFIG = {
  stale: 300000,
  retries: 0
};
function getLocksDir() {
  return join29(os2.homedir(), ".claudekit", "locks");
}
async function ensureLocksDir() {
  const lockDir = getLocksDir();
  await mkdir8(lockDir, { recursive: true });
}
async function withProcessLock(lockName, fn) {
  await ensureLocksDir();
  const lockPath = join29(getLocksDir(), `${lockName}.lock`);
  let release;
  try {
    release = await import_proper_lockfile.default.lock(lockPath, { ...LOCK_CONFIG, realpath: false });
    return await fn();
  } catch (e2) {
    const error = e2;
    if (error.code === "ELOCKED") {
      throw new Error(`Another ClaudeKit process is running.

Operation: ${lockName}
Wait for it to complete or remove lock: ${lockPath}`);
    }
    throw e2;
  } finally {
    if (release) {
      await release();
    }
  }
}

// src/commands/init/init-command.ts
init_types2();
// src/commands/init/phases/api-key-handler.ts
init_logger();
// src/commands/init/phases/conflict-handler.ts
init_logger();
init_path_resolver();
var import_fs_extra5 = __toESM(require_lib(), 1);
import { join as join30 } from "node:path";
async function handleConflicts(ctx) {
  if (ctx.cancelled)
    return ctx;
  if (!ctx.options.global)
    return ctx;
  if (PathResolver.isLocalSameAsGlobal()) {
    return ctx;
  }
  const localSettingsPath = join30(process.cwd(), ".claude", "settings.json");
  if (!await import_fs_extra5.pathExists(localSettingsPath)) {
    return ctx;
  }
  if (ctx.isNonInteractive) {
    logger.warning("Local .claude/settings.json detected. Local settings take precedence over global.");
    logger.warning("Consider removing local installation: rm -rf .claude");
    return ctx;
  }
  const choice = await ctx.prompts.promptLocalMigration();
  if (choice === "cancel") {
    ctx.prompts.outro("Installation cancelled.");
    return { ...ctx, cancelled: true };
  }
  if (choice === "remove") {
    const localClaudeDir = join30(process.cwd(), ".claude");
    try {
      await import_fs_extra5.remove(localClaudeDir);
      logger.success("Removed local .claude/ directory");
    } catch (error) {
      logger.error(`Failed to remove local installation: ${error instanceof Error ? error.message : "Unknown error"}`);
      logger.warning("Proceeding with global installation anyway.");
    }
  }
  if (choice === "keep") {
    logger.warning("Proceeding with global installation. Local settings will take precedence.");
  }
  return ctx;
}
// src/domains/installation/download-extractor.ts
import * as fs13 from "node:fs";
import * as path9 from "node:path";

// src/domains/github/auth-prompt.ts
init_dist2();
var import_picocolors14 = __toESM(require_picocolors(), 1);
init_github_auth();
async function promptForAuth() {
  const hasGit = GitCloneManager.isGitInstalled();
  const hasSshKeys = hasGit && GitCloneManager.hasSshKeys();
  const hasGhCli = AuthManager.isGhCliInstalled();
  oe(import_picocolors14.default.yellow("No GitHub authentication found"));
  const options = [];
  if (hasGit) {
    const hint = hasSshKeys ? "SSH keys detected" : "Will use HTTPS";
    options.push({
      value: "git",
      label: "Use git clone (--use-git)",
      hint: `${hint} - recommended for security`
    });
  }
  options.push({
    value: "token",
    label: "Enter GitHub token (GITHUB_TOKEN)",
    hint: "Classic PAT with 'repo' scope"
  });
  if (hasGhCli) {
    options.push({
      value: "gh-cli",
      label: "Use GitHub CLI (gh auth login)",
      hint: "Run 'gh auth login' first"
    });
  } else {
    options.push({
      value: "gh-cli",
      label: "Install GitHub CLI",
      hint: "brew install gh / winget install GitHub.cli"
    });
  }
  const selection = await ie({
    message: "Choose authentication method:",
    options
  });
  if (lD(selection)) {
    return { method: "cancel" };
  }
  if (selection === "token") {
    const token = await te({
      message: "Enter your GitHub Personal Access Token:",
      placeholder: "ghp_xxxxxxxxxxxxxxxxxxxx",
      validate: (value) => {
        if (!value || value.trim().length < 10) {
          return "Token is too short";
        }
        if (!value.startsWith("ghp_") && !value.startsWith("github_pat_")) {
          return "Token should start with 'ghp_' (Classic) or 'github_pat_' (Fine-grained)";
        }
        return;
      }
    });
    if (lD(token)) {
      return { method: "cancel" };
    }
    if (typeof token === "string" && token.startsWith("github_pat_")) {
      le(import_picocolors14.default.yellow(`  Fine-grained PATs cannot access repos where you're a collaborator.
` + "   If you encounter access issues, use a Classic PAT instead."));
    }
    return { method: "token", token };
  }
  return { method: selection };
}

// src/domains/installation/download-extractor.ts
init_github_auth();
init_github_client();

// src/domains/installation/download-manager.ts
init_environment();
init_logger();
import { mkdir as mkdir14, stat as stat5 } from "node:fs/promises";
import { tmpdir as tmpdir3 } from "node:os";
import { join as join37 } from "node:path";

// node_modules/ora/index.js
import process9 from "node:process";

// node_modules/chalk/source/vendor/ansi-styles/index.js
var ANSI_BACKGROUND_OFFSET = 10;
var wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
var styles = {
  modifier: {
    reset: [0, 0],
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    blackBright: [90, 39],
    gray: [90, 39],
    grey: [90, 39],
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    bgGrey: [100, 49],
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
var modifierNames = Object.keys(styles.modifier);
var foregroundColorNames = Object.keys(styles.color);
var backgroundColorNames = Object.keys(styles.bgColor);
var colorNames = [...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
  const codes = new Map;
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, "codes", {
    value: codes,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles;
}
var ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;

// node_modules/chalk/source/vendor/supports-color/index.js
import process2 from "node:process";
import os3 from "node:os";
import tty from "node:tty";
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : process2.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
var { env } = process2;
var flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
  flagForceColor = 0;
} else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
  flagForceColor = 1;
}
function envForceColor() {
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      return 1;
    }
    if (env.FORCE_COLOR === "false") {
      return 0;
    }
    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
  }
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== undefined) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
  }
  if ("TF_BUILD" in env && "AGENT_NAME" in env) {
    return 1;
  }
  if (haveStream && !streamIsTTY && forceColor === undefined) {
    return 0;
  }
  const min = forceColor || 0;
  if (env.TERM === "dumb") {
    return min;
  }
  if (process2.platform === "win32") {
    const osRelease = os3.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env) {
    if (["GITHUB_ACTIONS", "GITEA_ACTIONS", "CIRCLECI"].some((key) => (key in env))) {
      return 3;
    }
    if (["TRAVIS", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => (sign in env)) || env.CI_NAME === "codeship") {
      return 1;
    }
    return min;
  }
  if ("TEAMCITY_VERSION" in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env.COLORTERM === "truecolor") {
    return 3;
  }
  if (env.TERM === "xterm-kitty") {
    return 3;
  }
  if (env.TERM === "xterm-ghostty") {
    return 3;
  }
  if (env.TERM === "wezterm") {
    return 3;
  }
  if ("TERM_PROGRAM" in env) {
    const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app": {
        return version >= 3 ? 3 : 2;
      }
      case "Apple_Terminal": {
        return 2;
      }
    }
  }
  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env) {
    return 1;
  }
  return min;
}
function createSupportsColor(stream, options = {}) {
  const level = _supportsColor(stream, {
    streamIsTTY: stream && stream.isTTY,
    ...options
  });
  return translateLevel(level);
}
var supportsColor = {
  stdout: createSupportsColor({ isTTY: tty.isatty(1) }),
  stderr: createSupportsColor({ isTTY: tty.isatty(2) })
};
var supports_color_default = supportsColor;

// node_modules/chalk/source/utilities.js
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string.slice(endIndex, index) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? `\r
` : `
`) + postfix;
    endIndex = index + 1;
    index = string.indexOf(`
`, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}

// node_modules/chalk/source/index.js
var { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;
var GENERATOR = Symbol("GENERATOR");
var STYLER = Symbol("STYLER");
var IS_EMPTY = Symbol("IS_EMPTY");
var levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
var styles2 = Object.create(null);
var applyOptions = (object, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === undefined ? colorLevel : options.level;
};
var chalkFactory = (options) => {
  const chalk = (...strings) => strings.join(" ");
  applyOptions(chalk, options);
  Object.setPrototypeOf(chalk, createChalk.prototype);
  return chalk;
};
function createChalk(options) {
  return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default)) {
  styles2[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    }
  };
}
styles2.visible = {
  get() {
    const builder = createBuilder(this, this[STYLER], true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  }
};
var getModelAnsi = (model, level, type, ...arguments_) => {
  if (model === "rgb") {
    if (level === "ansi16m") {
      return ansi_styles_default[type].ansi16m(...arguments_);
    }
    if (level === "ansi256") {
      return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
    }
    return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
  }
  if (model === "hex") {
    return getModelAnsi("rgb", level, type, ...ansi_styles_default.hexToRgb(...arguments_));
  }
  return ansi_styles_default[type][model](...arguments_);
};
var usedModels = ["rgb", "hex", "ansi256"];
for (const model of usedModels) {
  styles2[model] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles2[bgModel] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
}
var proto = Object.defineProperties(() => {}, {
  ...styles2,
  level: {
    enumerable: true,
    get() {
      return this[GENERATOR].level;
    },
    set(level) {
      this[GENERATOR].level = level;
    }
  }
});
var createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === undefined) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
};
var createBuilder = (self2, _styler, _isEmpty) => {
  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self2;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
};
var applyStyle = (self2, string) => {
  if (self2.level <= 0 || !string) {
    return self2[IS_EMPTY] ? "" : string;
  }
  let styler = self2[STYLER];
  if (styler === undefined) {
    return string;
  }
  const { openAll, closeAll } = styler;
  if (string.includes("\x1B")) {
    while (styler !== undefined) {
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf(`
`);
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles2);
var chalk = createChalk();
var chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;

// node_modules/cli-cursor/index.js
import process5 from "node:process";

// node_modules/restore-cursor/index.js
import process4 from "node:process";

// node_modules/mimic-function/index.js
var copyProperty = (to, from, property, ignoreNonConfigurable) => {
  if (property === "length" || property === "prototype") {
    return;
  }
  if (property === "arguments" || property === "caller") {
    return;
  }
  const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
  const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
    return;
  }
  Object.defineProperty(to, property, fromDescriptor);
};
var canCopyProperty = function(toDescriptor, fromDescriptor) {
  return toDescriptor === undefined || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
};
var changePrototype = (to, from) => {
  const fromPrototype = Object.getPrototypeOf(from);
  if (fromPrototype === Object.getPrototypeOf(to)) {
    return;
  }
  Object.setPrototypeOf(to, fromPrototype);
};
var wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
var toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
var toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
var changeToString = (to, from, name) => {
  const withName = name === "" ? "" : `with ${name.trim()}() `;
  const newToString = wrappedToString.bind(null, withName, from.toString());
  Object.defineProperty(newToString, "name", toStringName);
  const { writable, enumerable, configurable } = toStringDescriptor;
  Object.defineProperty(to, "toString", { value: newToString, writable, enumerable, configurable });
};
function mimicFunction(to, from, { ignoreNonConfigurable = false } = {}) {
  const { name } = to;
  for (const property of Reflect.ownKeys(from)) {
    copyProperty(to, from, property, ignoreNonConfigurable);
  }
  changePrototype(to, from);
  changeToString(to, from, name);
  return to;
}

// node_modules/restore-cursor/node_modules/onetime/index.js
var calledFunctions = new WeakMap;
var onetime = (function_, options = {}) => {
  if (typeof function_ !== "function") {
    throw new TypeError("Expected a function");
  }
  let returnValue;
  let callCount = 0;
  const functionName = function_.displayName || function_.name || "<anonymous>";
  const onetime2 = function(...arguments_) {
    calledFunctions.set(onetime2, ++callCount);
    if (callCount === 1) {
      returnValue = function_.apply(this, arguments_);
      function_ = undefined;
    } else if (options.throw === true) {
      throw new Error(`Function \`${functionName}\` can only be called once`);
    }
    return returnValue;
  };
  mimicFunction(onetime2, function_);
  calledFunctions.set(onetime2, callCount);
  return onetime2;
};
onetime.callCount = (function_) => {
  if (!calledFunctions.has(function_)) {
    throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
  }
  return calledFunctions.get(function_);
};
var onetime_default = onetime;

// node_modules/restore-cursor/node_modules/signal-exit/dist/mjs/signals.js
var signals = [];
signals.push("SIGHUP", "SIGINT", "SIGTERM");
if (process.platform !== "win32") {
  signals.push("SIGALRM", "SIGABRT", "SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
}
if (process.platform === "linux") {
  signals.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT");
}

// node_modules/restore-cursor/node_modules/signal-exit/dist/mjs/index.js
var processOk = (process3) => !!process3 && typeof process3 === "object" && typeof process3.removeListener === "function" && typeof process3.emit === "function" && typeof process3.reallyExit === "function" && typeof process3.listeners === "function" && typeof process3.kill === "function" && typeof process3.pid === "number" && typeof process3.on === "function";
var kExitEmitter = Symbol.for("signal-exit emitter");
var global2 = globalThis;
var ObjectDefineProperty = Object.defineProperty.bind(Object);

class Emitter {
  emitted = {
    afterExit: false,
    exit: false
  };
  listeners = {
    afterExit: [],
    exit: []
  };
  count = 0;
  id = Math.random();
  constructor() {
    if (global2[kExitEmitter]) {
      return global2[kExitEmitter];
    }
    ObjectDefineProperty(global2, kExitEmitter, {
      value: this,
      writable: false,
      enumerable: false,
      configurable: false
    });
  }
  on(ev, fn) {
    this.listeners[ev].push(fn);
  }
  removeListener(ev, fn) {
    const list = this.listeners[ev];
    const i = list.indexOf(fn);
    if (i === -1) {
      return;
    }
    if (i === 0 && list.length === 1) {
      list.length = 0;
    } else {
      list.splice(i, 1);
    }
  }
  emit(ev, code, signal) {
    if (this.emitted[ev]) {
      return false;
    }
    this.emitted[ev] = true;
    let ret = false;
    for (const fn of this.listeners[ev]) {
      ret = fn(code, signal) === true || ret;
    }
    if (ev === "exit") {
      ret = this.emit("afterExit", code, signal) || ret;
    }
    return ret;
  }
}

class SignalExitBase {
}
var signalExitWrap = (handler) => {
  return {
    onExit(cb, opts) {
      return handler.onExit(cb, opts);
    },
    load() {
      return handler.load();
    },
    unload() {
      return handler.unload();
    }
  };
};

class SignalExitFallback extends SignalExitBase {
  onExit() {
    return () => {};
  }
  load() {}
  unload() {}
}

class SignalExit extends SignalExitBase {
  #hupSig = process3.platform === "win32" ? "SIGINT" : "SIGHUP";
  #emitter = new Emitter;
  #process;
  #originalProcessEmit;
  #originalProcessReallyExit;
  #sigListeners = {};
  #loaded = false;
  constructor(process3) {
    super();
    this.#process = process3;
    this.#sigListeners = {};
    for (const sig of signals) {
      this.#sigListeners[sig] = () => {
        const listeners = this.#process.listeners(sig);
        let { count } = this.#emitter;
        const p = process3;
        if (typeof p.__signal_exit_emitter__ === "object" && typeof p.__signal_exit_emitter__.count === "number") {
          count += p.__signal_exit_emitter__.count;
        }
        if (listeners.length === count) {
          this.unload();
          const ret = this.#emitter.emit("exit", null, sig);
          const s = sig === "SIGHUP" ? this.#hupSig : sig;
          if (!ret)
            process3.kill(process3.pid, s);
        }
      };
    }
    this.#originalProcessReallyExit = process3.reallyExit;
    this.#originalProcessEmit = process3.emit;
  }
  onExit(cb, opts) {
    if (!processOk(this.#process)) {
      return () => {};
    }
    if (this.#loaded === false) {
      this.load();
    }
    const ev = opts?.alwaysLast ? "afterExit" : "exit";
    this.#emitter.on(ev, cb);
    return () => {
      this.#emitter.removeListener(ev, cb);
      if (this.#emitter.listeners["exit"].length === 0 && this.#emitter.listeners["afterExit"].length === 0) {
        this.unload();
      }
    };
  }
  load() {
    if (this.#loaded) {
      return;
    }
    this.#loaded = true;
    this.#emitter.count += 1;
    for (const sig of signals) {
      try {
        const fn = this.#sigListeners[sig];
        if (fn)
          this.#process.on(sig, fn);
      } catch (_3) {}
    }
    this.#process.emit = (ev, ...a3) => {
      return this.#processEmit(ev, ...a3);
    };
    this.#process.reallyExit = (code) => {
      return this.#processReallyExit(code);
    };
  }
  unload() {
    if (!this.#loaded) {
      return;
    }
    this.#loaded = false;
    signals.forEach((sig) => {
      const listener = this.#sigListeners[sig];
      if (!listener) {
        throw new Error("Listener not defined for signal: " + sig);
      }
      try {
        this.#process.removeListener(sig, listener);
      } catch (_3) {}
    });
    this.#process.emit = this.#originalProcessEmit;
    this.#process.reallyExit = this.#originalProcessReallyExit;
    this.#emitter.count -= 1;
  }
  #processReallyExit(code) {
    if (!processOk(this.#process)) {
      return 0;
    }
    this.#process.exitCode = code || 0;
    this.#emitter.emit("exit", this.#process.exitCode, null);
    return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);
  }
  #processEmit(ev, ...args) {
    const og = this.#originalProcessEmit;
    if (ev === "exit" && processOk(this.#process)) {
      if (typeof args[0] === "number") {
        this.#process.exitCode = args[0];
      }
      const ret = og.call(this.#process, ev, ...args);
      this.#emitter.emit("exit", this.#process.exitCode, null);
      return ret;
    } else {
      return og.call(this.#process, ev, ...args);
    }
  }
}
var process3 = globalThis.process;
var {
  onExit,
  load,
  unload
} = signalExitWrap(processOk(process3) ? new SignalExit(process3) : new SignalExitFallback);

// node_modules/restore-cursor/index.js
var terminal = process4.stderr.isTTY ? process4.stderr : process4.stdout.isTTY ? process4.stdout : undefined;
var restoreCursor = terminal ? onetime_default(() => {
  onExit(() => {
    terminal.write("\x1B[?25h");
  }, { alwaysLast: true });
}) : () => {};
var restore_cursor_default = restoreCursor;

// node_modules/cli-cursor/index.js
var isHidden = false;
var cliCursor = {};
cliCursor.show = (writableStream = process5.stderr) => {
  if (!writableStream.isTTY) {
    return;
  }
  isHidden = false;
  writableStream.write("\x1B[?25h");
};
cliCursor.hide = (writableStream = process5.stderr) => {
  if (!writableStream.isTTY) {
    return;
  }
  restore_cursor_default();
  isHidden = true;
  writableStream.write("\x1B[?25l");
};
cliCursor.toggle = (force, writableStream) => {
  if (force !== undefined) {
    isHidden = force;
  }
  if (isHidden) {
    cliCursor.show(writableStream);
  } else {
    cliCursor.hide(writableStream);
  }
};
var cli_cursor_default = cliCursor;

// node_modules/ora/index.js
var import_cli_spinners = __toESM(require_cli_spinners(), 1);

// node_modules/log-symbols/node_modules/is-unicode-supported/index.js
import process6 from "node:process";
function isUnicodeSupported() {
  if (process6.platform !== "win32") {
    return process6.env.TERM !== "linux";
  }
  return Boolean(process6.env.CI) || Boolean(process6.env.WT_SESSION) || Boolean(process6.env.TERMINUS_SUBLIME) || process6.env.ConEmuTask === "{cmd::Cmder}" || process6.env.TERM_PROGRAM === "Terminus-Sublime" || process6.env.TERM_PROGRAM === "vscode" || process6.env.TERM === "xterm-256color" || process6.env.TERM === "alacritty" || process6.env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}

// node_modules/log-symbols/index.js
var main = {
  info: source_default.blue(""),
  success: source_default.green(""),
  warning: source_default.yellow(""),
  error: source_default.red("")
};
var fallback = {
  info: source_default.blue("i"),
  success: source_default.green(""),
  warning: source_default.yellow(""),
  error: source_default.red("")
};
var logSymbols = isUnicodeSupported() ? main : fallback;
var log_symbols_default = logSymbols;

// node_modules/ansi-regex/index.js
function ansiRegex({ onlyFirst = false } = {}) {
  const ST = "(?:\\u0007|\\u001B\\u005C|\\u009C)";
  const osc = `(?:\\u001B\\][\\s\\S]*?${ST})`;
  const csi = "[\\u001B\\u009B][[\\]()#;?]*(?:\\d{1,4}(?:[;:]\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]";
  const pattern = `${osc}|${csi}`;
  return new RegExp(pattern, onlyFirst ? undefined : "g");
}

// node_modules/strip-ansi/index.js
var regex = ansiRegex();
function stripAnsi(string) {
  if (typeof string !== "string") {
    throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
  }
  return string.replace(regex, "");
}

// node_modules/get-east-asian-width/lookup.js
function isAmbiguous(x3) {
  return x3 === 161 || x3 === 164 || x3 === 167 || x3 === 168 || x3 === 170 || x3 === 173 || x3 === 174 || x3 >= 176 && x3 <= 180 || x3 >= 182 && x3 <= 186 || x3 >= 188 && x3 <= 191 || x3 === 198 || x3 === 208 || x3 === 215 || x3 === 216 || x3 >= 222 && x3 <= 225 || x3 === 230 || x3 >= 232 && x3 <= 234 || x3 === 236 || x3 === 237 || x3 === 240 || x3 === 242 || x3 === 243 || x3 >= 247 && x3 <= 250 || x3 === 252 || x3 === 254 || x3 === 257 || x3 === 273 || x3 === 275 || x3 === 283 || x3 === 294 || x3 === 295 || x3 === 299 || x3 >= 305 && x3 <= 307 || x3 === 312 || x3 >= 319 && x3 <= 322 || x3 === 324 || x3 >= 328 && x3 <= 331 || x3 === 333 || x3 === 338 || x3 === 339 || x3 === 358 || x3 === 359 || x3 === 363 || x3 === 462 || x3 === 464 || x3 === 466 || x3 === 468 || x3 === 470 || x3 === 472 || x3 === 474 || x3 === 476 || x3 === 593 || x3 === 609 || x3 === 708 || x3 === 711 || x3 >= 713 && x3 <= 715 || x3 === 717 || x3 === 720 || x3 >= 728 && x3 <= 731 || x3 === 733 || x3 === 735 || x3 >= 768 && x3 <= 879 || x3 >= 913 && x3 <= 929 || x3 >= 931 && x3 <= 937 || x3 >= 945 && x3 <= 961 || x3 >= 963 && x3 <= 969 || x3 === 1025 || x3 >= 1040 && x3 <= 1103 || x3 === 1105 || x3 === 8208 || x3 >= 8211 && x3 <= 8214 || x3 === 8216 || x3 === 8217 || x3 === 8220 || x3 === 8221 || x3 >= 8224 && x3 <= 8226 || x3 >= 8228 && x3 <= 8231 || x3 === 8240 || x3 === 8242 || x3 === 8243 || x3 === 8245 || x3 === 8251 || x3 === 8254 || x3 === 8308 || x3 === 8319 || x3 >= 8321 && x3 <= 8324 || x3 === 8364 || x3 === 8451 || x3 === 8453 || x3 === 8457 || x3 === 8467 || x3 === 8470 || x3 === 8481 || x3 === 8482 || x3 === 8486 || x3 === 8491 || x3 === 8531 || x3 === 8532 || x3 >= 8539 && x3 <= 8542 || x3 >= 8544 && x3 <= 8555 || x3 >= 8560 && x3 <= 8569 || x3 === 8585 || x3 >= 8592 && x3 <= 8601 || x3 === 8632 || x3 === 8633 || x3 === 8658 || x3 === 8660 || x3 === 8679 || x3 === 8704 || x3 === 8706 || x3 === 8707 || x3 === 8711 || x3 === 8712 || x3 === 8715 || x3 === 8719 || x3 === 8721 || x3 === 8725 || x3 === 8730 || x3 >= 8733 && x3 <= 8736 || x3 === 8739 || x3 === 8741 || x3 >= 8743 && x3 <= 8748 || x3 === 8750 || x3 >= 8756 && x3 <= 8759 || x3 === 8764 || x3 === 8765 || x3 === 8776 || x3 === 8780 || x3 === 8786 || x3 === 8800 || x3 === 8801 || x3 >= 8804 && x3 <= 8807 || x3 === 8810 || x3 === 8811 || x3 === 8814 || x3 === 8815 || x3 === 8834 || x3 === 8835 || x3 === 8838 || x3 === 8839 || x3 === 8853 || x3 === 8857 || x3 === 8869 || x3 === 8895 || x3 === 8978 || x3 >= 9312 && x3 <= 9449 || x3 >= 9451 && x3 <= 9547 || x3 >= 9552 && x3 <= 9587 || x3 >= 9600 && x3 <= 9615 || x3 >= 9618 && x3 <= 9621 || x3 === 9632 || x3 === 9633 || x3 >= 9635 && x3 <= 9641 || x3 === 9650 || x3 === 9651 || x3 === 9654 || x3 === 9655 || x3 === 9660 || x3 === 9661 || x3 === 9664 || x3 === 9665 || x3 >= 9670 && x3 <= 9672 || x3 === 9675 || x3 >= 9678 && x3 <= 9681 || x3 >= 9698 && x3 <= 9701 || x3 === 9711 || x3 === 9733 || x3 === 9734 || x3 === 9737 || x3 === 9742 || x3 === 9743 || x3 === 9756 || x3 === 9758 || x3 === 9792 || x3 === 9794 || x3 === 9824 || x3 === 9825 || x3 >= 9827 && x3 <= 9829 || x3 >= 9831 && x3 <= 9834 || x3 === 9836 || x3 === 9837 || x3 === 9839 || x3 === 9886 || x3 === 9887 || x3 === 9919 || x3 >= 9926 && x3 <= 9933 || x3 >= 9935 && x3 <= 9939 || x3 >= 9941 && x3 <= 9953 || x3 === 9955 || x3 === 9960 || x3 === 9961 || x3 >= 9963 && x3 <= 9969 || x3 === 9972 || x3 >= 9974 && x3 <= 9977 || x3 === 9979 || x3 === 9980 || x3 === 9982 || x3 === 9983 || x3 === 10045 || x3 >= 10102 && x3 <= 10111 || x3 >= 11094 && x3 <= 11097 || x3 >= 12872 && x3 <= 12879 || x3 >= 57344 && x3 <= 63743 || x3 >= 65024 && x3 <= 65039 || x3 === 65533 || x3 >= 127232 && x3 <= 127242 || x3 >= 127248 && x3 <= 127277 || x3 >= 127280 && x3 <= 127337 || x3 >= 127344 && x3 <= 127373 || x3 === 127375 || x3 === 127376 || x3 >= 127387 && x3 <= 127404 || x3 >= 917760 && x3 <= 917999 || x3 >= 983040 && x3 <= 1048573 || x3 >= 1048576 && x3 <= 1114109;
}
function isFullWidth(x3) {
  return x3 === 12288 || x3 >= 65281 && x3 <= 65376 || x3 >= 65504 && x3 <= 65510;
}
function isWide(x3) {
  return x3 >= 4352 && x3 <= 4447 || x3 === 8986 || x3 === 8987 || x3 === 9001 || x3 === 9002 || x3 >= 9193 && x3 <= 9196 || x3 === 9200 || x3 === 9203 || x3 === 9725 || x3 === 9726 || x3 === 9748 || x3 === 9749 || x3 >= 9776 && x3 <= 9783 || x3 >= 9800 && x3 <= 9811 || x3 === 9855 || x3 >= 9866 && x3 <= 9871 || x3 === 9875 || x3 === 9889 || x3 === 9898 || x3 === 9899 || x3 === 9917 || x3 === 9918 || x3 === 9924 || x3 === 9925 || x3 === 9934 || x3 === 9940 || x3 === 9962 || x3 === 9970 || x3 === 9971 || x3 === 9973 || x3 === 9978 || x3 === 9981 || x3 === 9989 || x3 === 9994 || x3 === 9995 || x3 === 10024 || x3 === 10060 || x3 === 10062 || x3 >= 10067 && x3 <= 10069 || x3 === 10071 || x3 >= 10133 && x3 <= 10135 || x3 === 10160 || x3 === 10175 || x3 === 11035 || x3 === 11036 || x3 === 11088 || x3 === 11093 || x3 >= 11904 && x3 <= 11929 || x3 >= 11931 && x3 <= 12019 || x3 >= 12032 && x3 <= 12245 || x3 >= 12272 && x3 <= 12287 || x3 >= 12289 && x3 <= 12350 || x3 >= 12353 && x3 <= 12438 || x3 >= 12441 && x3 <= 12543 || x3 >= 12549 && x3 <= 12591 || x3 >= 12593 && x3 <= 12686 || x3 >= 12688 && x3 <= 12773 || x3 >= 12783 && x3 <= 12830 || x3 >= 12832 && x3 <= 12871 || x3 >= 12880 && x3 <= 42124 || x3 >= 42128 && x3 <= 42182 || x3 >= 43360 && x3 <= 43388 || x3 >= 44032 && x3 <= 55203 || x3 >= 63744 && x3 <= 64255 || x3 >= 65040 && x3 <= 65049 || x3 >= 65072 && x3 <= 65106 || x3 >= 65108 && x3 <= 65126 || x3 >= 65128 && x3 <= 65131 || x3 >= 94176 && x3 <= 94180 || x3 >= 94192 && x3 <= 94198 || x3 >= 94208 && x3 <= 101589 || x3 >= 101631 && x3 <= 101662 || x3 >= 101760 && x3 <= 101874 || x3 >= 110576 && x3 <= 110579 || x3 >= 110581 && x3 <= 110587 || x3 === 110589 || x3 === 110590 || x3 >= 110592 && x3 <= 110882 || x3 === 110898 || x3 >= 110928 && x3 <= 110930 || x3 === 110933 || x3 >= 110948 && x3 <= 110951 || x3 >= 110960 && x3 <= 111355 || x3 >= 119552 && x3 <= 119638 || x3 >= 119648 && x3 <= 119670 || x3 === 126980 || x3 === 127183 || x3 === 127374 || x3 >= 127377 && x3 <= 127386 || x3 >= 127488 && x3 <= 127490 || x3 >= 127504 && x3 <= 127547 || x3 >= 127552 && x3 <= 127560 || x3 === 127568 || x3 === 127569 || x3 >= 127584 && x3 <= 127589 || x3 >= 127744 && x3 <= 127776 || x3 >= 127789 && x3 <= 127797 || x3 >= 127799 && x3 <= 127868 || x3 >= 127870 && x3 <= 127891 || x3 >= 127904 && x3 <= 127946 || x3 >= 127951 && x3 <= 127955 || x3 >= 127968 && x3 <= 127984 || x3 === 127988 || x3 >= 127992 && x3 <= 128062 || x3 === 128064 || x3 >= 128066 && x3 <= 128252 || x3 >= 128255 && x3 <= 128317 || x3 >= 128331 && x3 <= 128334 || x3 >= 128336 && x3 <= 128359 || x3 === 128378 || x3 === 128405 || x3 === 128406 || x3 === 128420 || x3 >= 128507 && x3 <= 128591 || x3 >= 128640 && x3 <= 128709 || x3 === 128716 || x3 >= 128720 && x3 <= 128722 || x3 >= 128725 && x3 <= 128728 || x3 >= 128732 && x3 <= 128735 || x3 === 128747 || x3 === 128748 || x3 >= 128756 && x3 <= 128764 || x3 >= 128992 && x3 <= 129003 || x3 === 129008 || x3 >= 129292 && x3 <= 129338 || x3 >= 129340 && x3 <= 129349 || x3 >= 129351 && x3 <= 129535 || x3 >= 129648 && x3 <= 129660 || x3 >= 129664 && x3 <= 129674 || x3 >= 129678 && x3 <= 129734 || x3 === 129736 || x3 >= 129741 && x3 <= 129756 || x3 >= 129759 && x3 <= 129770 || x3 >= 129775 && x3 <= 129784 || x3 >= 131072 && x3 <= 196605 || x3 >= 196608 && x3 <= 262141;
}

// node_modules/get-east-asian-width/index.js
function validate(codePoint) {
  if (!Number.isSafeInteger(codePoint)) {
    throw new TypeError(`Expected a code point, got \`${typeof codePoint}\`.`);
  }
}
function eastAsianWidth(codePoint, { ambiguousAsWide = false } = {}) {
  validate(codePoint);
  if (isFullWidth(codePoint) || isWide(codePoint) || ambiguousAsWide && isAmbiguous(codePoint)) {
    return 2;
  }
  return 1;
}

// node_modules/ora/node_modules/string-width/index.js
var import_emoji_regex = __toESM(require_emoji_regex(), 1);
var segmenter = new Intl.Segmenter;
var defaultIgnorableCodePointRegex = /^\p{Default_Ignorable_Code_Point}$/u;
function stringWidth(string, options = {}) {
  if (typeof string !== "string" || string.length === 0) {
    return 0;
  }
  const {
    ambiguousIsNarrow = true,
    countAnsiEscapeCodes = false
  } = options;
  if (!countAnsiEscapeCodes) {
    string = stripAnsi(string);
  }
  if (string.length === 0) {
    return 0;
  }
  let width = 0;
  const eastAsianWidthOptions = { ambiguousAsWide: !ambiguousIsNarrow };
  for (const { segment: character } of segmenter.segment(string)) {
    const codePoint = character.codePointAt(0);
    if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) {
      continue;
    }
    if (codePoint >= 8203 && codePoint <= 8207 || codePoint === 65279) {
      continue;
    }
    if (codePoint >= 768 && codePoint <= 879 || codePoint >= 6832 && codePoint <= 6911 || codePoint >= 7616 && codePoint <= 7679 || codePoint >= 8400 && codePoint <= 8447 || codePoint >= 65056 && codePoint <= 65071) {
      continue;
    }
    if (codePoint >= 55296 && codePoint <= 57343) {
      continue;
    }
    if (codePoint >= 65024 && codePoint <= 65039) {
      continue;
    }
    if (defaultIgnorableCodePointRegex.test(character)) {
      continue;
    }
    if (import_emoji_regex.default().test(character)) {
      width += 2;
      continue;
    }
    width += eastAsianWidth(codePoint, eastAsianWidthOptions);
  }
  return width;
}

// node_modules/is-interactive/index.js
function isInteractive({ stream = process.stdout } = {}) {
  return Boolean(stream && stream.isTTY && process.env.TERM !== "dumb" && !("CI" in process.env));
}

// node_modules/is-unicode-supported/index.js
import process7 from "node:process";
function isUnicodeSupported2() {
  const { env: env2 } = process7;
  const { TERM, TERM_PROGRAM } = env2;
  if (process7.platform !== "win32") {
    return TERM !== "linux";
  }
  return Boolean(env2.WT_SESSION) || Boolean(env2.TERMINUS_SUBLIME) || env2.ConEmuTask === "{cmd::Cmder}" || TERM_PROGRAM === "Terminus-Sublime" || TERM_PROGRAM === "vscode" || TERM === "xterm-256color" || TERM === "alacritty" || TERM === "rxvt-unicode" || TERM === "rxvt-unicode-256color" || env2.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}

// node_modules/stdin-discarder/index.js
import process8 from "node:process";
var ASCII_ETX_CODE = 3;

class StdinDiscarder {
  #activeCount = 0;
  start() {
    this.#activeCount++;
    if (this.#activeCount === 1) {
      this.#realStart();
    }
  }
  stop() {
    if (this.#activeCount <= 0) {
      throw new Error("`stop` called more times than `start`");
    }
    this.#activeCount--;
    if (this.#activeCount === 0) {
      this.#realStop();
    }
  }
  #realStart() {
    if (process8.platform === "win32" || !process8.stdin.isTTY) {
      return;
    }
    process8.stdin.setRawMode(true);
    process8.stdin.on("data", this.#handleInput);
    process8.stdin.resume();
  }
  #realStop() {
    if (!process8.stdin.isTTY) {
      return;
    }
    process8.stdin.off("data", this.#handleInput);
    process8.stdin.pause();
    process8.stdin.setRawMode(false);
  }
  #handleInput(chunk) {
    if (chunk[0] === ASCII_ETX_CODE) {
      process8.emit("SIGINT");
    }
  }
}
var stdinDiscarder = new StdinDiscarder;
var stdin_discarder_default = stdinDiscarder;

// node_modules/ora/index.js
var import_cli_spinners2 = __toESM(require_cli_spinners(), 1);

class Ora {
  #linesToClear = 0;
  #isDiscardingStdin = false;
  #lineCount = 0;
  #frameIndex = -1;
  #lastSpinnerFrameTime = 0;
  #options;
  #spinner;
  #stream;
  #id;
  #initialInterval;
  #isEnabled;
  #isSilent;
  #indent;
  #text;
  #prefixText;
  #suffixText;
  color;
  constructor(options) {
    if (typeof options === "string") {
      options = {
        text: options
      };
    }
    this.#options = {
      color: "cyan",
      stream: process9.stderr,
      discardStdin: true,
      hideCursor: true,
      ...options
    };
    this.color = this.#options.color;
    this.spinner = this.#options.spinner;
    this.#initialInterval = this.#options.interval;
    this.#stream = this.#options.stream;
    this.#isEnabled = typeof this.#options.isEnabled === "boolean" ? this.#options.isEnabled : isInteractive({ stream: this.#stream });
    this.#isSilent = typeof this.#options.isSilent === "boolean" ? this.#options.isSilent : false;
    this.text = this.#options.text;
    this.prefixText = this.#options.prefixText;
    this.suffixText = this.#options.suffixText;
    this.indent = this.#options.indent;
    if (process9.env.NODE_ENV === "test") {
      this._stream = this.#stream;
      this._isEnabled = this.#isEnabled;
      Object.defineProperty(this, "_linesToClear", {
        get() {
          return this.#linesToClear;
        },
        set(newValue) {
          this.#linesToClear = newValue;
        }
      });
      Object.defineProperty(this, "_frameIndex", {
        get() {
          return this.#frameIndex;
        }
      });
      Object.defineProperty(this, "_lineCount", {
        get() {
          return this.#lineCount;
        }
      });
    }
  }
  get indent() {
    return this.#indent;
  }
  set indent(indent = 0) {
    if (!(indent >= 0 && Number.isInteger(indent))) {
      throw new Error("The `indent` option must be an integer from 0 and up");
    }
    this.#indent = indent;
    this.#updateLineCount();
  }
  get interval() {
    return this.#initialInterval ?? this.#spinner.interval ?? 100;
  }
  get spinner() {
    return this.#spinner;
  }
  set spinner(spinner) {
    this.#frameIndex = -1;
    this.#initialInterval = undefined;
    if (typeof spinner === "object") {
      if (spinner.frames === undefined) {
        throw new Error("The given spinner must have a `frames` property");
      }
      this.#spinner = spinner;
    } else if (!isUnicodeSupported2()) {
      this.#spinner = import_cli_spinners.default.line;
    } else if (spinner === undefined) {
      this.#spinner = import_cli_spinners.default.dots;
    } else if (spinner !== "default" && import_cli_spinners.default[spinner]) {
      this.#spinner = import_cli_spinners.default[spinner];
    } else {
      throw new Error(`There is no built-in spinner named '${spinner}'. See https://github.com/sindresorhus/cli-spinners/blob/main/spinners.json for a full list.`);
    }
  }
  get text() {
    return this.#text;
  }
  set text(value = "") {
    this.#text = value;
    this.#updateLineCount();
  }
  get prefixText() {
    return this.#prefixText;
  }
  set prefixText(value = "") {
    this.#prefixText = value;
    this.#updateLineCount();
  }
  get suffixText() {
    return this.#suffixText;
  }
  set suffixText(value = "") {
    this.#suffixText = value;
    this.#updateLineCount();
  }
  get isSpinning() {
    return this.#id !== undefined;
  }
  #getFullPrefixText(prefixText = this.#prefixText, postfix = " ") {
    if (typeof prefixText === "string" && prefixText !== "") {
      return prefixText + postfix;
    }
    if (typeof prefixText === "function") {
      return prefixText() + postfix;
    }
    return "";
  }
  #getFullSuffixText(suffixText = this.#suffixText, prefix = " ") {
    if (typeof suffixText === "string" && suffixText !== "") {
      return prefix + suffixText;
    }
    if (typeof suffixText === "function") {
      return prefix + suffixText();
    }
    return "";
  }
  #updateLineCount() {
    const columns = this.#stream.columns ?? 80;
    const fullPrefixText = this.#getFullPrefixText(this.#prefixText, "-");
    const fullSuffixText = this.#getFullSuffixText(this.#suffixText, "-");
    const fullText = " ".repeat(this.#indent) + fullPrefixText + "--" + this.#text + "--" + fullSuffixText;
    this.#lineCount = 0;
    for (const line of stripAnsi(fullText).split(`
`)) {
      this.#lineCount += Math.max(1, Math.ceil(stringWidth(line, { countAnsiEscapeCodes: true }) / columns));
    }
  }
  get isEnabled() {
    return this.#isEnabled && !this.#isSilent;
  }
  set isEnabled(value) {
    if (typeof value !== "boolean") {
      throw new TypeError("The `isEnabled` option must be a boolean");
    }
    this.#isEnabled = value;
  }
  get isSilent() {
    return this.#isSilent;
  }
  set isSilent(value) {
    if (typeof value !== "boolean") {
      throw new TypeError("The `isSilent` option must be a boolean");
    }
    this.#isSilent = value;
  }
  frame() {
    const now = Date.now();
    if (this.#frameIndex === -1 || now - this.#lastSpinnerFrameTime >= this.interval) {
      this.#frameIndex = ++this.#frameIndex % this.#spinner.frames.length;
      this.#lastSpinnerFrameTime = now;
    }
    const { frames } = this.#spinner;
    let frame = frames[this.#frameIndex];
    if (this.color) {
      frame = source_default[this.color](frame);
    }
    const fullPrefixText = typeof this.#prefixText === "string" && this.#prefixText !== "" ? this.#prefixText + " " : "";
    const fullText = typeof this.text === "string" ? " " + this.text : "";
    const fullSuffixText = typeof this.#suffixText === "string" && this.#suffixText !== "" ? " " + this.#suffixText : "";
    return fullPrefixText + frame + fullText + fullSuffixText;
  }
  clear() {
    if (!this.#isEnabled || !this.#stream.isTTY) {
      return this;
    }
    this.#stream.cursorTo(0);
    for (let index = 0;index < this.#linesToClear; index++) {
      if (index > 0) {
        this.#stream.moveCursor(0, -1);
      }
      this.#stream.clearLine(1);
    }
    if (this.#indent || this.lastIndent !== this.#indent) {
      this.#stream.cursorTo(this.#indent);
    }
    this.lastIndent = this.#indent;
    this.#linesToClear = 0;
    return this;
  }
  render() {
    if (this.#isSilent) {
      return this;
    }
    this.clear();
    this.#stream.write(this.frame());
    this.#linesToClear = this.#lineCount;
    return this;
  }
  start(text) {
    if (text) {
      this.text = text;
    }
    if (this.#isSilent) {
      return this;
    }
    if (!this.#isEnabled) {
      if (this.text) {
        this.#stream.write(`- ${this.text}
`);
      }
      return this;
    }
    if (this.isSpinning) {
      return this;
    }
    if (this.#options.hideCursor) {
      cli_cursor_default.hide(this.#stream);
    }
    if (this.#options.discardStdin && process9.stdin.isTTY) {
      this.#isDiscardingStdin = true;
      stdin_discarder_default.start();
    }
    this.render();
    this.#id = setInterval(this.render.bind(this), this.interval);
    return this;
  }
  stop() {
    if (!this.#isEnabled) {
      return this;
    }
    clearInterval(this.#id);
    this.#id = undefined;
    this.#frameIndex = 0;
    this.clear();
    if (this.#options.hideCursor) {
      cli_cursor_default.show(this.#stream);
    }
    if (this.#options.discardStdin && process9.stdin.isTTY && this.#isDiscardingStdin) {
      stdin_discarder_default.stop();
      this.#isDiscardingStdin = false;
    }
    return this;
  }
  succeed(text) {
    return this.stopAndPersist({ symbol: log_symbols_default.success, text });
  }
  fail(text) {
    return this.stopAndPersist({ symbol: log_symbols_default.error, text });
  }
  warn(text) {
    return this.stopAndPersist({ symbol: log_symbols_default.warning, text });
  }
  info(text) {
    return this.stopAndPersist({ symbol: log_symbols_default.info, text });
  }
  stopAndPersist(options = {}) {
    if (this.#isSilent) {
      return this;
    }
    const prefixText = options.prefixText ?? this.#prefixText;
    const fullPrefixText = this.#getFullPrefixText(prefixText, " ");
    const symbolText = options.symbol ?? " ";
    const text = options.text ?? this.text;
    const separatorText = symbolText ? " " : "";
    const fullText = typeof text === "string" ? separatorText + text : "";
    const suffixText = options.suffixText ?? this.#suffixText;
    const fullSuffixText = this.#getFullSuffixText(suffixText, " ");
    const textToWrite = fullPrefixText + symbolText + fullText + fullSuffixText + `
`;
    this.stop();
    this.#stream.write(textToWrite);
    return this;
  }
}
function ora(options) {
  return new Ora(options);
}

// src/shared/safe-spinner.ts
var import_picocolors15 = __toESM(require_picocolors(), 1);
init_output_manager();
var ASCII_SPINNER = {
  interval: 100,
  frames: ["-", "\\", "|", "/"]
};
var UNICODE_SPINNER = {
  interval: 80,
  frames: ["", "", "", "", "", "", "", "", "", ""]
};
function createSpinner(options) {
  const spinnerOptions = typeof options === "string" ? { text: options } : options;
  const symbols = output.getSymbols();
  const shouldShow = output.shouldShowProgress();
  const spinnerType = symbols === output.getSymbols() && symbols.success === "" ? UNICODE_SPINNER : ASCII_SPINNER;
  const spinner = ora({
    ...spinnerOptions,
    spinner: spinnerType,
    prefixText: "",
    isSilent: !shouldShow
  });
  spinner.succeed = (text) => {
    if (output.isJson()) {
      spinner.stop();
      output.addJsonEntry({ type: "success", message: text || spinner.text });
      return spinner;
    }
    spinner.stopAndPersist({
      symbol: import_picocolors15.default.green(symbols.success),
      text: text || spinner.text
    });
    return spinner;
  };
  spinner.fail = (text) => {
    if (output.isJson()) {
      spinner.stop();
      output.addJsonEntry({ type: "error", message: text || spinner.text });
      return spinner;
    }
    spinner.stopAndPersist({
      symbol: import_picocolors15.default.red(symbols.error),
      text: text || spinner.text
    });
    return spinner;
  };
  return spinner;
}

// src/domains/installation/download-manager.ts
init_types2();
var import_ignore = __toESM(require_ignore(), 1);

// src/domains/installation/download/file-downloader.ts
init_logger();
init_output_manager();
import { createWriteStream as createWriteStream2, rmSync } from "node:fs";
import { mkdir as mkdir9 } from "node:fs/promises";
import { join as join31 } from "node:path";

// src/shared/progress-bar.ts
var import_picocolors16 = __toESM(require_picocolors(), 1);
init_output_manager();
init_terminal_utils();
var BAR_CHARS = {
  unicode: { filled: "", empty: "" },
  ascii: { filled: "=", empty: "-" }
};
var RENDER_RATE_LIMIT_MS = 100;
var JSON_MILESTONE_INTERVAL = 25;
var MIN_ELAPSED_SECONDS = 0.1;
var MAX_LABEL_WIDTH = 14;

class ProgressBar {
  current = 0;
  total;
  label;
  width;
  format;
  showEta;
  startTime;
  lastRenderTime = 0;
  lastRenderContent = "";
  isCompleted = false;
  constructor(options) {
    this.total = options.total;
    this.label = options.label || "";
    this.width = options.width || 20;
    this.format = options.format || "percentage";
    this.showEta = options.showEta ?? false;
    this.startTime = Date.now();
  }
  update(current) {
    if (this.isCompleted)
      return;
    this.current = Math.min(current, this.total);
    this.render();
  }
  increment(delta = 1) {
    this.update(this.current + delta);
  }
  complete(message) {
    if (this.isCompleted)
      return;
    this.isCompleted = true;
    this.current = this.total;
    if (output.isJson()) {
      output.addJsonEntry({
        type: "progress",
        message: message || `${this.label} complete`,
        data: { current: this.current, total: this.total, percent: 100 }
      });
      return;
    }
    if (!this.shouldRender()) {
      console.log(message || `${this.label} complete`);
      return;
    }
    this.clearLine();
    if (message) {
      const symbols = output.getSymbols();
      console.log(`${import_picocolors16.default.green(symbols.success)} ${message}`);
    }
  }
  clearLine() {
    if (isTTY()) {
      process.stdout.write("\r\x1B[K");
    }
  }
  shouldRender() {
    if (output.isJson())
      return false;
    if (!isTTY())
      return false;
    return true;
  }
  render() {
    const now = Date.now();
    if (now - this.lastRenderTime < RENDER_RATE_LIMIT_MS && this.current < this.total) {
      return;
    }
    this.lastRenderTime = now;
    if (output.isJson()) {
      const percent = Math.floor(this.current / this.total * 100);
      if (percent % JSON_MILESTONE_INTERVAL === 0 || this.current === this.total) {
        output.addJsonEntry({
          type: "progress",
          data: { current: this.current, total: this.total, percent }
        });
      }
      return;
    }
    if (!this.shouldRender()) {
      const percent = Math.floor(this.current / this.total * 100);
      if (percent % JSON_MILESTONE_INTERVAL === 0 && this.lastRenderContent !== `${percent}%`) {
        this.lastRenderContent = `${percent}%`;
        console.log(`  ${this.label} ${this.formatProgress()}`);
      }
      return;
    }
    const content = this.formatBar();
    process.stdout.write(`\r${content}`);
  }
  formatBar() {
    const chars = this.getBarCharacters();
    const percent = this.total > 0 ? this.current / this.total : 0;
    const filledCount = Math.round(percent * this.width);
    const emptyCount = this.width - filledCount;
    const bar = chars.filled.repeat(filledCount) + chars.empty.repeat(emptyCount);
    const progress = this.formatProgress();
    const displayLabel = this.label.length > MAX_LABEL_WIDTH ? `${this.label.slice(0, MAX_LABEL_WIDTH - 3)}...` : this.label;
    let line = `  ${displayLabel}`.padEnd(16);
    line += `[${bar}] ${progress}`;
    if (this.showEta && this.current > 0 && this.current < this.total) {
      const elapsed = Math.max((Date.now() - this.startTime) / 1000, MIN_ELAPSED_SECONDS);
      const rate = this.current / elapsed;
      const remaining = (this.total - this.current) / rate;
      line += ` ETA: ${this.formatTime(remaining)}`;
    }
    return line;
  }
  formatProgress() {
    switch (this.format) {
      case "download":
        return `${this.formatSize(this.current)} / ${this.formatSize(this.total)}`;
      case "count":
        return `${this.current}/${this.total}`;
      default: {
        const percent = this.total > 0 ? Math.round(this.current / this.total * 100) : 0;
        return `${percent}%`;
      }
    }
  }
  formatSize(bytes) {
    if (bytes < 1024)
      return `${bytes} B`;
    if (bytes < 1024 * 1024)
      return `${(bytes / 1024).toFixed(1)} KB`;
    if (bytes < 1024 * 1024 * 1024)
      return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
    return `${(bytes / (1024 * 1024 * 1024)).toFixed(2)} GB`;
  }
  formatTime(seconds) {
    if (seconds < 60)
      return `${Math.round(seconds)}s`;
    const mins = Math.floor(seconds / 60);
    const secs = Math.round(seconds % 60);
    return `${mins}m${secs}s`;
  }
  getBarCharacters() {
    return supportsUnicode() ? BAR_CHARS.unicode : BAR_CHARS.ascii;
  }
}
function createProgressBar(options) {
  return new ProgressBar(options);
}

// src/domains/installation/download/file-downloader.ts
init_types2();

// src/domains/installation/utils/path-security.ts
init_types2();
import { relative as relative3, resolve as resolve4 } from "node:path";
var MAX_EXTRACTION_SIZE = 500 * 1024 * 1024;
function isPathSafe(basePath, targetPath) {
  const resolvedBase = resolve4(basePath);
  const resolvedTarget = resolve4(targetPath);
  const relativePath = relative3(resolvedBase, resolvedTarget);
  return !relativePath.startsWith("..") && !relativePath.startsWith("/") && resolvedTarget.startsWith(resolvedBase);
}

class ExtractionSizeTracker {
  totalExtractedSize = 0;
  checkExtractionSize(fileSize) {
    this.totalExtractedSize += fileSize;
    if (this.totalExtractedSize > MAX_EXTRACTION_SIZE) {
      throw new ExtractionError(`Archive exceeds maximum extraction size of ${formatBytes(MAX_EXTRACTION_SIZE)}. Possible archive bomb detected.`);
    }
  }
  reset() {
    this.totalExtractedSize = 0;
  }
}
function formatBytes(bytes) {
  if (bytes === 0)
    return "0 Bytes";
  const k2 = 1024;
  const sizes = ["Bytes", "KB", "MB", "GB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k2));
  return `${Math.round(bytes / k2 ** i * 100) / 100} ${sizes[i]}`;
}

// src/domains/installation/download/file-downloader.ts
var MAX_DOWNLOAD_SIZE = 500 * 1024 * 1024;

class FileDownloader {
  async downloadAsset(asset, destDir) {
    try {
      const destPath = join31(destDir, asset.name);
      await mkdir9(destDir, { recursive: true });
      output.info(`Downloading ${asset.name} (${formatBytes(asset.size)})...`);
      logger.verbose("Download details", {
        url: asset.browser_download_url,
        size: asset.size,
        name: asset.name
      });
      const response = await fetch(asset.browser_download_url, {
        headers: {
          Accept: "application/octet-stream"
        }
      });
      logger.verbose("HTTP response", {
        status: response.status,
        statusText: response.statusText,
        headers: Object.fromEntries(response.headers.entries())
      });
      if (!response.ok) {
        throw new DownloadError(`Failed to download: ${response.statusText}`);
      }
      const totalSize = asset.size;
      if (totalSize > MAX_DOWNLOAD_SIZE) {
        throw new DownloadError(`File too large: ${formatBytes(totalSize)} exceeds ${formatBytes(MAX_DOWNLOAD_SIZE)} limit`);
      }
      let downloadedSize = 0;
      const progressBar = createProgressBar({
        total: totalSize,
        format: "download",
        label: "Downloading"
      });
      const fileStream = createWriteStream2(destPath);
      const reader = response.body?.getReader();
      if (!reader) {
        throw new DownloadError("Failed to get response reader");
      }
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            break;
          }
          fileStream.write(value);
          downloadedSize += value.length;
          progressBar.update(downloadedSize);
        }
        if (downloadedSize !== totalSize) {
          fileStream.end();
          await new Promise((resolve5) => fileStream.once("close", resolve5));
          try {
            rmSync(destPath, { force: true });
          } catch (cleanupError) {
            const errorMsg = cleanupError instanceof Error ? cleanupError.message : String(cleanupError);
            logger.debug(`Failed to clean up partial download ${destPath}: ${errorMsg}`);
          }
          throw new DownloadError(`Incomplete download: received ${formatBytes(downloadedSize)} of ${formatBytes(totalSize)}`);
        }
        fileStream.end();
        progressBar.complete(`Downloaded ${asset.name}`);
        return destPath;
      } catch (error) {
        fileStream.end();
        await new Promise((resolve5) => fileStream.once("close", resolve5));
        try {
          rmSync(destPath, { force: true });
        } catch (cleanupError) {
          const errorMsg = cleanupError instanceof Error ? cleanupError.message : String(cleanupError);
          logger.debug(`Failed to clean up partial download ${destPath}: ${errorMsg}`);
        }
        throw error;
      }
    } catch (error) {
      throw new DownloadError(`Failed to download ${asset.name}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  async downloadFile(params) {
    const { url, name, size, destDir, token } = params;
    const destPath = join31(destDir, name);
    await mkdir9(destDir, { recursive: true });
    output.info(`Downloading ${name}${size ? ` (${formatBytes(size)})` : ""}...`);
    const headers = {};
    if (token && url.includes("api.github.com")) {
      headers.Authorization = `Bearer ${token}`;
      headers.Accept = "application/octet-stream";
      headers["X-GitHub-Api-Version"] = "2022-11-28";
    } else {
      headers.Accept = "application/octet-stream";
    }
    const response = await fetch(url, { headers });
    if (!response.ok) {
      throw new DownloadError(`Failed to download: ${response.statusText}`);
    }
    const totalSize = size || Number(response.headers.get("content-length")) || 0;
    if (totalSize > MAX_DOWNLOAD_SIZE) {
      throw new DownloadError(`File too large: ${formatBytes(totalSize)} exceeds ${formatBytes(MAX_DOWNLOAD_SIZE)} limit`);
    }
    let downloadedSize = 0;
    const progressBar = totalSize > 0 ? createProgressBar({
      total: totalSize,
      format: "download",
      label: "Downloading"
    }) : null;
    const fileStream = createWriteStream2(destPath);
    const reader = response.body?.getReader();
    if (!reader) {
      throw new DownloadError("Failed to get response reader");
    }
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          break;
        fileStream.write(value);
        downloadedSize += value.length;
        if (progressBar) {
          progressBar.update(downloadedSize);
        }
      }
      const expectedSize = Number(response.headers.get("content-length"));
      if (expectedSize > 0 && downloadedSize !== expectedSize) {
        fileStream.end();
        await new Promise((resolve5) => fileStream.once("close", resolve5));
        try {
          rmSync(destPath, { force: true });
        } catch (cleanupError) {
          const errorMsg = cleanupError instanceof Error ? cleanupError.message : String(cleanupError);
          logger.debug(`Failed to clean up partial download ${destPath}: ${errorMsg}`);
        }
        throw new DownloadError(`Incomplete download: received ${formatBytes(downloadedSize)} of ${formatBytes(expectedSize)}`);
      }
      fileStream.end();
      if (progressBar) {
        progressBar.complete(`Downloaded ${name}`);
      } else {
        output.success(`Downloaded ${name}`);
      }
      return destPath;
    } catch (error) {
      fileStream.end();
      await new Promise((resolve5) => fileStream.once("close", resolve5));
      try {
        rmSync(destPath, { force: true });
      } catch (cleanupError) {
        const errorMsg = cleanupError instanceof Error ? cleanupError.message : String(cleanupError);
        logger.debug(`Failed to clean up partial download ${destPath}: ${errorMsg}`);
      }
      throw error;
    }
  }
}

// src/domains/installation/extraction/extraction-validator.ts
init_logger();
init_types2();
import { constants as constants3 } from "node:fs";
import { access as access3, readdir as readdir4 } from "node:fs/promises";
import { join as join32 } from "node:path";
async function validateExtraction(extractDir) {
  try {
    const entries = await readdir4(extractDir, { encoding: "utf8" });
    logger.debug(`Extracted files: ${entries.join(", ")}`);
    if (entries.length === 0) {
      throw new ExtractionError("Extraction resulted in no files");
    }
    const criticalPaths = [".claude", "CLAUDE.md"];
    const missingPaths = [];
    for (const path2 of criticalPaths) {
      try {
        await access3(join32(extractDir, path2), constants3.F_OK);
        logger.debug(`Found: ${path2}`);
      } catch {
        logger.warning(`Expected path not found: ${path2}`);
        missingPaths.push(path2);
      }
    }
    if (missingPaths.length > 0) {
      logger.warning(`Some expected paths are missing: ${missingPaths.join(", ")}. This may not be a ClaudeKit project.`);
    }
    logger.debug("Extraction validation passed");
  } catch (error) {
    if (error instanceof ExtractionError) {
      throw error;
    }
    throw new ExtractionError(`Validation failed: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}

// src/domains/installation/extraction/tar-extractor.ts
init_logger();
import { copyFile as copyFile2, mkdir as mkdir12, readdir as readdir6, rm, stat as stat3 } from "node:fs/promises";
import { join as join35 } from "node:path";

// node_modules/@isaacs/fs-minipass/dist/esm/index.js
import EE from "events";
import fs3 from "fs";

// node_modules/@isaacs/fs-minipass/node_modules/minipass/dist/esm/index.js
import { EventEmitter as EventEmitter2 } from "node:events";
import Stream from "node:stream";
import { StringDecoder } from "node:string_decoder";
var proc = typeof process === "object" && process ? process : {
  stdout: null,
  stderr: null
};
var isStream = (s) => !!s && typeof s === "object" && (s instanceof Minipass || s instanceof Stream || isReadable(s) || isWritable(s));
var isReadable = (s) => !!s && typeof s === "object" && s instanceof EventEmitter2 && typeof s.pipe === "function" && s.pipe !== Stream.Writable.prototype.pipe;
var isWritable = (s) => !!s && typeof s === "object" && s instanceof EventEmitter2 && typeof s.write === "function" && typeof s.end === "function";
var EOF = Symbol("EOF");
var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
var EMITTED_END = Symbol("emittedEnd");
var EMITTING_END = Symbol("emittingEnd");
var EMITTED_ERROR = Symbol("emittedError");
var CLOSED = Symbol("closed");
var READ = Symbol("read");
var FLUSH = Symbol("flush");
var FLUSHCHUNK = Symbol("flushChunk");
var ENCODING = Symbol("encoding");
var DECODER = Symbol("decoder");
var FLOWING = Symbol("flowing");
var PAUSED = Symbol("paused");
var RESUME = Symbol("resume");
var BUFFER = Symbol("buffer");
var PIPES = Symbol("pipes");
var BUFFERLENGTH = Symbol("bufferLength");
var BUFFERPUSH = Symbol("bufferPush");
var BUFFERSHIFT = Symbol("bufferShift");
var OBJECTMODE = Symbol("objectMode");
var DESTROYED = Symbol("destroyed");
var ERROR = Symbol("error");
var EMITDATA = Symbol("emitData");
var EMITEND = Symbol("emitEnd");
var EMITEND2 = Symbol("emitEnd2");
var ASYNC = Symbol("async");
var ABORT = Symbol("abort");
var ABORTED = Symbol("aborted");
var SIGNAL = Symbol("signal");
var DATALISTENERS = Symbol("dataListeners");
var DISCARDED = Symbol("discarded");
var defer = (fn) => Promise.resolve().then(fn);
var nodefer = (fn) => fn();
var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
var isArrayBufferLike = (b3) => b3 instanceof ArrayBuffer || !!b3 && typeof b3 === "object" && b3.constructor && b3.constructor.name === "ArrayBuffer" && b3.byteLength >= 0;
var isArrayBufferView = (b3) => !Buffer.isBuffer(b3) && ArrayBuffer.isView(b3);

class Pipe {
  src;
  dest;
  opts;
  ondrain;
  constructor(src, dest, opts) {
    this.src = src;
    this.dest = dest;
    this.opts = opts;
    this.ondrain = () => src[RESUME]();
    this.dest.on("drain", this.ondrain);
  }
  unpipe() {
    this.dest.removeListener("drain", this.ondrain);
  }
  proxyErrors(_er) {}
  end() {
    this.unpipe();
    if (this.opts.end)
      this.dest.end();
  }
}

class PipeProxyErrors extends Pipe {
  unpipe() {
    this.src.removeListener("error", this.proxyErrors);
    super.unpipe();
  }
  constructor(src, dest, opts) {
    super(src, dest, opts);
    this.proxyErrors = (er) => dest.emit("error", er);
    src.on("error", this.proxyErrors);
  }
}
var isObjectModeOptions = (o2) => !!o2.objectMode;
var isEncodingOptions = (o2) => !o2.objectMode && !!o2.encoding && o2.encoding !== "buffer";

class Minipass extends EventEmitter2 {
  [FLOWING] = false;
  [PAUSED] = false;
  [PIPES] = [];
  [BUFFER] = [];
  [OBJECTMODE];
  [ENCODING];
  [ASYNC];
  [DECODER];
  [EOF] = false;
  [EMITTED_END] = false;
  [EMITTING_END] = false;
  [CLOSED] = false;
  [EMITTED_ERROR] = null;
  [BUFFERLENGTH] = 0;
  [DESTROYED] = false;
  [SIGNAL];
  [ABORTED] = false;
  [DATALISTENERS] = 0;
  [DISCARDED] = false;
  writable = true;
  readable = true;
  constructor(...args) {
    const options = args[0] || {};
    super();
    if (options.objectMode && typeof options.encoding === "string") {
      throw new TypeError("Encoding and objectMode may not be used together");
    }
    if (isObjectModeOptions(options)) {
      this[OBJECTMODE] = true;
      this[ENCODING] = null;
    } else if (isEncodingOptions(options)) {
      this[ENCODING] = options.encoding;
      this[OBJECTMODE] = false;
    } else {
      this[OBJECTMODE] = false;
      this[ENCODING] = null;
    }
    this[ASYNC] = !!options.async;
    this[DECODER] = this[ENCODING] ? new StringDecoder(this[ENCODING]) : null;
    if (options && options.debugExposeBuffer === true) {
      Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
    }
    if (options && options.debugExposePipes === true) {
      Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
    }
    const { signal } = options;
    if (signal) {
      this[SIGNAL] = signal;
      if (signal.aborted) {
        this[ABORT]();
      } else {
        signal.addEventListener("abort", () => this[ABORT]());
      }
    }
  }
  get bufferLength() {
    return this[BUFFERLENGTH];
  }
  get encoding() {
    return this[ENCODING];
  }
  set encoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  setEncoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  get objectMode() {
    return this[OBJECTMODE];
  }
  set objectMode(_om) {
    throw new Error("objectMode must be set at instantiation time");
  }
  get ["async"]() {
    return this[ASYNC];
  }
  set ["async"](a3) {
    this[ASYNC] = this[ASYNC] || !!a3;
  }
  [ABORT]() {
    this[ABORTED] = true;
    this.emit("abort", this[SIGNAL]?.reason);
    this.destroy(this[SIGNAL]?.reason);
  }
  get aborted() {
    return this[ABORTED];
  }
  set aborted(_3) {}
  write(chunk, encoding, cb) {
    if (this[ABORTED])
      return false;
    if (this[EOF])
      throw new Error("write after end");
    if (this[DESTROYED]) {
      this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
      return true;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = "utf8";
    }
    if (!encoding)
      encoding = "utf8";
    const fn = this[ASYNC] ? defer : nodefer;
    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
      if (isArrayBufferView(chunk)) {
        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
      } else if (isArrayBufferLike(chunk)) {
        chunk = Buffer.from(chunk);
      } else if (typeof chunk !== "string") {
        throw new Error("Non-contiguous data written to non-objectMode stream");
      }
    }
    if (this[OBJECTMODE]) {
      if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
        this[FLUSH](true);
      if (this[FLOWING])
        this.emit("data", chunk);
      else
        this[BUFFERPUSH](chunk);
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING];
    }
    if (!chunk.length) {
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING];
    }
    if (typeof chunk === "string" && !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
      chunk = Buffer.from(chunk, encoding);
    }
    if (Buffer.isBuffer(chunk) && this[ENCODING]) {
      chunk = this[DECODER].write(chunk);
    }
    if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
      this[FLUSH](true);
    if (this[FLOWING])
      this.emit("data", chunk);
    else
      this[BUFFERPUSH](chunk);
    if (this[BUFFERLENGTH] !== 0)
      this.emit("readable");
    if (cb)
      fn(cb);
    return this[FLOWING];
  }
  read(n) {
    if (this[DESTROYED])
      return null;
    this[DISCARDED] = false;
    if (this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH]) {
      this[MAYBE_EMIT_END]();
      return null;
    }
    if (this[OBJECTMODE])
      n = null;
    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
      this[BUFFER] = [
        this[ENCODING] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
      ];
    }
    const ret = this[READ](n || null, this[BUFFER][0]);
    this[MAYBE_EMIT_END]();
    return ret;
  }
  [READ](n, chunk) {
    if (this[OBJECTMODE])
      this[BUFFERSHIFT]();
    else {
      const c2 = chunk;
      if (n === c2.length || n === null)
        this[BUFFERSHIFT]();
      else if (typeof c2 === "string") {
        this[BUFFER][0] = c2.slice(n);
        chunk = c2.slice(0, n);
        this[BUFFERLENGTH] -= n;
      } else {
        this[BUFFER][0] = c2.subarray(n);
        chunk = c2.subarray(0, n);
        this[BUFFERLENGTH] -= n;
      }
    }
    this.emit("data", chunk);
    if (!this[BUFFER].length && !this[EOF])
      this.emit("drain");
    return chunk;
  }
  end(chunk, encoding, cb) {
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = undefined;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = "utf8";
    }
    if (chunk !== undefined)
      this.write(chunk, encoding);
    if (cb)
      this.once("end", cb);
    this[EOF] = true;
    this.writable = false;
    if (this[FLOWING] || !this[PAUSED])
      this[MAYBE_EMIT_END]();
    return this;
  }
  [RESUME]() {
    if (this[DESTROYED])
      return;
    if (!this[DATALISTENERS] && !this[PIPES].length) {
      this[DISCARDED] = true;
    }
    this[PAUSED] = false;
    this[FLOWING] = true;
    this.emit("resume");
    if (this[BUFFER].length)
      this[FLUSH]();
    else if (this[EOF])
      this[MAYBE_EMIT_END]();
    else
      this.emit("drain");
  }
  resume() {
    return this[RESUME]();
  }
  pause() {
    this[FLOWING] = false;
    this[PAUSED] = true;
    this[DISCARDED] = false;
  }
  get destroyed() {
    return this[DESTROYED];
  }
  get flowing() {
    return this[FLOWING];
  }
  get paused() {
    return this[PAUSED];
  }
  [BUFFERPUSH](chunk) {
    if (this[OBJECTMODE])
      this[BUFFERLENGTH] += 1;
    else
      this[BUFFERLENGTH] += chunk.length;
    this[BUFFER].push(chunk);
  }
  [BUFFERSHIFT]() {
    if (this[OBJECTMODE])
      this[BUFFERLENGTH] -= 1;
    else
      this[BUFFERLENGTH] -= this[BUFFER][0].length;
    return this[BUFFER].shift();
  }
  [FLUSH](noDrain = false) {
    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
    if (!noDrain && !this[BUFFER].length && !this[EOF])
      this.emit("drain");
  }
  [FLUSHCHUNK](chunk) {
    this.emit("data", chunk);
    return this[FLOWING];
  }
  pipe(dest, opts) {
    if (this[DESTROYED])
      return dest;
    this[DISCARDED] = false;
    const ended = this[EMITTED_END];
    opts = opts || {};
    if (dest === proc.stdout || dest === proc.stderr)
      opts.end = false;
    else
      opts.end = opts.end !== false;
    opts.proxyErrors = !!opts.proxyErrors;
    if (ended) {
      if (opts.end)
        dest.end();
    } else {
      this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
      if (this[ASYNC])
        defer(() => this[RESUME]());
      else
        this[RESUME]();
    }
    return dest;
  }
  unpipe(dest) {
    const p = this[PIPES].find((p2) => p2.dest === dest);
    if (p) {
      if (this[PIPES].length === 1) {
        if (this[FLOWING] && this[DATALISTENERS] === 0) {
          this[FLOWING] = false;
        }
        this[PIPES] = [];
      } else
        this[PIPES].splice(this[PIPES].indexOf(p), 1);
      p.unpipe();
    }
  }
  addListener(ev, handler) {
    return this.on(ev, handler);
  }
  on(ev, handler) {
    const ret = super.on(ev, handler);
    if (ev === "data") {
      this[DISCARDED] = false;
      this[DATALISTENERS]++;
      if (!this[PIPES].length && !this[FLOWING]) {
        this[RESUME]();
      }
    } else if (ev === "readable" && this[BUFFERLENGTH] !== 0) {
      super.emit("readable");
    } else if (isEndish(ev) && this[EMITTED_END]) {
      super.emit(ev);
      this.removeAllListeners(ev);
    } else if (ev === "error" && this[EMITTED_ERROR]) {
      const h2 = handler;
      if (this[ASYNC])
        defer(() => h2.call(this, this[EMITTED_ERROR]));
      else
        h2.call(this, this[EMITTED_ERROR]);
    }
    return ret;
  }
  removeListener(ev, handler) {
    return this.off(ev, handler);
  }
  off(ev, handler) {
    const ret = super.off(ev, handler);
    if (ev === "data") {
      this[DATALISTENERS] = this.listeners("data").length;
      if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) {
        this[FLOWING] = false;
      }
    }
    return ret;
  }
  removeAllListeners(ev) {
    const ret = super.removeAllListeners(ev);
    if (ev === "data" || ev === undefined) {
      this[DATALISTENERS] = 0;
      if (!this[DISCARDED] && !this[PIPES].length) {
        this[FLOWING] = false;
      }
    }
    return ret;
  }
  get emittedEnd() {
    return this[EMITTED_END];
  }
  [MAYBE_EMIT_END]() {
    if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
      this[EMITTING_END] = true;
      this.emit("end");
      this.emit("prefinish");
      this.emit("finish");
      if (this[CLOSED])
        this.emit("close");
      this[EMITTING_END] = false;
    }
  }
  emit(ev, ...args) {
    const data = args[0];
    if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED]) {
      return false;
    } else if (ev === "data") {
      return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer(() => this[EMITDATA](data)), true) : this[EMITDATA](data);
    } else if (ev === "end") {
      return this[EMITEND]();
    } else if (ev === "close") {
      this[CLOSED] = true;
      if (!this[EMITTED_END] && !this[DESTROYED])
        return false;
      const ret2 = super.emit("close");
      this.removeAllListeners("close");
      return ret2;
    } else if (ev === "error") {
      this[EMITTED_ERROR] = data;
      super.emit(ERROR, data);
      const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
      this[MAYBE_EMIT_END]();
      return ret2;
    } else if (ev === "resume") {
      const ret2 = super.emit("resume");
      this[MAYBE_EMIT_END]();
      return ret2;
    } else if (ev === "finish" || ev === "prefinish") {
      const ret2 = super.emit(ev);
      this.removeAllListeners(ev);
      return ret2;
    }
    const ret = super.emit(ev, ...args);
    this[MAYBE_EMIT_END]();
    return ret;
  }
  [EMITDATA](data) {
    for (const p of this[PIPES]) {
      if (p.dest.write(data) === false)
        this.pause();
    }
    const ret = this[DISCARDED] ? false : super.emit("data", data);
    this[MAYBE_EMIT_END]();
    return ret;
  }
  [EMITEND]() {
    if (this[EMITTED_END])
      return false;
    this[EMITTED_END] = true;
    this.readable = false;
    return this[ASYNC] ? (defer(() => this[EMITEND2]()), true) : this[EMITEND2]();
  }
  [EMITEND2]() {
    if (this[DECODER]) {
      const data = this[DECODER].end();
      if (data) {
        for (const p of this[PIPES]) {
          p.dest.write(data);
        }
        if (!this[DISCARDED])
          super.emit("data", data);
      }
    }
    for (const p of this[PIPES]) {
      p.end();
    }
    const ret = super.emit("end");
    this.removeAllListeners("end");
    return ret;
  }
  async collect() {
    const buf = Object.assign([], {
      dataLength: 0
    });
    if (!this[OBJECTMODE])
      buf.dataLength = 0;
    const p = this.promise();
    this.on("data", (c2) => {
      buf.push(c2);
      if (!this[OBJECTMODE])
        buf.dataLength += c2.length;
    });
    await p;
    return buf;
  }
  async concat() {
    if (this[OBJECTMODE]) {
      throw new Error("cannot concat in objectMode");
    }
    const buf = await this.collect();
    return this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
  }
  async promise() {
    return new Promise((resolve5, reject) => {
      this.on(DESTROYED, () => reject(new Error("stream destroyed")));
      this.on("error", (er) => reject(er));
      this.on("end", () => resolve5());
    });
  }
  [Symbol.asyncIterator]() {
    this[DISCARDED] = false;
    let stopped = false;
    const stop = async () => {
      this.pause();
      stopped = true;
      return { value: undefined, done: true };
    };
    const next = () => {
      if (stopped)
        return stop();
      const res = this.read();
      if (res !== null)
        return Promise.resolve({ done: false, value: res });
      if (this[EOF])
        return stop();
      let resolve5;
      let reject;
      const onerr = (er) => {
        this.off("data", ondata);
        this.off("end", onend);
        this.off(DESTROYED, ondestroy);
        stop();
        reject(er);
      };
      const ondata = (value) => {
        this.off("error", onerr);
        this.off("end", onend);
        this.off(DESTROYED, ondestroy);
        this.pause();
        resolve5({ value, done: !!this[EOF] });
      };
      const onend = () => {
        this.off("error", onerr);
        this.off("data", ondata);
        this.off(DESTROYED, ondestroy);
        stop();
        resolve5({ done: true, value: undefined });
      };
      const ondestroy = () => onerr(new Error("stream destroyed"));
      return new Promise((res2, rej) => {
        reject = rej;
        resolve5 = res2;
        this.once(DESTROYED, ondestroy);
        this.once("error", onerr);
        this.once("end", onend);
        this.once("data", ondata);
      });
    };
    return {
      next,
      throw: stop,
      return: stop,
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  [Symbol.iterator]() {
    this[DISCARDED] = false;
    let stopped = false;
    const stop = () => {
      this.pause();
      this.off(ERROR, stop);
      this.off(DESTROYED, stop);
      this.off("end", stop);
      stopped = true;
      return { done: true, value: undefined };
    };
    const next = () => {
      if (stopped)
        return stop();
      const value = this.read();
      return value === null ? stop() : { done: false, value };
    };
    this.once("end", stop);
    this.once(ERROR, stop);
    this.once(DESTROYED, stop);
    return {
      next,
      throw: stop,
      return: stop,
      [Symbol.iterator]() {
        return this;
      }
    };
  }
  destroy(er) {
    if (this[DESTROYED]) {
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED);
      return this;
    }
    this[DESTROYED] = true;
    this[DISCARDED] = true;
    this[BUFFER].length = 0;
    this[BUFFERLENGTH] = 0;
    const wc = this;
    if (typeof wc.close === "function" && !this[CLOSED])
      wc.close();
    if (er)
      this.emit("error", er);
    else
      this.emit(DESTROYED);
    return this;
  }
  static get isStream() {
    return isStream;
  }
}

// node_modules/@isaacs/fs-minipass/dist/esm/index.js
var writev = fs3.writev;
var _autoClose = Symbol("_autoClose");
var _close = Symbol("_close");
var _ended = Symbol("_ended");
var _fd = Symbol("_fd");
var _finished = Symbol("_finished");
var _flags = Symbol("_flags");
var _flush = Symbol("_flush");
var _handleChunk = Symbol("_handleChunk");
var _makeBuf = Symbol("_makeBuf");
var _mode = Symbol("_mode");
var _needDrain = Symbol("_needDrain");
var _onerror = Symbol("_onerror");
var _onopen = Symbol("_onopen");
var _onread = Symbol("_onread");
var _onwrite = Symbol("_onwrite");
var _open = Symbol("_open");
var _path = Symbol("_path");
var _pos = Symbol("_pos");
var _queue = Symbol("_queue");
var _read = Symbol("_read");
var _readSize = Symbol("_readSize");
var _reading = Symbol("_reading");
var _remain = Symbol("_remain");
var _size = Symbol("_size");
var _write = Symbol("_write");
var _writing = Symbol("_writing");
var _defaultFlag = Symbol("_defaultFlag");
var _errored = Symbol("_errored");

class ReadStream extends Minipass {
  [_errored] = false;
  [_fd];
  [_path];
  [_readSize];
  [_reading] = false;
  [_size];
  [_remain];
  [_autoClose];
  constructor(path2, opt) {
    opt = opt || {};
    super(opt);
    this.readable = true;
    this.writable = false;
    if (typeof path2 !== "string") {
      throw new TypeError("path must be a string");
    }
    this[_errored] = false;
    this[_fd] = typeof opt.fd === "number" ? opt.fd : undefined;
    this[_path] = path2;
    this[_readSize] = opt.readSize || 16 * 1024 * 1024;
    this[_reading] = false;
    this[_size] = typeof opt.size === "number" ? opt.size : Infinity;
    this[_remain] = this[_size];
    this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
    if (typeof this[_fd] === "number") {
      this[_read]();
    } else {
      this[_open]();
    }
  }
  get fd() {
    return this[_fd];
  }
  get path() {
    return this[_path];
  }
  write() {
    throw new TypeError("this is a readable stream");
  }
  end() {
    throw new TypeError("this is a readable stream");
  }
  [_open]() {
    fs3.open(this[_path], "r", (er, fd) => this[_onopen](er, fd));
  }
  [_onopen](er, fd) {
    if (er) {
      this[_onerror](er);
    } else {
      this[_fd] = fd;
      this.emit("open", fd);
      this[_read]();
    }
  }
  [_makeBuf]() {
    return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
  }
  [_read]() {
    if (!this[_reading]) {
      this[_reading] = true;
      const buf = this[_makeBuf]();
      if (buf.length === 0) {
        return process.nextTick(() => this[_onread](null, 0, buf));
      }
      fs3.read(this[_fd], buf, 0, buf.length, null, (er, br, b3) => this[_onread](er, br, b3));
    }
  }
  [_onread](er, br, buf) {
    this[_reading] = false;
    if (er) {
      this[_onerror](er);
    } else if (this[_handleChunk](br, buf)) {
      this[_read]();
    }
  }
  [_close]() {
    if (this[_autoClose] && typeof this[_fd] === "number") {
      const fd = this[_fd];
      this[_fd] = undefined;
      fs3.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
    }
  }
  [_onerror](er) {
    this[_reading] = true;
    this[_close]();
    this.emit("error", er);
  }
  [_handleChunk](br, buf) {
    let ret = false;
    this[_remain] -= br;
    if (br > 0) {
      ret = super.write(br < buf.length ? buf.subarray(0, br) : buf);
    }
    if (br === 0 || this[_remain] <= 0) {
      ret = false;
      this[_close]();
      super.end();
    }
    return ret;
  }
  emit(ev, ...args) {
    switch (ev) {
      case "prefinish":
      case "finish":
        return false;
      case "drain":
        if (typeof this[_fd] === "number") {
          this[_read]();
        }
        return false;
      case "error":
        if (this[_errored]) {
          return false;
        }
        this[_errored] = true;
        return super.emit(ev, ...args);
      default:
        return super.emit(ev, ...args);
    }
  }
}

class ReadStreamSync extends ReadStream {
  [_open]() {
    let threw = true;
    try {
      this[_onopen](null, fs3.openSync(this[_path], "r"));
      threw = false;
    } finally {
      if (threw) {
        this[_close]();
      }
    }
  }
  [_read]() {
    let threw = true;
    try {
      if (!this[_reading]) {
        this[_reading] = true;
        do {
          const buf = this[_makeBuf]();
          const br = buf.length === 0 ? 0 : fs3.readSync(this[_fd], buf, 0, buf.length, null);
          if (!this[_handleChunk](br, buf)) {
            break;
          }
        } while (true);
        this[_reading] = false;
      }
      threw = false;
    } finally {
      if (threw) {
        this[_close]();
      }
    }
  }
  [_close]() {
    if (this[_autoClose] && typeof this[_fd] === "number") {
      const fd = this[_fd];
      this[_fd] = undefined;
      fs3.closeSync(fd);
      this.emit("close");
    }
  }
}

class WriteStream extends EE {
  readable = false;
  writable = true;
  [_errored] = false;
  [_writing] = false;
  [_ended] = false;
  [_queue] = [];
  [_needDrain] = false;
  [_path];
  [_mode];
  [_autoClose];
  [_fd];
  [_defaultFlag];
  [_flags];
  [_finished] = false;
  [_pos];
  constructor(path2, opt) {
    opt = opt || {};
    super(opt);
    this[_path] = path2;
    this[_fd] = typeof opt.fd === "number" ? opt.fd : undefined;
    this[_mode] = opt.mode === undefined ? 438 : opt.mode;
    this[_pos] = typeof opt.start === "number" ? opt.start : undefined;
    this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
    const defaultFlag = this[_pos] !== undefined ? "r+" : "w";
    this[_defaultFlag] = opt.flags === undefined;
    this[_flags] = opt.flags === undefined ? defaultFlag : opt.flags;
    if (this[_fd] === undefined) {
      this[_open]();
    }
  }
  emit(ev, ...args) {
    if (ev === "error") {
      if (this[_errored]) {
        return false;
      }
      this[_errored] = true;
    }
    return super.emit(ev, ...args);
  }
  get fd() {
    return this[_fd];
  }
  get path() {
    return this[_path];
  }
  [_onerror](er) {
    this[_close]();
    this[_writing] = true;
    this.emit("error", er);
  }
  [_open]() {
    fs3.open(this[_path], this[_flags], this[_mode], (er, fd) => this[_onopen](er, fd));
  }
  [_onopen](er, fd) {
    if (this[_defaultFlag] && this[_flags] === "r+" && er && er.code === "ENOENT") {
      this[_flags] = "w";
      this[_open]();
    } else if (er) {
      this[_onerror](er);
    } else {
      this[_fd] = fd;
      this.emit("open", fd);
      if (!this[_writing]) {
        this[_flush]();
      }
    }
  }
  end(buf, enc) {
    if (buf) {
      this.write(buf, enc);
    }
    this[_ended] = true;
    if (!this[_writing] && !this[_queue].length && typeof this[_fd] === "number") {
      this[_onwrite](null, 0);
    }
    return this;
  }
  write(buf, enc) {
    if (typeof buf === "string") {
      buf = Buffer.from(buf, enc);
    }
    if (this[_ended]) {
      this.emit("error", new Error("write() after end()"));
      return false;
    }
    if (this[_fd] === undefined || this[_writing] || this[_queue].length) {
      this[_queue].push(buf);
      this[_needDrain] = true;
      return false;
    }
    this[_writing] = true;
    this[_write](buf);
    return true;
  }
  [_write](buf) {
    fs3.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));
  }
  [_onwrite](er, bw) {
    if (er) {
      this[_onerror](er);
    } else {
      if (this[_pos] !== undefined && typeof bw === "number") {
        this[_pos] += bw;
      }
      if (this[_queue].length) {
        this[_flush]();
      } else {
        this[_writing] = false;
        if (this[_ended] && !this[_finished]) {
          this[_finished] = true;
          this[_close]();
          this.emit("finish");
        } else if (this[_needDrain]) {
          this[_needDrain] = false;
          this.emit("drain");
        }
      }
    }
  }
  [_flush]() {
    if (this[_queue].length === 0) {
      if (this[_ended]) {
        this[_onwrite](null, 0);
      }
    } else if (this[_queue].length === 1) {
      this[_write](this[_queue].pop());
    } else {
      const iovec = this[_queue];
      this[_queue] = [];
      writev(this[_fd], iovec, this[_pos], (er, bw) => this[_onwrite](er, bw));
    }
  }
  [_close]() {
    if (this[_autoClose] && typeof this[_fd] === "number") {
      const fd = this[_fd];
      this[_fd] = undefined;
      fs3.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
    }
  }
}

class WriteStreamSync extends WriteStream {
  [_open]() {
    let fd;
    if (this[_defaultFlag] && this[_flags] === "r+") {
      try {
        fd = fs3.openSync(this[_path], this[_flags], this[_mode]);
      } catch (er) {
        if (er?.code === "ENOENT") {
          this[_flags] = "w";
          return this[_open]();
        } else {
          throw er;
        }
      }
    } else {
      fd = fs3.openSync(this[_path], this[_flags], this[_mode]);
    }
    this[_onopen](null, fd);
  }
  [_close]() {
    if (this[_autoClose] && typeof this[_fd] === "number") {
      const fd = this[_fd];
      this[_fd] = undefined;
      fs3.closeSync(fd);
      this.emit("close");
    }
  }
  [_write](buf) {
    let threw = true;
    try {
      this[_onwrite](null, fs3.writeSync(this[_fd], buf, 0, buf.length, this[_pos]));
      threw = false;
    } finally {
      if (threw) {
        try {
          this[_close]();
        } catch {}
      }
    }
  }
}

// node_modules/tar/dist/esm/create.js
import path4 from "node:path";

// node_modules/tar/dist/esm/list.js
import fs4 from "node:fs";
import { dirname as dirname5, parse as parse2 } from "path";

// node_modules/tar/dist/esm/options.js
var argmap = new Map([
  ["C", "cwd"],
  ["f", "file"],
  ["z", "gzip"],
  ["P", "preservePaths"],
  ["U", "unlink"],
  ["strip-components", "strip"],
  ["stripComponents", "strip"],
  ["keep-newer", "newer"],
  ["keepNewer", "newer"],
  ["keep-newer-files", "newer"],
  ["keepNewerFiles", "newer"],
  ["k", "keep"],
  ["keep-existing", "keep"],
  ["keepExisting", "keep"],
  ["m", "noMtime"],
  ["no-mtime", "noMtime"],
  ["p", "preserveOwner"],
  ["L", "follow"],
  ["h", "follow"],
  ["onentry", "onReadEntry"]
]);
var isSyncFile = (o2) => !!o2.sync && !!o2.file;
var isAsyncFile = (o2) => !o2.sync && !!o2.file;
var isSyncNoFile = (o2) => !!o2.sync && !o2.file;
var isAsyncNoFile = (o2) => !o2.sync && !o2.file;
var isFile = (o2) => !!o2.file;
var dealiasKey = (k2) => {
  const d3 = argmap.get(k2);
  if (d3)
    return d3;
  return k2;
};
var dealias = (opt = {}) => {
  if (!opt)
    return {};
  const result = {};
  for (const [key, v2] of Object.entries(opt)) {
    const k2 = dealiasKey(key);
    result[k2] = v2;
  }
  if (result.chmod === undefined && result.noChmod === false) {
    result.chmod = true;
  }
  delete result.noChmod;
  return result;
};

// node_modules/tar/dist/esm/make-command.js
var makeCommand = (syncFile, asyncFile, syncNoFile, asyncNoFile, validate2) => {
  return Object.assign((opt_ = [], entries, cb) => {
    if (Array.isArray(opt_)) {
      entries = opt_;
      opt_ = {};
    }
    if (typeof entries === "function") {
      cb = entries;
      entries = undefined;
    }
    if (!entries) {
      entries = [];
    } else {
      entries = Array.from(entries);
    }
    const opt = dealias(opt_);
    validate2?.(opt, entries);
    if (isSyncFile(opt)) {
      if (typeof cb === "function") {
        throw new TypeError("callback not supported for sync tar functions");
      }
      return syncFile(opt, entries);
    } else if (isAsyncFile(opt)) {
      const p = asyncFile(opt, entries);
      const c2 = cb ? cb : undefined;
      return c2 ? p.then(() => c2(), c2) : p;
    } else if (isSyncNoFile(opt)) {
      if (typeof cb === "function") {
        throw new TypeError("callback not supported for sync tar functions");
      }
      return syncNoFile(opt, entries);
    } else if (isAsyncNoFile(opt)) {
      if (typeof cb === "function") {
        throw new TypeError("callback only supported with file option");
      }
      return asyncNoFile(opt, entries);
    } else {
      throw new Error("impossible options??");
    }
  }, {
    syncFile,
    asyncFile,
    syncNoFile,
    asyncNoFile,
    validate: validate2
  });
};

// node_modules/tar/dist/esm/parse.js
import { EventEmitter as EE2 } from "events";

// node_modules/minizlib/dist/esm/index.js
import assert from "assert";
import { Buffer as Buffer2 } from "buffer";

// node_modules/minizlib/node_modules/minipass/dist/esm/index.js
import { EventEmitter as EventEmitter3 } from "node:events";
import Stream2 from "node:stream";
import { StringDecoder as StringDecoder2 } from "node:string_decoder";
var proc2 = typeof process === "object" && process ? process : {
  stdout: null,
  stderr: null
};
var isStream2 = (s) => !!s && typeof s === "object" && (s instanceof Minipass2 || s instanceof Stream2 || isReadable2(s) || isWritable2(s));
var isReadable2 = (s) => !!s && typeof s === "object" && s instanceof EventEmitter3 && typeof s.pipe === "function" && s.pipe !== Stream2.Writable.prototype.pipe;
var isWritable2 = (s) => !!s && typeof s === "object" && s instanceof EventEmitter3 && typeof s.write === "function" && typeof s.end === "function";
var EOF2 = Symbol("EOF");
var MAYBE_EMIT_END2 = Symbol("maybeEmitEnd");
var EMITTED_END2 = Symbol("emittedEnd");
var EMITTING_END2 = Symbol("emittingEnd");
var EMITTED_ERROR2 = Symbol("emittedError");
var CLOSED2 = Symbol("closed");
var READ2 = Symbol("read");
var FLUSH2 = Symbol("flush");
var FLUSHCHUNK2 = Symbol("flushChunk");
var ENCODING2 = Symbol("encoding");
var DECODER2 = Symbol("decoder");
var FLOWING2 = Symbol("flowing");
var PAUSED2 = Symbol("paused");
var RESUME2 = Symbol("resume");
var BUFFER2 = Symbol("buffer");
var PIPES2 = Symbol("pipes");
var BUFFERLENGTH2 = Symbol("bufferLength");
var BUFFERPUSH2 = Symbol("bufferPush");
var BUFFERSHIFT2 = Symbol("bufferShift");
var OBJECTMODE2 = Symbol("objectMode");
var DESTROYED2 = Symbol("destroyed");
var ERROR2 = Symbol("error");
var EMITDATA2 = Symbol("emitData");
var EMITEND3 = Symbol("emitEnd");
var EMITEND22 = Symbol("emitEnd2");
var ASYNC2 = Symbol("async");
var ABORT2 = Symbol("abort");
var ABORTED2 = Symbol("aborted");
var SIGNAL2 = Symbol("signal");
var DATALISTENERS2 = Symbol("dataListeners");
var DISCARDED2 = Symbol("discarded");
var defer2 = (fn) => Promise.resolve().then(fn);
var nodefer2 = (fn) => fn();
var isEndish2 = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
var isArrayBufferLike2 = (b3) => b3 instanceof ArrayBuffer || !!b3 && typeof b3 === "object" && b3.constructor && b3.constructor.name === "ArrayBuffer" && b3.byteLength >= 0;
var isArrayBufferView2 = (b3) => !Buffer.isBuffer(b3) && ArrayBuffer.isView(b3);

class Pipe2 {
  src;
  dest;
  opts;
  ondrain;
  constructor(src, dest, opts) {
    this.src = src;
    this.dest = dest;
    this.opts = opts;
    this.ondrain = () => src[RESUME2]();
    this.dest.on("drain", this.ondrain);
  }
  unpipe() {
    this.dest.removeListener("drain", this.ondrain);
  }
  proxyErrors(_er) {}
  end() {
    this.unpipe();
    if (this.opts.end)
      this.dest.end();
  }
}

class PipeProxyErrors2 extends Pipe2 {
  unpipe() {
    this.src.removeListener("error", this.proxyErrors);
    super.unpipe();
  }
  constructor(src, dest, opts) {
    super(src, dest, opts);
    this.proxyErrors = (er) => dest.emit("error", er);
    src.on("error", this.proxyErrors);
  }
}
var isObjectModeOptions2 = (o2) => !!o2.objectMode;
var isEncodingOptions2 = (o2) => !o2.objectMode && !!o2.encoding && o2.encoding !== "buffer";

class Minipass2 extends EventEmitter3 {
  [FLOWING2] = false;
  [PAUSED2] = false;
  [PIPES2] = [];
  [BUFFER2] = [];
  [OBJECTMODE2];
  [ENCODING2];
  [ASYNC2];
  [DECODER2];
  [EOF2] = false;
  [EMITTED_END2] = false;
  [EMITTING_END2] = false;
  [CLOSED2] = false;
  [EMITTED_ERROR2] = null;
  [BUFFERLENGTH2] = 0;
  [DESTROYED2] = false;
  [SIGNAL2];
  [ABORTED2] = false;
  [DATALISTENERS2] = 0;
  [DISCARDED2] = false;
  writable = true;
  readable = true;
  constructor(...args) {
    const options = args[0] || {};
    super();
    if (options.objectMode && typeof options.encoding === "string") {
      throw new TypeError("Encoding and objectMode may not be used together");
    }
    if (isObjectModeOptions2(options)) {
      this[OBJECTMODE2] = true;
      this[ENCODING2] = null;
    } else if (isEncodingOptions2(options)) {
      this[ENCODING2] = options.encoding;
      this[OBJECTMODE2] = false;
    } else {
      this[OBJECTMODE2] = false;
      this[ENCODING2] = null;
    }
    this[ASYNC2] = !!options.async;
    this[DECODER2] = this[ENCODING2] ? new StringDecoder2(this[ENCODING2]) : null;
    if (options && options.debugExposeBuffer === true) {
      Object.defineProperty(this, "buffer", { get: () => this[BUFFER2] });
    }
    if (options && options.debugExposePipes === true) {
      Object.defineProperty(this, "pipes", { get: () => this[PIPES2] });
    }
    const { signal } = options;
    if (signal) {
      this[SIGNAL2] = signal;
      if (signal.aborted) {
        this[ABORT2]();
      } else {
        signal.addEventListener("abort", () => this[ABORT2]());
      }
    }
  }
  get bufferLength() {
    return this[BUFFERLENGTH2];
  }
  get encoding() {
    return this[ENCODING2];
  }
  set encoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  setEncoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  get objectMode() {
    return this[OBJECTMODE2];
  }
  set objectMode(_om) {
    throw new Error("objectMode must be set at instantiation time");
  }
  get ["async"]() {
    return this[ASYNC2];
  }
  set ["async"](a3) {
    this[ASYNC2] = this[ASYNC2] || !!a3;
  }
  [ABORT2]() {
    this[ABORTED2] = true;
    this.emit("abort", this[SIGNAL2]?.reason);
    this.destroy(this[SIGNAL2]?.reason);
  }
  get aborted() {
    return this[ABORTED2];
  }
  set aborted(_3) {}
  write(chunk, encoding, cb) {
    if (this[ABORTED2])
      return false;
    if (this[EOF2])
      throw new Error("write after end");
    if (this[DESTROYED2]) {
      this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
      return true;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = "utf8";
    }
    if (!encoding)
      encoding = "utf8";
    const fn = this[ASYNC2] ? defer2 : nodefer2;
    if (!this[OBJECTMODE2] && !Buffer.isBuffer(chunk)) {
      if (isArrayBufferView2(chunk)) {
        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
      } else if (isArrayBufferLike2(chunk)) {
        chunk = Buffer.from(chunk);
      } else if (typeof chunk !== "string") {
        throw new Error("Non-contiguous data written to non-objectMode stream");
      }
    }
    if (this[OBJECTMODE2]) {
      if (this[FLOWING2] && this[BUFFERLENGTH2] !== 0)
        this[FLUSH2](true);
      if (this[FLOWING2])
        this.emit("data", chunk);
      else
        this[BUFFERPUSH2](chunk);
      if (this[BUFFERLENGTH2] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING2];
    }
    if (!chunk.length) {
      if (this[BUFFERLENGTH2] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING2];
    }
    if (typeof chunk === "string" && !(encoding === this[ENCODING2] && !this[DECODER2]?.lastNeed)) {
      chunk = Buffer.from(chunk, encoding);
    }
    if (Buffer.isBuffer(chunk) && this[ENCODING2]) {
      chunk = this[DECODER2].write(chunk);
    }
    if (this[FLOWING2] && this[BUFFERLENGTH2] !== 0)
      this[FLUSH2](true);
    if (this[FLOWING2])
      this.emit("data", chunk);
    else
      this[BUFFERPUSH2](chunk);
    if (this[BUFFERLENGTH2] !== 0)
      this.emit("readable");
    if (cb)
      fn(cb);
    return this[FLOWING2];
  }
  read(n) {
    if (this[DESTROYED2])
      return null;
    this[DISCARDED2] = false;
    if (this[BUFFERLENGTH2] === 0 || n === 0 || n && n > this[BUFFERLENGTH2]) {
      this[MAYBE_EMIT_END2]();
      return null;
    }
    if (this[OBJECTMODE2])
      n = null;
    if (this[BUFFER2].length > 1 && !this[OBJECTMODE2]) {
      this[BUFFER2] = [
        this[ENCODING2] ? this[BUFFER2].join("") : Buffer.concat(this[BUFFER2], this[BUFFERLENGTH2])
      ];
    }
    const ret = this[READ2](n || null, this[BUFFER2][0]);
    this[MAYBE_EMIT_END2]();
    return ret;
  }
  [READ2](n, chunk) {
    if (this[OBJECTMODE2])
      this[BUFFERSHIFT2]();
    else {
      const c2 = chunk;
      if (n === c2.length || n === null)
        this[BUFFERSHIFT2]();
      else if (typeof c2 === "string") {
        this[BUFFER2][0] = c2.slice(n);
        chunk = c2.slice(0, n);
        this[BUFFERLENGTH2] -= n;
      } else {
        this[BUFFER2][0] = c2.subarray(n);
        chunk = c2.subarray(0, n);
        this[BUFFERLENGTH2] -= n;
      }
    }
    this.emit("data", chunk);
    if (!this[BUFFER2].length && !this[EOF2])
      this.emit("drain");
    return chunk;
  }
  end(chunk, encoding, cb) {
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = undefined;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = "utf8";
    }
    if (chunk !== undefined)
      this.write(chunk, encoding);
    if (cb)
      this.once("end", cb);
    this[EOF2] = true;
    this.writable = false;
    if (this[FLOWING2] || !this[PAUSED2])
      this[MAYBE_EMIT_END2]();
    return this;
  }
  [RESUME2]() {
    if (this[DESTROYED2])
      return;
    if (!this[DATALISTENERS2] && !this[PIPES2].length) {
      this[DISCARDED2] = true;
    }
    this[PAUSED2] = false;
    this[FLOWING2] = true;
    this.emit("resume");
    if (this[BUFFER2].length)
      this[FLUSH2]();
    else if (this[EOF2])
      this[MAYBE_EMIT_END2]();
    else
      this.emit("drain");
  }
  resume() {
    return this[RESUME2]();
  }
  pause() {
    this[FLOWING2] = false;
    this[PAUSED2] = true;
    this[DISCARDED2] = false;
  }
  get destroyed() {
    return this[DESTROYED2];
  }
  get flowing() {
    return this[FLOWING2];
  }
  get paused() {
    return this[PAUSED2];
  }
  [BUFFERPUSH2](chunk) {
    if (this[OBJECTMODE2])
      this[BUFFERLENGTH2] += 1;
    else
      this[BUFFERLENGTH2] += chunk.length;
    this[BUFFER2].push(chunk);
  }
  [BUFFERSHIFT2]() {
    if (this[OBJECTMODE2])
      this[BUFFERLENGTH2] -= 1;
    else
      this[BUFFERLENGTH2] -= this[BUFFER2][0].length;
    return this[BUFFER2].shift();
  }
  [FLUSH2](noDrain = false) {
    do {} while (this[FLUSHCHUNK2](this[BUFFERSHIFT2]()) && this[BUFFER2].length);
    if (!noDrain && !this[BUFFER2].length && !this[EOF2])
      this.emit("drain");
  }
  [FLUSHCHUNK2](chunk) {
    this.emit("data", chunk);
    return this[FLOWING2];
  }
  pipe(dest, opts) {
    if (this[DESTROYED2])
      return dest;
    this[DISCARDED2] = false;
    const ended = this[EMITTED_END2];
    opts = opts || {};
    if (dest === proc2.stdout || dest === proc2.stderr)
      opts.end = false;
    else
      opts.end = opts.end !== false;
    opts.proxyErrors = !!opts.proxyErrors;
    if (ended) {
      if (opts.end)
        dest.end();
    } else {
      this[PIPES2].push(!opts.proxyErrors ? new Pipe2(this, dest, opts) : new PipeProxyErrors2(this, dest, opts));
      if (this[ASYNC2])
        defer2(() => this[RESUME2]());
      else
        this[RESUME2]();
    }
    return dest;
  }
  unpipe(dest) {
    const p = this[PIPES2].find((p2) => p2.dest === dest);
    if (p) {
      if (this[PIPES2].length === 1) {
        if (this[FLOWING2] && this[DATALISTENERS2] === 0) {
          this[FLOWING2] = false;
        }
        this[PIPES2] = [];
      } else
        this[PIPES2].splice(this[PIPES2].indexOf(p), 1);
      p.unpipe();
    }
  }
  addListener(ev, handler) {
    return this.on(ev, handler);
  }
  on(ev, handler) {
    const ret = super.on(ev, handler);
    if (ev === "data") {
      this[DISCARDED2] = false;
      this[DATALISTENERS2]++;
      if (!this[PIPES2].length && !this[FLOWING2]) {
        this[RESUME2]();
      }
    } else if (ev === "readable" && this[BUFFERLENGTH2] !== 0) {
      super.emit("readable");
    } else if (isEndish2(ev) && this[EMITTED_END2]) {
      super.emit(ev);
      this.removeAllListeners(ev);
    } else if (ev === "error" && this[EMITTED_ERROR2]) {
      const h2 = handler;
      if (this[ASYNC2])
        defer2(() => h2.call(this, this[EMITTED_ERROR2]));
      else
        h2.call(this, this[EMITTED_ERROR2]);
    }
    return ret;
  }
  removeListener(ev, handler) {
    return this.off(ev, handler);
  }
  off(ev, handler) {
    const ret = super.off(ev, handler);
    if (ev === "data") {
      this[DATALISTENERS2] = this.listeners("data").length;
      if (this[DATALISTENERS2] === 0 && !this[DISCARDED2] && !this[PIPES2].length) {
        this[FLOWING2] = false;
      }
    }
    return ret;
  }
  removeAllListeners(ev) {
    const ret = super.removeAllListeners(ev);
    if (ev === "data" || ev === undefined) {
      this[DATALISTENERS2] = 0;
      if (!this[DISCARDED2] && !this[PIPES2].length) {
        this[FLOWING2] = false;
      }
    }
    return ret;
  }
  get emittedEnd() {
    return this[EMITTED_END2];
  }
  [MAYBE_EMIT_END2]() {
    if (!this[EMITTING_END2] && !this[EMITTED_END2] && !this[DESTROYED2] && this[BUFFER2].length === 0 && this[EOF2]) {
      this[EMITTING_END2] = true;
      this.emit("end");
      this.emit("prefinish");
      this.emit("finish");
      if (this[CLOSED2])
        this.emit("close");
      this[EMITTING_END2] = false;
    }
  }
  emit(ev, ...args) {
    const data = args[0];
    if (ev !== "error" && ev !== "close" && ev !== DESTROYED2 && this[DESTROYED2]) {
      return false;
    } else if (ev === "data") {
      return !this[OBJECTMODE2] && !data ? false : this[ASYNC2] ? (defer2(() => this[EMITDATA2](data)), true) : this[EMITDATA2](data);
    } else if (ev === "end") {
      return this[EMITEND3]();
    } else if (ev === "close") {
      this[CLOSED2] = true;
      if (!this[EMITTED_END2] && !this[DESTROYED2])
        return false;
      const ret2 = super.emit("close");
      this.removeAllListeners("close");
      return ret2;
    } else if (ev === "error") {
      this[EMITTED_ERROR2] = data;
      super.emit(ERROR2, data);
      const ret2 = !this[SIGNAL2] || this.listeners("error").length ? super.emit("error", data) : false;
      this[MAYBE_EMIT_END2]();
      return ret2;
    } else if (ev === "resume") {
      const ret2 = super.emit("resume");
      this[MAYBE_EMIT_END2]();
      return ret2;
    } else if (ev === "finish" || ev === "prefinish") {
      const ret2 = super.emit(ev);
      this.removeAllListeners(ev);
      return ret2;
    }
    const ret = super.emit(ev, ...args);
    this[MAYBE_EMIT_END2]();
    return ret;
  }
  [EMITDATA2](data) {
    for (const p of this[PIPES2]) {
      if (p.dest.write(data) === false)
        this.pause();
    }
    const ret = this[DISCARDED2] ? false : super.emit("data", data);
    this[MAYBE_EMIT_END2]();
    return ret;
  }
  [EMITEND3]() {
    if (this[EMITTED_END2])
      return false;
    this[EMITTED_END2] = true;
    this.readable = false;
    return this[ASYNC2] ? (defer2(() => this[EMITEND22]()), true) : this[EMITEND22]();
  }
  [EMITEND22]() {
    if (this[DECODER2]) {
      const data = this[DECODER2].end();
      if (data) {
        for (const p of this[PIPES2]) {
          p.dest.write(data);
        }
        if (!this[DISCARDED2])
          super.emit("data", data);
      }
    }
    for (const p of this[PIPES2]) {
      p.end();
    }
    const ret = super.emit("end");
    this.removeAllListeners("end");
    return ret;
  }
  async collect() {
    const buf = Object.assign([], {
      dataLength: 0
    });
    if (!this[OBJECTMODE2])
      buf.dataLength = 0;
    const p = this.promise();
    this.on("data", (c2) => {
      buf.push(c2);
      if (!this[OBJECTMODE2])
        buf.dataLength += c2.length;
    });
    await p;
    return buf;
  }
  async concat() {
    if (this[OBJECTMODE2]) {
      throw new Error("cannot concat in objectMode");
    }
    const buf = await this.collect();
    return this[ENCODING2] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
  }
  async promise() {
    return new Promise((resolve5, reject) => {
      this.on(DESTROYED2, () => reject(new Error("stream destroyed")));
      this.on("error", (er) => reject(er));
      this.on("end", () => resolve5());
    });
  }
  [Symbol.asyncIterator]() {
    this[DISCARDED2] = false;
    let stopped = false;
    const stop = async () => {
      this.pause();
      stopped = true;
      return { value: undefined, done: true };
    };
    const next = () => {
      if (stopped)
        return stop();
      const res = this.read();
      if (res !== null)
        return Promise.resolve({ done: false, value: res });
      if (this[EOF2])
        return stop();
      let resolve5;
      let reject;
      const onerr = (er) => {
        this.off("data", ondata);
        this.off("end", onend);
        this.off(DESTROYED2, ondestroy);
        stop();
        reject(er);
      };
      const ondata = (value) => {
        this.off("error", onerr);
        this.off("end", onend);
        this.off(DESTROYED2, ondestroy);
        this.pause();
        resolve5({ value, done: !!this[EOF2] });
      };
      const onend = () => {
        this.off("error", onerr);
        this.off("data", ondata);
        this.off(DESTROYED2, ondestroy);
        stop();
        resolve5({ done: true, value: undefined });
      };
      const ondestroy = () => onerr(new Error("stream destroyed"));
      return new Promise((res2, rej) => {
        reject = rej;
        resolve5 = res2;
        this.once(DESTROYED2, ondestroy);
        this.once("error", onerr);
        this.once("end", onend);
        this.once("data", ondata);
      });
    };
    return {
      next,
      throw: stop,
      return: stop,
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  [Symbol.iterator]() {
    this[DISCARDED2] = false;
    let stopped = false;
    const stop = () => {
      this.pause();
      this.off(ERROR2, stop);
      this.off(DESTROYED2, stop);
      this.off("end", stop);
      stopped = true;
      return { done: true, value: undefined };
    };
    const next = () => {
      if (stopped)
        return stop();
      const value = this.read();
      return value === null ? stop() : { done: false, value };
    };
    this.once("end", stop);
    this.once(ERROR2, stop);
    this.once(DESTROYED2, stop);
    return {
      next,
      throw: stop,
      return: stop,
      [Symbol.iterator]() {
        return this;
      }
    };
  }
  destroy(er) {
    if (this[DESTROYED2]) {
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED2);
      return this;
    }
    this[DESTROYED2] = true;
    this[DISCARDED2] = true;
    this[BUFFER2].length = 0;
    this[BUFFERLENGTH2] = 0;
    const wc = this;
    if (typeof wc.close === "function" && !this[CLOSED2])
      wc.close();
    if (er)
      this.emit("error", er);
    else
      this.emit(DESTROYED2);
    return this;
  }
  static get isStream() {
    return isStream2;
  }
}

// node_modules/minizlib/dist/esm/index.js
import * as realZlib2 from "zlib";

// node_modules/minizlib/dist/esm/constants.js
import realZlib from "zlib";
var realZlibConstants = realZlib.constants || { ZLIB_VERNUM: 4736 };
var constants4 = Object.freeze(Object.assign(Object.create(null), {
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_VERSION_ERROR: -6,
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  DEFLATE: 1,
  INFLATE: 2,
  GZIP: 3,
  GUNZIP: 4,
  DEFLATERAW: 5,
  INFLATERAW: 6,
  UNZIP: 7,
  BROTLI_DECODE: 8,
  BROTLI_ENCODE: 9,
  Z_MIN_WINDOWBITS: 8,
  Z_MAX_WINDOWBITS: 15,
  Z_DEFAULT_WINDOWBITS: 15,
  Z_MIN_CHUNK: 64,
  Z_MAX_CHUNK: Infinity,
  Z_DEFAULT_CHUNK: 16384,
  Z_MIN_MEMLEVEL: 1,
  Z_MAX_MEMLEVEL: 9,
  Z_DEFAULT_MEMLEVEL: 8,
  Z_MIN_LEVEL: -1,
  Z_MAX_LEVEL: 9,
  Z_DEFAULT_LEVEL: -1,
  BROTLI_OPERATION_PROCESS: 0,
  BROTLI_OPERATION_FLUSH: 1,
  BROTLI_OPERATION_FINISH: 2,
  BROTLI_OPERATION_EMIT_METADATA: 3,
  BROTLI_MODE_GENERIC: 0,
  BROTLI_MODE_TEXT: 1,
  BROTLI_MODE_FONT: 2,
  BROTLI_DEFAULT_MODE: 0,
  BROTLI_MIN_QUALITY: 0,
  BROTLI_MAX_QUALITY: 11,
  BROTLI_DEFAULT_QUALITY: 11,
  BROTLI_MIN_WINDOW_BITS: 10,
  BROTLI_MAX_WINDOW_BITS: 24,
  BROTLI_LARGE_MAX_WINDOW_BITS: 30,
  BROTLI_DEFAULT_WINDOW: 22,
  BROTLI_MIN_INPUT_BLOCK_BITS: 16,
  BROTLI_MAX_INPUT_BLOCK_BITS: 24,
  BROTLI_PARAM_MODE: 0,
  BROTLI_PARAM_QUALITY: 1,
  BROTLI_PARAM_LGWIN: 2,
  BROTLI_PARAM_LGBLOCK: 3,
  BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
  BROTLI_PARAM_SIZE_HINT: 5,
  BROTLI_PARAM_LARGE_WINDOW: 6,
  BROTLI_PARAM_NPOSTFIX: 7,
  BROTLI_PARAM_NDIRECT: 8,
  BROTLI_DECODER_RESULT_ERROR: 0,
  BROTLI_DECODER_RESULT_SUCCESS: 1,
  BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
  BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
  BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
  BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
  BROTLI_DECODER_NO_ERROR: 0,
  BROTLI_DECODER_SUCCESS: 1,
  BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
  BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
  BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
  BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
  BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
  BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
  BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
  BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
  BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
  BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
  BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
  BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
  BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
  BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
  BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
  BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
  BROTLI_DECODER_ERROR_UNREACHABLE: -31
}, realZlibConstants));

// node_modules/minizlib/dist/esm/index.js
var OriginalBufferConcat = Buffer2.concat;
var desc = Object.getOwnPropertyDescriptor(Buffer2, "concat");
var noop = (args) => args;
var passthroughBufferConcat = desc?.writable === true || desc?.set !== undefined ? (makeNoOp) => {
  Buffer2.concat = makeNoOp ? noop : OriginalBufferConcat;
} : (_3) => {};
var _superWrite = Symbol("_superWrite");

class ZlibError extends Error {
  code;
  errno;
  constructor(err, origin) {
    super("zlib: " + err.message, { cause: err });
    this.code = err.code;
    this.errno = err.errno;
    if (!this.code)
      this.code = "ZLIB_ERROR";
    this.message = "zlib: " + err.message;
    Error.captureStackTrace(this, origin ?? this.constructor);
  }
  get name() {
    return "ZlibError";
  }
}
var _flushFlag = Symbol("flushFlag");

class ZlibBase extends Minipass2 {
  #sawError = false;
  #ended = false;
  #flushFlag;
  #finishFlushFlag;
  #fullFlushFlag;
  #handle;
  #onError;
  get sawError() {
    return this.#sawError;
  }
  get handle() {
    return this.#handle;
  }
  get flushFlag() {
    return this.#flushFlag;
  }
  constructor(opts, mode) {
    if (!opts || typeof opts !== "object")
      throw new TypeError("invalid options for ZlibBase constructor");
    super(opts);
    this.#flushFlag = opts.flush ?? 0;
    this.#finishFlushFlag = opts.finishFlush ?? 0;
    this.#fullFlushFlag = opts.fullFlushFlag ?? 0;
    if (typeof realZlib2[mode] !== "function") {
      throw new TypeError("Compression method not supported: " + mode);
    }
    try {
      this.#handle = new realZlib2[mode](opts);
    } catch (er) {
      throw new ZlibError(er, this.constructor);
    }
    this.#onError = (err) => {
      if (this.#sawError)
        return;
      this.#sawError = true;
      this.close();
      this.emit("error", err);
    };
    this.#handle?.on("error", (er) => this.#onError(new ZlibError(er)));
    this.once("end", () => this.close);
  }
  close() {
    if (this.#handle) {
      this.#handle.close();
      this.#handle = undefined;
      this.emit("close");
    }
  }
  reset() {
    if (!this.#sawError) {
      assert(this.#handle, "zlib binding closed");
      return this.#handle.reset?.();
    }
  }
  flush(flushFlag) {
    if (this.ended)
      return;
    if (typeof flushFlag !== "number")
      flushFlag = this.#fullFlushFlag;
    this.write(Object.assign(Buffer2.alloc(0), { [_flushFlag]: flushFlag }));
  }
  end(chunk, encoding, cb) {
    if (typeof chunk === "function") {
      cb = chunk;
      encoding = undefined;
      chunk = undefined;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = undefined;
    }
    if (chunk) {
      if (encoding)
        this.write(chunk, encoding);
      else
        this.write(chunk);
    }
    this.flush(this.#finishFlushFlag);
    this.#ended = true;
    return super.end(cb);
  }
  get ended() {
    return this.#ended;
  }
  [_superWrite](data) {
    return super.write(data);
  }
  write(chunk, encoding, cb) {
    if (typeof encoding === "function")
      cb = encoding, encoding = "utf8";
    if (typeof chunk === "string")
      chunk = Buffer2.from(chunk, encoding);
    if (this.#sawError)
      return;
    assert(this.#handle, "zlib binding closed");
    const nativeHandle = this.#handle._handle;
    const originalNativeClose = nativeHandle.close;
    nativeHandle.close = () => {};
    const originalClose = this.#handle.close;
    this.#handle.close = () => {};
    passthroughBufferConcat(true);
    let result = undefined;
    try {
      const flushFlag = typeof chunk[_flushFlag] === "number" ? chunk[_flushFlag] : this.#flushFlag;
      result = this.#handle._processChunk(chunk, flushFlag);
      passthroughBufferConcat(false);
    } catch (err) {
      passthroughBufferConcat(false);
      this.#onError(new ZlibError(err, this.write));
    } finally {
      if (this.#handle) {
        this.#handle._handle = nativeHandle;
        nativeHandle.close = originalNativeClose;
        this.#handle.close = originalClose;
        this.#handle.removeAllListeners("error");
      }
    }
    if (this.#handle)
      this.#handle.on("error", (er) => this.#onError(new ZlibError(er, this.write)));
    let writeReturn;
    if (result) {
      if (Array.isArray(result) && result.length > 0) {
        const r2 = result[0];
        writeReturn = this[_superWrite](Buffer2.from(r2));
        for (let i = 1;i < result.length; i++) {
          writeReturn = this[_superWrite](result[i]);
        }
      } else {
        writeReturn = this[_superWrite](Buffer2.from(result));
      }
    }
    if (cb)
      cb();
    return writeReturn;
  }
}

class Zlib extends ZlibBase {
  #level;
  #strategy;
  constructor(opts, mode) {
    opts = opts || {};
    opts.flush = opts.flush || constants4.Z_NO_FLUSH;
    opts.finishFlush = opts.finishFlush || constants4.Z_FINISH;
    opts.fullFlushFlag = constants4.Z_FULL_FLUSH;
    super(opts, mode);
    this.#level = opts.level;
    this.#strategy = opts.strategy;
  }
  params(level, strategy) {
    if (this.sawError)
      return;
    if (!this.handle)
      throw new Error("cannot switch params when binding is closed");
    if (!this.handle.params)
      throw new Error("not supported in this implementation");
    if (this.#level !== level || this.#strategy !== strategy) {
      this.flush(constants4.Z_SYNC_FLUSH);
      assert(this.handle, "zlib binding closed");
      const origFlush = this.handle.flush;
      this.handle.flush = (flushFlag, cb) => {
        if (typeof flushFlag === "function") {
          cb = flushFlag;
          flushFlag = this.flushFlag;
        }
        this.flush(flushFlag);
        cb?.();
      };
      try {
        this.handle.params(level, strategy);
      } finally {
        this.handle.flush = origFlush;
      }
      if (this.handle) {
        this.#level = level;
        this.#strategy = strategy;
      }
    }
  }
}
class Gzip extends Zlib {
  #portable;
  constructor(opts) {
    super(opts, "Gzip");
    this.#portable = opts && !!opts.portable;
  }
  [_superWrite](data) {
    if (!this.#portable)
      return super[_superWrite](data);
    this.#portable = false;
    data[9] = 255;
    return super[_superWrite](data);
  }
}
class Unzip extends Zlib {
  constructor(opts) {
    super(opts, "Unzip");
  }
}

class Brotli extends ZlibBase {
  constructor(opts, mode) {
    opts = opts || {};
    opts.flush = opts.flush || constants4.BROTLI_OPERATION_PROCESS;
    opts.finishFlush = opts.finishFlush || constants4.BROTLI_OPERATION_FINISH;
    opts.fullFlushFlag = constants4.BROTLI_OPERATION_FLUSH;
    super(opts, mode);
  }
}

class BrotliCompress extends Brotli {
  constructor(opts) {
    super(opts, "BrotliCompress");
  }
}

class BrotliDecompress extends Brotli {
  constructor(opts) {
    super(opts, "BrotliDecompress");
  }
}

class Zstd extends ZlibBase {
  constructor(opts, mode) {
    opts = opts || {};
    opts.flush = opts.flush || constants4.ZSTD_e_continue;
    opts.finishFlush = opts.finishFlush || constants4.ZSTD_e_end;
    opts.fullFlushFlag = constants4.ZSTD_e_flush;
    super(opts, mode);
  }
}

class ZstdCompress extends Zstd {
  constructor(opts) {
    super(opts, "ZstdCompress");
  }
}

class ZstdDecompress extends Zstd {
  constructor(opts) {
    super(opts, "ZstdDecompress");
  }
}

// node_modules/tar/dist/esm/header.js
import { posix as pathModule } from "node:path";

// node_modules/tar/dist/esm/large-numbers.js
var encode = (num, buf) => {
  if (!Number.isSafeInteger(num)) {
    throw Error("cannot encode number outside of javascript safe integer range");
  } else if (num < 0) {
    encodeNegative(num, buf);
  } else {
    encodePositive(num, buf);
  }
  return buf;
};
var encodePositive = (num, buf) => {
  buf[0] = 128;
  for (var i = buf.length;i > 1; i--) {
    buf[i - 1] = num & 255;
    num = Math.floor(num / 256);
  }
};
var encodeNegative = (num, buf) => {
  buf[0] = 255;
  var flipped = false;
  num = num * -1;
  for (var i = buf.length;i > 1; i--) {
    var byte = num & 255;
    num = Math.floor(num / 256);
    if (flipped) {
      buf[i - 1] = onesComp(byte);
    } else if (byte === 0) {
      buf[i - 1] = 0;
    } else {
      flipped = true;
      buf[i - 1] = twosComp(byte);
    }
  }
};
var parse = (buf) => {
  const pre = buf[0];
  const value = pre === 128 ? pos(buf.subarray(1, buf.length)) : pre === 255 ? twos(buf) : null;
  if (value === null) {
    throw Error("invalid base256 encoding");
  }
  if (!Number.isSafeInteger(value)) {
    throw Error("parsed number outside of javascript safe integer range");
  }
  return value;
};
var twos = (buf) => {
  var len = buf.length;
  var sum = 0;
  var flipped = false;
  for (var i = len - 1;i > -1; i--) {
    var byte = Number(buf[i]);
    var f3;
    if (flipped) {
      f3 = onesComp(byte);
    } else if (byte === 0) {
      f3 = byte;
    } else {
      flipped = true;
      f3 = twosComp(byte);
    }
    if (f3 !== 0) {
      sum -= f3 * Math.pow(256, len - i - 1);
    }
  }
  return sum;
};
var pos = (buf) => {
  var len = buf.length;
  var sum = 0;
  for (var i = len - 1;i > -1; i--) {
    var byte = Number(buf[i]);
    if (byte !== 0) {
      sum += byte * Math.pow(256, len - i - 1);
    }
  }
  return sum;
};
var onesComp = (byte) => (255 ^ byte) & 255;
var twosComp = (byte) => (255 ^ byte) + 1 & 255;

// node_modules/tar/dist/esm/types.js
var isCode = (c2) => name.has(c2);
var name = new Map([
  ["0", "File"],
  ["", "OldFile"],
  ["1", "Link"],
  ["2", "SymbolicLink"],
  ["3", "CharacterDevice"],
  ["4", "BlockDevice"],
  ["5", "Directory"],
  ["6", "FIFO"],
  ["7", "ContiguousFile"],
  ["g", "GlobalExtendedHeader"],
  ["x", "ExtendedHeader"],
  ["A", "SolarisACL"],
  ["D", "GNUDumpDir"],
  ["I", "Inode"],
  ["K", "NextFileHasLongLinkpath"],
  ["L", "NextFileHasLongPath"],
  ["M", "ContinuationFile"],
  ["N", "OldGnuLongPath"],
  ["S", "SparseFile"],
  ["V", "TapeVolumeHeader"],
  ["X", "OldExtendedHeader"]
]);
var code = new Map(Array.from(name).map((kv) => [kv[1], kv[0]]));

// node_modules/tar/dist/esm/header.js
class Header {
  cksumValid = false;
  needPax = false;
  nullBlock = false;
  block;
  path;
  mode;
  uid;
  gid;
  size;
  cksum;
  #type = "Unsupported";
  linkpath;
  uname;
  gname;
  devmaj = 0;
  devmin = 0;
  atime;
  ctime;
  mtime;
  charset;
  comment;
  constructor(data, off = 0, ex, gex) {
    if (Buffer.isBuffer(data)) {
      this.decode(data, off || 0, ex, gex);
    } else if (data) {
      this.#slurp(data);
    }
  }
  decode(buf, off, ex, gex) {
    if (!off) {
      off = 0;
    }
    if (!buf || !(buf.length >= off + 512)) {
      throw new Error("need 512 bytes for header");
    }
    this.path = ex?.path ?? decString(buf, off, 100);
    this.mode = ex?.mode ?? gex?.mode ?? decNumber(buf, off + 100, 8);
    this.uid = ex?.uid ?? gex?.uid ?? decNumber(buf, off + 108, 8);
    this.gid = ex?.gid ?? gex?.gid ?? decNumber(buf, off + 116, 8);
    this.size = ex?.size ?? gex?.size ?? decNumber(buf, off + 124, 12);
    this.mtime = ex?.mtime ?? gex?.mtime ?? decDate(buf, off + 136, 12);
    this.cksum = decNumber(buf, off + 148, 12);
    if (gex)
      this.#slurp(gex, true);
    if (ex)
      this.#slurp(ex);
    const t = decString(buf, off + 156, 1);
    if (isCode(t)) {
      this.#type = t || "0";
    }
    if (this.#type === "0" && this.path.slice(-1) === "/") {
      this.#type = "5";
    }
    if (this.#type === "5") {
      this.size = 0;
    }
    this.linkpath = decString(buf, off + 157, 100);
    if (buf.subarray(off + 257, off + 265).toString() === "ustar\x0000") {
      this.uname = ex?.uname ?? gex?.uname ?? decString(buf, off + 265, 32);
      this.gname = ex?.gname ?? gex?.gname ?? decString(buf, off + 297, 32);
      this.devmaj = ex?.devmaj ?? gex?.devmaj ?? decNumber(buf, off + 329, 8) ?? 0;
      this.devmin = ex?.devmin ?? gex?.devmin ?? decNumber(buf, off + 337, 8) ?? 0;
      if (buf[off + 475] !== 0) {
        const prefix = decString(buf, off + 345, 155);
        this.path = prefix + "/" + this.path;
      } else {
        const prefix = decString(buf, off + 345, 130);
        if (prefix) {
          this.path = prefix + "/" + this.path;
        }
        this.atime = ex?.atime ?? gex?.atime ?? decDate(buf, off + 476, 12);
        this.ctime = ex?.ctime ?? gex?.ctime ?? decDate(buf, off + 488, 12);
      }
    }
    let sum = 8 * 32;
    for (let i = off;i < off + 148; i++) {
      sum += buf[i];
    }
    for (let i = off + 156;i < off + 512; i++) {
      sum += buf[i];
    }
    this.cksumValid = sum === this.cksum;
    if (this.cksum === undefined && sum === 8 * 32) {
      this.nullBlock = true;
    }
  }
  #slurp(ex, gex = false) {
    Object.assign(this, Object.fromEntries(Object.entries(ex).filter(([k2, v2]) => {
      return !(v2 === null || v2 === undefined || k2 === "path" && gex || k2 === "linkpath" && gex || k2 === "global");
    })));
  }
  encode(buf, off = 0) {
    if (!buf) {
      buf = this.block = Buffer.alloc(512);
    }
    if (this.#type === "Unsupported") {
      this.#type = "0";
    }
    if (!(buf.length >= off + 512)) {
      throw new Error("need 512 bytes for header");
    }
    const prefixSize = this.ctime || this.atime ? 130 : 155;
    const split = splitPrefix(this.path || "", prefixSize);
    const path2 = split[0];
    const prefix = split[1];
    this.needPax = !!split[2];
    this.needPax = encString(buf, off, 100, path2) || this.needPax;
    this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax;
    this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax;
    this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax;
    this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax;
    this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax;
    buf[off + 156] = this.#type.charCodeAt(0);
    this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax;
    buf.write("ustar\x0000", off + 257, 8);
    this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax;
    this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax;
    this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax;
    this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax;
    this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax;
    if (buf[off + 475] !== 0) {
      this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax;
    } else {
      this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax;
      this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax;
      this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax;
    }
    let sum = 8 * 32;
    for (let i = off;i < off + 148; i++) {
      sum += buf[i];
    }
    for (let i = off + 156;i < off + 512; i++) {
      sum += buf[i];
    }
    this.cksum = sum;
    encNumber(buf, off + 148, 8, this.cksum);
    this.cksumValid = true;
    return this.needPax;
  }
  get type() {
    return this.#type === "Unsupported" ? this.#type : name.get(this.#type);
  }
  get typeKey() {
    return this.#type;
  }
  set type(type) {
    const c2 = String(code.get(type));
    if (isCode(c2) || c2 === "Unsupported") {
      this.#type = c2;
    } else if (isCode(type)) {
      this.#type = type;
    } else {
      throw new TypeError("invalid entry type: " + type);
    }
  }
}
var splitPrefix = (p, prefixSize) => {
  const pathSize = 100;
  let pp = p;
  let prefix = "";
  let ret = undefined;
  const root = pathModule.parse(p).root || ".";
  if (Buffer.byteLength(pp) < pathSize) {
    ret = [pp, prefix, false];
  } else {
    prefix = pathModule.dirname(pp);
    pp = pathModule.basename(pp);
    do {
      if (Buffer.byteLength(pp) <= pathSize && Buffer.byteLength(prefix) <= prefixSize) {
        ret = [pp, prefix, false];
      } else if (Buffer.byteLength(pp) > pathSize && Buffer.byteLength(prefix) <= prefixSize) {
        ret = [pp.slice(0, pathSize - 1), prefix, true];
      } else {
        pp = pathModule.join(pathModule.basename(prefix), pp);
        prefix = pathModule.dirname(prefix);
      }
    } while (prefix !== root && ret === undefined);
    if (!ret) {
      ret = [p.slice(0, pathSize - 1), "", true];
    }
  }
  return ret;
};
var decString = (buf, off, size) => buf.subarray(off, off + size).toString("utf8").replace(/\0.*/, "");
var decDate = (buf, off, size) => numToDate(decNumber(buf, off, size));
var numToDate = (num) => num === undefined ? undefined : new Date(num * 1000);
var decNumber = (buf, off, size) => Number(buf[off]) & 128 ? parse(buf.subarray(off, off + size)) : decSmallNumber(buf, off, size);
var nanUndef = (value) => isNaN(value) ? undefined : value;
var decSmallNumber = (buf, off, size) => nanUndef(parseInt(buf.subarray(off, off + size).toString("utf8").replace(/\0.*$/, "").trim(), 8));
var MAXNUM = {
  12: 8589934591,
  8: 2097151
};
var encNumber = (buf, off, size, num) => num === undefined ? false : num > MAXNUM[size] || num < 0 ? (encode(num, buf.subarray(off, off + size)), true) : (encSmallNumber(buf, off, size, num), false);
var encSmallNumber = (buf, off, size, num) => buf.write(octalString(num, size), off, size, "ascii");
var octalString = (num, size) => padOctal(Math.floor(num).toString(8), size);
var padOctal = (str, size) => (str.length === size - 1 ? str : new Array(size - str.length - 1).join("0") + str + " ") + "\x00";
var encDate = (buf, off, size, date) => date === undefined ? false : encNumber(buf, off, size, date.getTime() / 1000);
var NULLS = new Array(156).join("\x00");
var encString = (buf, off, size, str) => str === undefined ? false : (buf.write(str + NULLS, off, size, "utf8"), str.length !== Buffer.byteLength(str) || str.length > size);

// node_modules/tar/dist/esm/pax.js
import { basename } from "node:path";
class Pax {
  atime;
  mtime;
  ctime;
  charset;
  comment;
  gid;
  uid;
  gname;
  uname;
  linkpath;
  dev;
  ino;
  nlink;
  path;
  size;
  mode;
  global;
  constructor(obj, global3 = false) {
    this.atime = obj.atime;
    this.charset = obj.charset;
    this.comment = obj.comment;
    this.ctime = obj.ctime;
    this.dev = obj.dev;
    this.gid = obj.gid;
    this.global = global3;
    this.gname = obj.gname;
    this.ino = obj.ino;
    this.linkpath = obj.linkpath;
    this.mtime = obj.mtime;
    this.nlink = obj.nlink;
    this.path = obj.path;
    this.size = obj.size;
    this.uid = obj.uid;
    this.uname = obj.uname;
  }
  encode() {
    const body = this.encodeBody();
    if (body === "") {
      return Buffer.allocUnsafe(0);
    }
    const bodyLen = Buffer.byteLength(body);
    const bufLen = 512 * Math.ceil(1 + bodyLen / 512);
    const buf = Buffer.allocUnsafe(bufLen);
    for (let i = 0;i < 512; i++) {
      buf[i] = 0;
    }
    new Header({
      path: ("PaxHeader/" + basename(this.path ?? "")).slice(0, 99),
      mode: this.mode || 420,
      uid: this.uid,
      gid: this.gid,
      size: bodyLen,
      mtime: this.mtime,
      type: this.global ? "GlobalExtendedHeader" : "ExtendedHeader",
      linkpath: "",
      uname: this.uname || "",
      gname: this.gname || "",
      devmaj: 0,
      devmin: 0,
      atime: this.atime,
      ctime: this.ctime
    }).encode(buf);
    buf.write(body, 512, bodyLen, "utf8");
    for (let i = bodyLen + 512;i < buf.length; i++) {
      buf[i] = 0;
    }
    return buf;
  }
  encodeBody() {
    return this.encodeField("path") + this.encodeField("ctime") + this.encodeField("atime") + this.encodeField("dev") + this.encodeField("ino") + this.encodeField("nlink") + this.encodeField("charset") + this.encodeField("comment") + this.encodeField("gid") + this.encodeField("gname") + this.encodeField("linkpath") + this.encodeField("mtime") + this.encodeField("size") + this.encodeField("uid") + this.encodeField("uname");
  }
  encodeField(field) {
    if (this[field] === undefined) {
      return "";
    }
    const r2 = this[field];
    const v2 = r2 instanceof Date ? r2.getTime() / 1000 : r2;
    const s = " " + (field === "dev" || field === "ino" || field === "nlink" ? "SCHILY." : "") + field + "=" + v2 + `
`;
    const byteLen = Buffer.byteLength(s);
    let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;
    if (byteLen + digits >= Math.pow(10, digits)) {
      digits += 1;
    }
    const len = digits + byteLen;
    return len + s;
  }
  static parse(str, ex, g2 = false) {
    return new Pax(merge(parseKV(str), ex), g2);
  }
}
var merge = (a3, b3) => b3 ? Object.assign({}, b3, a3) : a3;
var parseKV = (str) => str.replace(/\n$/, "").split(`
`).reduce(parseKVLine, Object.create(null));
var parseKVLine = (set, line) => {
  const n = parseInt(line, 10);
  if (n !== Buffer.byteLength(line) + 1) {
    return set;
  }
  line = line.slice((n + " ").length);
  const kv = line.split("=");
  const r2 = kv.shift();
  if (!r2) {
    return set;
  }
  const k2 = r2.replace(/^SCHILY\.(dev|ino|nlink)/, "$1");
  const v2 = kv.join("=");
  set[k2] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k2) ? new Date(Number(v2) * 1000) : /^[0-9]+$/.test(v2) ? +v2 : v2;
  return set;
};

// node_modules/tar/node_modules/minipass/dist/esm/index.js
import { EventEmitter as EventEmitter4 } from "node:events";
import Stream3 from "node:stream";
import { StringDecoder as StringDecoder3 } from "node:string_decoder";
var proc3 = typeof process === "object" && process ? process : {
  stdout: null,
  stderr: null
};
var isStream3 = (s) => !!s && typeof s === "object" && (s instanceof Minipass3 || s instanceof Stream3 || isReadable3(s) || isWritable3(s));
var isReadable3 = (s) => !!s && typeof s === "object" && s instanceof EventEmitter4 && typeof s.pipe === "function" && s.pipe !== Stream3.Writable.prototype.pipe;
var isWritable3 = (s) => !!s && typeof s === "object" && s instanceof EventEmitter4 && typeof s.write === "function" && typeof s.end === "function";
var EOF3 = Symbol("EOF");
var MAYBE_EMIT_END3 = Symbol("maybeEmitEnd");
var EMITTED_END3 = Symbol("emittedEnd");
var EMITTING_END3 = Symbol("emittingEnd");
var EMITTED_ERROR3 = Symbol("emittedError");
var CLOSED3 = Symbol("closed");
var READ3 = Symbol("read");
var FLUSH3 = Symbol("flush");
var FLUSHCHUNK3 = Symbol("flushChunk");
var ENCODING3 = Symbol("encoding");
var DECODER3 = Symbol("decoder");
var FLOWING3 = Symbol("flowing");
var PAUSED3 = Symbol("paused");
var RESUME3 = Symbol("resume");
var BUFFER3 = Symbol("buffer");
var PIPES3 = Symbol("pipes");
var BUFFERLENGTH3 = Symbol("bufferLength");
var BUFFERPUSH3 = Symbol("bufferPush");
var BUFFERSHIFT3 = Symbol("bufferShift");
var OBJECTMODE3 = Symbol("objectMode");
var DESTROYED3 = Symbol("destroyed");
var ERROR3 = Symbol("error");
var EMITDATA3 = Symbol("emitData");
var EMITEND5 = Symbol("emitEnd");
var EMITEND23 = Symbol("emitEnd2");
var ASYNC3 = Symbol("async");
var ABORT3 = Symbol("abort");
var ABORTED3 = Symbol("aborted");
var SIGNAL3 = Symbol("signal");
var DATALISTENERS3 = Symbol("dataListeners");
var DISCARDED3 = Symbol("discarded");
var defer3 = (fn) => Promise.resolve().then(fn);
var nodefer3 = (fn) => fn();
var isEndish3 = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
var isArrayBufferLike3 = (b3) => b3 instanceof ArrayBuffer || !!b3 && typeof b3 === "object" && b3.constructor && b3.constructor.name === "ArrayBuffer" && b3.byteLength >= 0;
var isArrayBufferView3 = (b3) => !Buffer.isBuffer(b3) && ArrayBuffer.isView(b3);

class Pipe3 {
  src;
  dest;
  opts;
  ondrain;
  constructor(src, dest, opts) {
    this.src = src;
    this.dest = dest;
    this.opts = opts;
    this.ondrain = () => src[RESUME3]();
    this.dest.on("drain", this.ondrain);
  }
  unpipe() {
    this.dest.removeListener("drain", this.ondrain);
  }
  proxyErrors(_er) {}
  end() {
    this.unpipe();
    if (this.opts.end)
      this.dest.end();
  }
}

class PipeProxyErrors3 extends Pipe3 {
  unpipe() {
    this.src.removeListener("error", this.proxyErrors);
    super.unpipe();
  }
  constructor(src, dest, opts) {
    super(src, dest, opts);
    this.proxyErrors = (er) => dest.emit("error", er);
    src.on("error", this.proxyErrors);
  }
}
var isObjectModeOptions3 = (o2) => !!o2.objectMode;
var isEncodingOptions3 = (o2) => !o2.objectMode && !!o2.encoding && o2.encoding !== "buffer";

class Minipass3 extends EventEmitter4 {
  [FLOWING3] = false;
  [PAUSED3] = false;
  [PIPES3] = [];
  [BUFFER3] = [];
  [OBJECTMODE3];
  [ENCODING3];
  [ASYNC3];
  [DECODER3];
  [EOF3] = false;
  [EMITTED_END3] = false;
  [EMITTING_END3] = false;
  [CLOSED3] = false;
  [EMITTED_ERROR3] = null;
  [BUFFERLENGTH3] = 0;
  [DESTROYED3] = false;
  [SIGNAL3];
  [ABORTED3] = false;
  [DATALISTENERS3] = 0;
  [DISCARDED3] = false;
  writable = true;
  readable = true;
  constructor(...args) {
    const options = args[0] || {};
    super();
    if (options.objectMode && typeof options.encoding === "string") {
      throw new TypeError("Encoding and objectMode may not be used together");
    }
    if (isObjectModeOptions3(options)) {
      this[OBJECTMODE3] = true;
      this[ENCODING3] = null;
    } else if (isEncodingOptions3(options)) {
      this[ENCODING3] = options.encoding;
      this[OBJECTMODE3] = false;
    } else {
      this[OBJECTMODE3] = false;
      this[ENCODING3] = null;
    }
    this[ASYNC3] = !!options.async;
    this[DECODER3] = this[ENCODING3] ? new StringDecoder3(this[ENCODING3]) : null;
    if (options && options.debugExposeBuffer === true) {
      Object.defineProperty(this, "buffer", { get: () => this[BUFFER3] });
    }
    if (options && options.debugExposePipes === true) {
      Object.defineProperty(this, "pipes", { get: () => this[PIPES3] });
    }
    const { signal } = options;
    if (signal) {
      this[SIGNAL3] = signal;
      if (signal.aborted) {
        this[ABORT3]();
      } else {
        signal.addEventListener("abort", () => this[ABORT3]());
      }
    }
  }
  get bufferLength() {
    return this[BUFFERLENGTH3];
  }
  get encoding() {
    return this[ENCODING3];
  }
  set encoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  setEncoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  get objectMode() {
    return this[OBJECTMODE3];
  }
  set objectMode(_om) {
    throw new Error("objectMode must be set at instantiation time");
  }
  get ["async"]() {
    return this[ASYNC3];
  }
  set ["async"](a3) {
    this[ASYNC3] = this[ASYNC3] || !!a3;
  }
  [ABORT3]() {
    this[ABORTED3] = true;
    this.emit("abort", this[SIGNAL3]?.reason);
    this.destroy(this[SIGNAL3]?.reason);
  }
  get aborted() {
    return this[ABORTED3];
  }
  set aborted(_3) {}
  write(chunk, encoding, cb) {
    if (this[ABORTED3])
      return false;
    if (this[EOF3])
      throw new Error("write after end");
    if (this[DESTROYED3]) {
      this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
      return true;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = "utf8";
    }
    if (!encoding)
      encoding = "utf8";
    const fn = this[ASYNC3] ? defer3 : nodefer3;
    if (!this[OBJECTMODE3] && !Buffer.isBuffer(chunk)) {
      if (isArrayBufferView3(chunk)) {
        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
      } else if (isArrayBufferLike3(chunk)) {
        chunk = Buffer.from(chunk);
      } else if (typeof chunk !== "string") {
        throw new Error("Non-contiguous data written to non-objectMode stream");
      }
    }
    if (this[OBJECTMODE3]) {
      if (this[FLOWING3] && this[BUFFERLENGTH3] !== 0)
        this[FLUSH3](true);
      if (this[FLOWING3])
        this.emit("data", chunk);
      else
        this[BUFFERPUSH3](chunk);
      if (this[BUFFERLENGTH3] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING3];
    }
    if (!chunk.length) {
      if (this[BUFFERLENGTH3] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING3];
    }
    if (typeof chunk === "string" && !(encoding === this[ENCODING3] && !this[DECODER3]?.lastNeed)) {
      chunk = Buffer.from(chunk, encoding);
    }
    if (Buffer.isBuffer(chunk) && this[ENCODING3]) {
      chunk = this[DECODER3].write(chunk);
    }
    if (this[FLOWING3] && this[BUFFERLENGTH3] !== 0)
      this[FLUSH3](true);
    if (this[FLOWING3])
      this.emit("data", chunk);
    else
      this[BUFFERPUSH3](chunk);
    if (this[BUFFERLENGTH3] !== 0)
      this.emit("readable");
    if (cb)
      fn(cb);
    return this[FLOWING3];
  }
  read(n) {
    if (this[DESTROYED3])
      return null;
    this[DISCARDED3] = false;
    if (this[BUFFERLENGTH3] === 0 || n === 0 || n && n > this[BUFFERLENGTH3]) {
      this[MAYBE_EMIT_END3]();
      return null;
    }
    if (this[OBJECTMODE3])
      n = null;
    if (this[BUFFER3].length > 1 && !this[OBJECTMODE3]) {
      this[BUFFER3] = [
        this[ENCODING3] ? this[BUFFER3].join("") : Buffer.concat(this[BUFFER3], this[BUFFERLENGTH3])
      ];
    }
    const ret = this[READ3](n || null, this[BUFFER3][0]);
    this[MAYBE_EMIT_END3]();
    return ret;
  }
  [READ3](n, chunk) {
    if (this[OBJECTMODE3])
      this[BUFFERSHIFT3]();
    else {
      const c2 = chunk;
      if (n === c2.length || n === null)
        this[BUFFERSHIFT3]();
      else if (typeof c2 === "string") {
        this[BUFFER3][0] = c2.slice(n);
        chunk = c2.slice(0, n);
        this[BUFFERLENGTH3] -= n;
      } else {
        this[BUFFER3][0] = c2.subarray(n);
        chunk = c2.subarray(0, n);
        this[BUFFERLENGTH3] -= n;
      }
    }
    this.emit("data", chunk);
    if (!this[BUFFER3].length && !this[EOF3])
      this.emit("drain");
    return chunk;
  }
  end(chunk, encoding, cb) {
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = undefined;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = "utf8";
    }
    if (chunk !== undefined)
      this.write(chunk, encoding);
    if (cb)
      this.once("end", cb);
    this[EOF3] = true;
    this.writable = false;
    if (this[FLOWING3] || !this[PAUSED3])
      this[MAYBE_EMIT_END3]();
    return this;
  }
  [RESUME3]() {
    if (this[DESTROYED3])
      return;
    if (!this[DATALISTENERS3] && !this[PIPES3].length) {
      this[DISCARDED3] = true;
    }
    this[PAUSED3] = false;
    this[FLOWING3] = true;
    this.emit("resume");
    if (this[BUFFER3].length)
      this[FLUSH3]();
    else if (this[EOF3])
      this[MAYBE_EMIT_END3]();
    else
      this.emit("drain");
  }
  resume() {
    return this[RESUME3]();
  }
  pause() {
    this[FLOWING3] = false;
    this[PAUSED3] = true;
    this[DISCARDED3] = false;
  }
  get destroyed() {
    return this[DESTROYED3];
  }
  get flowing() {
    return this[FLOWING3];
  }
  get paused() {
    return this[PAUSED3];
  }
  [BUFFERPUSH3](chunk) {
    if (this[OBJECTMODE3])
      this[BUFFERLENGTH3] += 1;
    else
      this[BUFFERLENGTH3] += chunk.length;
    this[BUFFER3].push(chunk);
  }
  [BUFFERSHIFT3]() {
    if (this[OBJECTMODE3])
      this[BUFFERLENGTH3] -= 1;
    else
      this[BUFFERLENGTH3] -= this[BUFFER3][0].length;
    return this[BUFFER3].shift();
  }
  [FLUSH3](noDrain = false) {
    do {} while (this[FLUSHCHUNK3](this[BUFFERSHIFT3]()) && this[BUFFER3].length);
    if (!noDrain && !this[BUFFER3].length && !this[EOF3])
      this.emit("drain");
  }
  [FLUSHCHUNK3](chunk) {
    this.emit("data", chunk);
    return this[FLOWING3];
  }
  pipe(dest, opts) {
    if (this[DESTROYED3])
      return dest;
    this[DISCARDED3] = false;
    const ended = this[EMITTED_END3];
    opts = opts || {};
    if (dest === proc3.stdout || dest === proc3.stderr)
      opts.end = false;
    else
      opts.end = opts.end !== false;
    opts.proxyErrors = !!opts.proxyErrors;
    if (ended) {
      if (opts.end)
        dest.end();
    } else {
      this[PIPES3].push(!opts.proxyErrors ? new Pipe3(this, dest, opts) : new PipeProxyErrors3(this, dest, opts));
      if (this[ASYNC3])
        defer3(() => this[RESUME3]());
      else
        this[RESUME3]();
    }
    return dest;
  }
  unpipe(dest) {
    const p = this[PIPES3].find((p2) => p2.dest === dest);
    if (p) {
      if (this[PIPES3].length === 1) {
        if (this[FLOWING3] && this[DATALISTENERS3] === 0) {
          this[FLOWING3] = false;
        }
        this[PIPES3] = [];
      } else
        this[PIPES3].splice(this[PIPES3].indexOf(p), 1);
      p.unpipe();
    }
  }
  addListener(ev, handler) {
    return this.on(ev, handler);
  }
  on(ev, handler) {
    const ret = super.on(ev, handler);
    if (ev === "data") {
      this[DISCARDED3] = false;
      this[DATALISTENERS3]++;
      if (!this[PIPES3].length && !this[FLOWING3]) {
        this[RESUME3]();
      }
    } else if (ev === "readable" && this[BUFFERLENGTH3] !== 0) {
      super.emit("readable");
    } else if (isEndish3(ev) && this[EMITTED_END3]) {
      super.emit(ev);
      this.removeAllListeners(ev);
    } else if (ev === "error" && this[EMITTED_ERROR3]) {
      const h2 = handler;
      if (this[ASYNC3])
        defer3(() => h2.call(this, this[EMITTED_ERROR3]));
      else
        h2.call(this, this[EMITTED_ERROR3]);
    }
    return ret;
  }
  removeListener(ev, handler) {
    return this.off(ev, handler);
  }
  off(ev, handler) {
    const ret = super.off(ev, handler);
    if (ev === "data") {
      this[DATALISTENERS3] = this.listeners("data").length;
      if (this[DATALISTENERS3] === 0 && !this[DISCARDED3] && !this[PIPES3].length) {
        this[FLOWING3] = false;
      }
    }
    return ret;
  }
  removeAllListeners(ev) {
    const ret = super.removeAllListeners(ev);
    if (ev === "data" || ev === undefined) {
      this[DATALISTENERS3] = 0;
      if (!this[DISCARDED3] && !this[PIPES3].length) {
        this[FLOWING3] = false;
      }
    }
    return ret;
  }
  get emittedEnd() {
    return this[EMITTED_END3];
  }
  [MAYBE_EMIT_END3]() {
    if (!this[EMITTING_END3] && !this[EMITTED_END3] && !this[DESTROYED3] && this[BUFFER3].length === 0 && this[EOF3]) {
      this[EMITTING_END3] = true;
      this.emit("end");
      this.emit("prefinish");
      this.emit("finish");
      if (this[CLOSED3])
        this.emit("close");
      this[EMITTING_END3] = false;
    }
  }
  emit(ev, ...args) {
    const data = args[0];
    if (ev !== "error" && ev !== "close" && ev !== DESTROYED3 && this[DESTROYED3]) {
      return false;
    } else if (ev === "data") {
      return !this[OBJECTMODE3] && !data ? false : this[ASYNC3] ? (defer3(() => this[EMITDATA3](data)), true) : this[EMITDATA3](data);
    } else if (ev === "end") {
      return this[EMITEND5]();
    } else if (ev === "close") {
      this[CLOSED3] = true;
      if (!this[EMITTED_END3] && !this[DESTROYED3])
        return false;
      const ret2 = super.emit("close");
      this.removeAllListeners("close");
      return ret2;
    } else if (ev === "error") {
      this[EMITTED_ERROR3] = data;
      super.emit(ERROR3, data);
      const ret2 = !this[SIGNAL3] || this.listeners("error").length ? super.emit("error", data) : false;
      this[MAYBE_EMIT_END3]();
      return ret2;
    } else if (ev === "resume") {
      const ret2 = super.emit("resume");
      this[MAYBE_EMIT_END3]();
      return ret2;
    } else if (ev === "finish" || ev === "prefinish") {
      const ret2 = super.emit(ev);
      this.removeAllListeners(ev);
      return ret2;
    }
    const ret = super.emit(ev, ...args);
    this[MAYBE_EMIT_END3]();
    return ret;
  }
  [EMITDATA3](data) {
    for (const p of this[PIPES3]) {
      if (p.dest.write(data) === false)
        this.pause();
    }
    const ret = this[DISCARDED3] ? false : super.emit("data", data);
    this[MAYBE_EMIT_END3]();
    return ret;
  }
  [EMITEND5]() {
    if (this[EMITTED_END3])
      return false;
    this[EMITTED_END3] = true;
    this.readable = false;
    return this[ASYNC3] ? (defer3(() => this[EMITEND23]()), true) : this[EMITEND23]();
  }
  [EMITEND23]() {
    if (this[DECODER3]) {
      const data = this[DECODER3].end();
      if (data) {
        for (const p of this[PIPES3]) {
          p.dest.write(data);
        }
        if (!this[DISCARDED3])
          super.emit("data", data);
      }
    }
    for (const p of this[PIPES3]) {
      p.end();
    }
    const ret = super.emit("end");
    this.removeAllListeners("end");
    return ret;
  }
  async collect() {
    const buf = Object.assign([], {
      dataLength: 0
    });
    if (!this[OBJECTMODE3])
      buf.dataLength = 0;
    const p = this.promise();
    this.on("data", (c2) => {
      buf.push(c2);
      if (!this[OBJECTMODE3])
        buf.dataLength += c2.length;
    });
    await p;
    return buf;
  }
  async concat() {
    if (this[OBJECTMODE3]) {
      throw new Error("cannot concat in objectMode");
    }
    const buf = await this.collect();
    return this[ENCODING3] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
  }
  async promise() {
    return new Promise((resolve5, reject) => {
      this.on(DESTROYED3, () => reject(new Error("stream destroyed")));
      this.on("error", (er) => reject(er));
      this.on("end", () => resolve5());
    });
  }
  [Symbol.asyncIterator]() {
    this[DISCARDED3] = false;
    let stopped = false;
    const stop = async () => {
      this.pause();
      stopped = true;
      return { value: undefined, done: true };
    };
    const next = () => {
      if (stopped)
        return stop();
      const res = this.read();
      if (res !== null)
        return Promise.resolve({ done: false, value: res });
      if (this[EOF3])
        return stop();
      let resolve5;
      let reject;
      const onerr = (er) => {
        this.off("data", ondata);
        this.off("end", onend);
        this.off(DESTROYED3, ondestroy);
        stop();
        reject(er);
      };
      const ondata = (value) => {
        this.off("error", onerr);
        this.off("end", onend);
        this.off(DESTROYED3, ondestroy);
        this.pause();
        resolve5({ value, done: !!this[EOF3] });
      };
      const onend = () => {
        this.off("error", onerr);
        this.off("data", ondata);
        this.off(DESTROYED3, ondestroy);
        stop();
        resolve5({ done: true, value: undefined });
      };
      const ondestroy = () => onerr(new Error("stream destroyed"));
      return new Promise((res2, rej) => {
        reject = rej;
        resolve5 = res2;
        this.once(DESTROYED3, ondestroy);
        this.once("error", onerr);
        this.once("end", onend);
        this.once("data", ondata);
      });
    };
    return {
      next,
      throw: stop,
      return: stop,
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  [Symbol.iterator]() {
    this[DISCARDED3] = false;
    let stopped = false;
    const stop = () => {
      this.pause();
      this.off(ERROR3, stop);
      this.off(DESTROYED3, stop);
      this.off("end", stop);
      stopped = true;
      return { done: true, value: undefined };
    };
    const next = () => {
      if (stopped)
        return stop();
      const value = this.read();
      return value === null ? stop() : { done: false, value };
    };
    this.once("end", stop);
    this.once(ERROR3, stop);
    this.once(DESTROYED3, stop);
    return {
      next,
      throw: stop,
      return: stop,
      [Symbol.iterator]() {
        return this;
      }
    };
  }
  destroy(er) {
    if (this[DESTROYED3]) {
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED3);
      return this;
    }
    this[DESTROYED3] = true;
    this[DISCARDED3] = true;
    this[BUFFER3].length = 0;
    this[BUFFERLENGTH3] = 0;
    const wc = this;
    if (typeof wc.close === "function" && !this[CLOSED3])
      wc.close();
    if (er)
      this.emit("error", er);
    else
      this.emit(DESTROYED3);
    return this;
  }
  static get isStream() {
    return isStream3;
  }
}

// node_modules/tar/dist/esm/normalize-windows-path.js
var platform6 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
var normalizeWindowsPath = platform6 !== "win32" ? (p) => p : (p) => p && p.replace(/\\/g, "/");

// node_modules/tar/dist/esm/read-entry.js
class ReadEntry extends Minipass3 {
  extended;
  globalExtended;
  header;
  startBlockSize;
  blockRemain;
  remain;
  type;
  meta = false;
  ignore = false;
  path;
  mode;
  uid;
  gid;
  uname;
  gname;
  size = 0;
  mtime;
  atime;
  ctime;
  linkpath;
  dev;
  ino;
  nlink;
  invalid = false;
  absolute;
  unsupported = false;
  constructor(header, ex, gex) {
    super({});
    this.pause();
    this.extended = ex;
    this.globalExtended = gex;
    this.header = header;
    this.remain = header.size ?? 0;
    this.startBlockSize = 512 * Math.ceil(this.remain / 512);
    this.blockRemain = this.startBlockSize;
    this.type = header.type;
    switch (this.type) {
      case "File":
      case "OldFile":
      case "Link":
      case "SymbolicLink":
      case "CharacterDevice":
      case "BlockDevice":
      case "Directory":
      case "FIFO":
      case "ContiguousFile":
      case "GNUDumpDir":
        break;
      case "NextFileHasLongLinkpath":
      case "NextFileHasLongPath":
      case "OldGnuLongPath":
      case "GlobalExtendedHeader":
      case "ExtendedHeader":
      case "OldExtendedHeader":
        this.meta = true;
        break;
      default:
        this.ignore = true;
    }
    if (!header.path) {
      throw new Error("no path provided for tar.ReadEntry");
    }
    this.path = normalizeWindowsPath(header.path);
    this.mode = header.mode;
    if (this.mode) {
      this.mode = this.mode & 4095;
    }
    this.uid = header.uid;
    this.gid = header.gid;
    this.uname = header.uname;
    this.gname = header.gname;
    this.size = this.remain;
    this.mtime = header.mtime;
    this.atime = header.atime;
    this.ctime = header.ctime;
    this.linkpath = header.linkpath ? normalizeWindowsPath(header.linkpath) : undefined;
    this.uname = header.uname;
    this.gname = header.gname;
    if (ex) {
      this.#slurp(ex);
    }
    if (gex) {
      this.#slurp(gex, true);
    }
  }
  write(data) {
    const writeLen = data.length;
    if (writeLen > this.blockRemain) {
      throw new Error("writing more to entry than is appropriate");
    }
    const r2 = this.remain;
    const br = this.blockRemain;
    this.remain = Math.max(0, r2 - writeLen);
    this.blockRemain = Math.max(0, br - writeLen);
    if (this.ignore) {
      return true;
    }
    if (r2 >= writeLen) {
      return super.write(data);
    }
    return super.write(data.subarray(0, r2));
  }
  #slurp(ex, gex = false) {
    if (ex.path)
      ex.path = normalizeWindowsPath(ex.path);
    if (ex.linkpath)
      ex.linkpath = normalizeWindowsPath(ex.linkpath);
    Object.assign(this, Object.fromEntries(Object.entries(ex).filter(([k2, v2]) => {
      return !(v2 === null || v2 === undefined || k2 === "path" && gex);
    })));
  }
}

// node_modules/tar/dist/esm/warn-method.js
var warnMethod = (self2, code2, message, data = {}) => {
  if (self2.file) {
    data.file = self2.file;
  }
  if (self2.cwd) {
    data.cwd = self2.cwd;
  }
  data.code = message instanceof Error && message.code || code2;
  data.tarCode = code2;
  if (!self2.strict && data.recoverable !== false) {
    if (message instanceof Error) {
      data = Object.assign(message, data);
      message = message.message;
    }
    self2.emit("warn", code2, message, data);
  } else if (message instanceof Error) {
    self2.emit("error", Object.assign(message, data));
  } else {
    self2.emit("error", Object.assign(new Error(`${code2}: ${message}`), data));
  }
};

// node_modules/tar/dist/esm/parse.js
var maxMetaEntrySize = 1024 * 1024;
var gzipHeader = Buffer.from([31, 139]);
var zstdHeader = Buffer.from([40, 181, 47, 253]);
var ZIP_HEADER_LEN = Math.max(gzipHeader.length, zstdHeader.length);
var STATE = Symbol("state");
var WRITEENTRY = Symbol("writeEntry");
var READENTRY = Symbol("readEntry");
var NEXTENTRY = Symbol("nextEntry");
var PROCESSENTRY = Symbol("processEntry");
var EX = Symbol("extendedHeader");
var GEX = Symbol("globalExtendedHeader");
var META = Symbol("meta");
var EMITMETA = Symbol("emitMeta");
var BUFFER4 = Symbol("buffer");
var QUEUE = Symbol("queue");
var ENDED = Symbol("ended");
var EMITTEDEND = Symbol("emittedEnd");
var EMIT = Symbol("emit");
var UNZIP = Symbol("unzip");
var CONSUMECHUNK = Symbol("consumeChunk");
var CONSUMECHUNKSUB = Symbol("consumeChunkSub");
var CONSUMEBODY = Symbol("consumeBody");
var CONSUMEMETA = Symbol("consumeMeta");
var CONSUMEHEADER = Symbol("consumeHeader");
var CONSUMING = Symbol("consuming");
var BUFFERCONCAT = Symbol("bufferConcat");
var MAYBEEND = Symbol("maybeEnd");
var WRITING = Symbol("writing");
var ABORTED4 = Symbol("aborted");
var DONE = Symbol("onDone");
var SAW_VALID_ENTRY = Symbol("sawValidEntry");
var SAW_NULL_BLOCK = Symbol("sawNullBlock");
var SAW_EOF = Symbol("sawEOF");
var CLOSESTREAM = Symbol("closeStream");
var noop2 = () => true;

class Parser extends EE2 {
  file;
  strict;
  maxMetaEntrySize;
  filter;
  brotli;
  zstd;
  writable = true;
  readable = false;
  [QUEUE] = [];
  [BUFFER4];
  [READENTRY];
  [WRITEENTRY];
  [STATE] = "begin";
  [META] = "";
  [EX];
  [GEX];
  [ENDED] = false;
  [UNZIP];
  [ABORTED4] = false;
  [SAW_VALID_ENTRY];
  [SAW_NULL_BLOCK] = false;
  [SAW_EOF] = false;
  [WRITING] = false;
  [CONSUMING] = false;
  [EMITTEDEND] = false;
  constructor(opt = {}) {
    super();
    this.file = opt.file || "";
    this.on(DONE, () => {
      if (this[STATE] === "begin" || this[SAW_VALID_ENTRY] === false) {
        this.warn("TAR_BAD_ARCHIVE", "Unrecognized archive format");
      }
    });
    if (opt.ondone) {
      this.on(DONE, opt.ondone);
    } else {
      this.on(DONE, () => {
        this.emit("prefinish");
        this.emit("finish");
        this.emit("end");
      });
    }
    this.strict = !!opt.strict;
    this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;
    this.filter = typeof opt.filter === "function" ? opt.filter : noop2;
    const isTBR = opt.file && (opt.file.endsWith(".tar.br") || opt.file.endsWith(".tbr"));
    this.brotli = !(opt.gzip || opt.zstd) && opt.brotli !== undefined ? opt.brotli : isTBR ? undefined : false;
    const isTZST = opt.file && (opt.file.endsWith(".tar.zst") || opt.file.endsWith(".tzst"));
    this.zstd = !(opt.gzip || opt.brotli) && opt.zstd !== undefined ? opt.zstd : isTZST ? true : undefined;
    this.on("end", () => this[CLOSESTREAM]());
    if (typeof opt.onwarn === "function") {
      this.on("warn", opt.onwarn);
    }
    if (typeof opt.onReadEntry === "function") {
      this.on("entry", opt.onReadEntry);
    }
  }
  warn(code2, message, data = {}) {
    warnMethod(this, code2, message, data);
  }
  [CONSUMEHEADER](chunk, position) {
    if (this[SAW_VALID_ENTRY] === undefined) {
      this[SAW_VALID_ENTRY] = false;
    }
    let header;
    try {
      header = new Header(chunk, position, this[EX], this[GEX]);
    } catch (er) {
      return this.warn("TAR_ENTRY_INVALID", er);
    }
    if (header.nullBlock) {
      if (this[SAW_NULL_BLOCK]) {
        this[SAW_EOF] = true;
        if (this[STATE] === "begin") {
          this[STATE] = "header";
        }
        this[EMIT]("eof");
      } else {
        this[SAW_NULL_BLOCK] = true;
        this[EMIT]("nullBlock");
      }
    } else {
      this[SAW_NULL_BLOCK] = false;
      if (!header.cksumValid) {
        this.warn("TAR_ENTRY_INVALID", "checksum failure", { header });
      } else if (!header.path) {
        this.warn("TAR_ENTRY_INVALID", "path is required", { header });
      } else {
        const type = header.type;
        if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) {
          this.warn("TAR_ENTRY_INVALID", "linkpath required", {
            header
          });
        } else if (!/^(Symbolic)?Link$/.test(type) && !/^(Global)?ExtendedHeader$/.test(type) && header.linkpath) {
          this.warn("TAR_ENTRY_INVALID", "linkpath forbidden", {
            header
          });
        } else {
          const entry = this[WRITEENTRY] = new ReadEntry(header, this[EX], this[GEX]);
          if (!this[SAW_VALID_ENTRY]) {
            if (entry.remain) {
              const onend = () => {
                if (!entry.invalid) {
                  this[SAW_VALID_ENTRY] = true;
                }
              };
              entry.on("end", onend);
            } else {
              this[SAW_VALID_ENTRY] = true;
            }
          }
          if (entry.meta) {
            if (entry.size > this.maxMetaEntrySize) {
              entry.ignore = true;
              this[EMIT]("ignoredEntry", entry);
              this[STATE] = "ignore";
              entry.resume();
            } else if (entry.size > 0) {
              this[META] = "";
              entry.on("data", (c2) => this[META] += c2);
              this[STATE] = "meta";
            }
          } else {
            this[EX] = undefined;
            entry.ignore = entry.ignore || !this.filter(entry.path, entry);
            if (entry.ignore) {
              this[EMIT]("ignoredEntry", entry);
              this[STATE] = entry.remain ? "ignore" : "header";
              entry.resume();
            } else {
              if (entry.remain) {
                this[STATE] = "body";
              } else {
                this[STATE] = "header";
                entry.end();
              }
              if (!this[READENTRY]) {
                this[QUEUE].push(entry);
                this[NEXTENTRY]();
              } else {
                this[QUEUE].push(entry);
              }
            }
          }
        }
      }
    }
  }
  [CLOSESTREAM]() {
    queueMicrotask(() => this.emit("close"));
  }
  [PROCESSENTRY](entry) {
    let go = true;
    if (!entry) {
      this[READENTRY] = undefined;
      go = false;
    } else if (Array.isArray(entry)) {
      const [ev, ...args] = entry;
      this.emit(ev, ...args);
    } else {
      this[READENTRY] = entry;
      this.emit("entry", entry);
      if (!entry.emittedEnd) {
        entry.on("end", () => this[NEXTENTRY]());
        go = false;
      }
    }
    return go;
  }
  [NEXTENTRY]() {
    do {} while (this[PROCESSENTRY](this[QUEUE].shift()));
    if (!this[QUEUE].length) {
      const re2 = this[READENTRY];
      const drainNow = !re2 || re2.flowing || re2.size === re2.remain;
      if (drainNow) {
        if (!this[WRITING]) {
          this.emit("drain");
        }
      } else {
        re2.once("drain", () => this.emit("drain"));
      }
    }
  }
  [CONSUMEBODY](chunk, position) {
    const entry = this[WRITEENTRY];
    if (!entry) {
      throw new Error("attempt to consume body without entry??");
    }
    const br = entry.blockRemain ?? 0;
    const c2 = br >= chunk.length && position === 0 ? chunk : chunk.subarray(position, position + br);
    entry.write(c2);
    if (!entry.blockRemain) {
      this[STATE] = "header";
      this[WRITEENTRY] = undefined;
      entry.end();
    }
    return c2.length;
  }
  [CONSUMEMETA](chunk, position) {
    const entry = this[WRITEENTRY];
    const ret = this[CONSUMEBODY](chunk, position);
    if (!this[WRITEENTRY] && entry) {
      this[EMITMETA](entry);
    }
    return ret;
  }
  [EMIT](ev, data, extra) {
    if (!this[QUEUE].length && !this[READENTRY]) {
      this.emit(ev, data, extra);
    } else {
      this[QUEUE].push([ev, data, extra]);
    }
  }
  [EMITMETA](entry) {
    this[EMIT]("meta", this[META]);
    switch (entry.type) {
      case "ExtendedHeader":
      case "OldExtendedHeader":
        this[EX] = Pax.parse(this[META], this[EX], false);
        break;
      case "GlobalExtendedHeader":
        this[GEX] = Pax.parse(this[META], this[GEX], true);
        break;
      case "NextFileHasLongPath":
      case "OldGnuLongPath": {
        const ex = this[EX] ?? Object.create(null);
        this[EX] = ex;
        ex.path = this[META].replace(/\0.*/, "");
        break;
      }
      case "NextFileHasLongLinkpath": {
        const ex = this[EX] || Object.create(null);
        this[EX] = ex;
        ex.linkpath = this[META].replace(/\0.*/, "");
        break;
      }
      default:
        throw new Error("unknown meta: " + entry.type);
    }
  }
  abort(error) {
    this[ABORTED4] = true;
    this.emit("abort", error);
    this.warn("TAR_ABORT", error, { recoverable: false });
  }
  write(chunk, encoding, cb) {
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = undefined;
    }
    if (typeof chunk === "string") {
      chunk = Buffer.from(chunk, typeof encoding === "string" ? encoding : "utf8");
    }
    if (this[ABORTED4]) {
      cb?.();
      return false;
    }
    const needSniff = this[UNZIP] === undefined || this.brotli === undefined && this[UNZIP] === false;
    if (needSniff && chunk) {
      if (this[BUFFER4]) {
        chunk = Buffer.concat([this[BUFFER4], chunk]);
        this[BUFFER4] = undefined;
      }
      if (chunk.length < ZIP_HEADER_LEN) {
        this[BUFFER4] = chunk;
        cb?.();
        return true;
      }
      for (let i = 0;this[UNZIP] === undefined && i < gzipHeader.length; i++) {
        if (chunk[i] !== gzipHeader[i]) {
          this[UNZIP] = false;
        }
      }
      let isZstd = false;
      if (this[UNZIP] === false && this.zstd !== false) {
        isZstd = true;
        for (let i = 0;i < zstdHeader.length; i++) {
          if (chunk[i] !== zstdHeader[i]) {
            isZstd = false;
            break;
          }
        }
      }
      const maybeBrotli = this.brotli === undefined && !isZstd;
      if (this[UNZIP] === false && maybeBrotli) {
        if (chunk.length < 512) {
          if (this[ENDED]) {
            this.brotli = true;
          } else {
            this[BUFFER4] = chunk;
            cb?.();
            return true;
          }
        } else {
          try {
            new Header(chunk.subarray(0, 512));
            this.brotli = false;
          } catch (_3) {
            this.brotli = true;
          }
        }
      }
      if (this[UNZIP] === undefined || this[UNZIP] === false && (this.brotli || isZstd)) {
        const ended = this[ENDED];
        this[ENDED] = false;
        this[UNZIP] = this[UNZIP] === undefined ? new Unzip({}) : isZstd ? new ZstdDecompress({}) : new BrotliDecompress({});
        this[UNZIP].on("data", (chunk2) => this[CONSUMECHUNK](chunk2));
        this[UNZIP].on("error", (er) => this.abort(er));
        this[UNZIP].on("end", () => {
          this[ENDED] = true;
          this[CONSUMECHUNK]();
        });
        this[WRITING] = true;
        const ret2 = !!this[UNZIP][ended ? "end" : "write"](chunk);
        this[WRITING] = false;
        cb?.();
        return ret2;
      }
    }
    this[WRITING] = true;
    if (this[UNZIP]) {
      this[UNZIP].write(chunk);
    } else {
      this[CONSUMECHUNK](chunk);
    }
    this[WRITING] = false;
    const ret = this[QUEUE].length ? false : this[READENTRY] ? this[READENTRY].flowing : true;
    if (!ret && !this[QUEUE].length) {
      this[READENTRY]?.once("drain", () => this.emit("drain"));
    }
    cb?.();
    return ret;
  }
  [BUFFERCONCAT](c2) {
    if (c2 && !this[ABORTED4]) {
      this[BUFFER4] = this[BUFFER4] ? Buffer.concat([this[BUFFER4], c2]) : c2;
    }
  }
  [MAYBEEND]() {
    if (this[ENDED] && !this[EMITTEDEND] && !this[ABORTED4] && !this[CONSUMING]) {
      this[EMITTEDEND] = true;
      const entry = this[WRITEENTRY];
      if (entry && entry.blockRemain) {
        const have = this[BUFFER4] ? this[BUFFER4].length : 0;
        this.warn("TAR_BAD_ARCHIVE", `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, { entry });
        if (this[BUFFER4]) {
          entry.write(this[BUFFER4]);
        }
        entry.end();
      }
      this[EMIT](DONE);
    }
  }
  [CONSUMECHUNK](chunk) {
    if (this[CONSUMING] && chunk) {
      this[BUFFERCONCAT](chunk);
    } else if (!chunk && !this[BUFFER4]) {
      this[MAYBEEND]();
    } else if (chunk) {
      this[CONSUMING] = true;
      if (this[BUFFER4]) {
        this[BUFFERCONCAT](chunk);
        const c2 = this[BUFFER4];
        this[BUFFER4] = undefined;
        this[CONSUMECHUNKSUB](c2);
      } else {
        this[CONSUMECHUNKSUB](chunk);
      }
      while (this[BUFFER4] && this[BUFFER4]?.length >= 512 && !this[ABORTED4] && !this[SAW_EOF]) {
        const c2 = this[BUFFER4];
        this[BUFFER4] = undefined;
        this[CONSUMECHUNKSUB](c2);
      }
      this[CONSUMING] = false;
    }
    if (!this[BUFFER4] || this[ENDED]) {
      this[MAYBEEND]();
    }
  }
  [CONSUMECHUNKSUB](chunk) {
    let position = 0;
    const length = chunk.length;
    while (position + 512 <= length && !this[ABORTED4] && !this[SAW_EOF]) {
      switch (this[STATE]) {
        case "begin":
        case "header":
          this[CONSUMEHEADER](chunk, position);
          position += 512;
          break;
        case "ignore":
        case "body":
          position += this[CONSUMEBODY](chunk, position);
          break;
        case "meta":
          position += this[CONSUMEMETA](chunk, position);
          break;
        default:
          throw new Error("invalid state: " + this[STATE]);
      }
    }
    if (position < length) {
      if (this[BUFFER4]) {
        this[BUFFER4] = Buffer.concat([
          chunk.subarray(position),
          this[BUFFER4]
        ]);
      } else {
        this[BUFFER4] = chunk.subarray(position);
      }
    }
  }
  end(chunk, encoding, cb) {
    if (typeof chunk === "function") {
      cb = chunk;
      encoding = undefined;
      chunk = undefined;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = undefined;
    }
    if (typeof chunk === "string") {
      chunk = Buffer.from(chunk, encoding);
    }
    if (cb)
      this.once("finish", cb);
    if (!this[ABORTED4]) {
      if (this[UNZIP]) {
        if (chunk)
          this[UNZIP].write(chunk);
        this[UNZIP].end();
      } else {
        this[ENDED] = true;
        if (this.brotli === undefined || this.zstd === undefined)
          chunk = chunk || Buffer.alloc(0);
        if (chunk)
          this.write(chunk);
        this[MAYBEEND]();
      }
    }
    return this;
  }
}

// node_modules/tar/dist/esm/strip-trailing-slashes.js
var stripTrailingSlashes = (str) => {
  let i = str.length - 1;
  let slashesStart = -1;
  while (i > -1 && str.charAt(i) === "/") {
    slashesStart = i;
    i--;
  }
  return slashesStart === -1 ? str : str.slice(0, slashesStart);
};

// node_modules/tar/dist/esm/list.js
var onReadEntryFunction = (opt) => {
  const onReadEntry = opt.onReadEntry;
  opt.onReadEntry = onReadEntry ? (e2) => {
    onReadEntry(e2);
    e2.resume();
  } : (e2) => e2.resume();
};
var filesFilter = (opt, files) => {
  const map = new Map(files.map((f3) => [stripTrailingSlashes(f3), true]));
  const filter = opt.filter;
  const mapHas = (file, r2 = "") => {
    const root = r2 || parse2(file).root || ".";
    let ret;
    if (file === root)
      ret = false;
    else {
      const m2 = map.get(file);
      if (m2 !== undefined) {
        ret = m2;
      } else {
        ret = mapHas(dirname5(file), root);
      }
    }
    map.set(file, ret);
    return ret;
  };
  opt.filter = filter ? (file, entry) => filter(file, entry) && mapHas(stripTrailingSlashes(file)) : (file) => mapHas(stripTrailingSlashes(file));
};
var listFileSync = (opt) => {
  const p = new Parser(opt);
  const file = opt.file;
  let fd;
  try {
    fd = fs4.openSync(file, "r");
    const stat3 = fs4.fstatSync(fd);
    const readSize = opt.maxReadSize || 16 * 1024 * 1024;
    if (stat3.size < readSize) {
      const buf = Buffer.allocUnsafe(stat3.size);
      const read = fs4.readSync(fd, buf, 0, stat3.size, 0);
      p.end(read === buf.byteLength ? buf : buf.subarray(0, read));
    } else {
      let pos2 = 0;
      const buf = Buffer.allocUnsafe(readSize);
      while (pos2 < stat3.size) {
        const bytesRead = fs4.readSync(fd, buf, 0, readSize, pos2);
        if (bytesRead === 0)
          break;
        pos2 += bytesRead;
        p.write(buf.subarray(0, bytesRead));
      }
      p.end();
    }
  } finally {
    if (typeof fd === "number") {
      try {
        fs4.closeSync(fd);
      } catch (er) {}
    }
  }
};
var listFile = (opt, _files) => {
  const parse3 = new Parser(opt);
  const readSize = opt.maxReadSize || 16 * 1024 * 1024;
  const file = opt.file;
  const p = new Promise((resolve5, reject) => {
    parse3.on("error", reject);
    parse3.on("end", resolve5);
    fs4.stat(file, (er, stat3) => {
      if (er) {
        reject(er);
      } else {
        const stream = new ReadStream(file, {
          readSize,
          size: stat3.size
        });
        stream.on("error", reject);
        stream.pipe(parse3);
      }
    });
  });
  return p;
};
var list = makeCommand(listFileSync, listFile, (opt) => new Parser(opt), (opt) => new Parser(opt), (opt, files) => {
  if (files?.length)
    filesFilter(opt, files);
  if (!opt.noResume)
    onReadEntryFunction(opt);
});

// node_modules/tar/dist/esm/pack.js
import fs6 from "fs";

// node_modules/tar/dist/esm/write-entry.js
import fs5 from "fs";
import path2 from "path";

// node_modules/tar/dist/esm/mode-fix.js
var modeFix = (mode, isDir, portable) => {
  mode &= 4095;
  if (portable) {
    mode = (mode | 384) & ~18;
  }
  if (isDir) {
    if (mode & 256) {
      mode |= 64;
    }
    if (mode & 32) {
      mode |= 8;
    }
    if (mode & 4) {
      mode |= 1;
    }
  }
  return mode;
};

// node_modules/tar/dist/esm/strip-absolute-path.js
import { win32 } from "node:path";
var { isAbsolute: isAbsolute2, parse: parse3 } = win32;
var stripAbsolutePath = (path2) => {
  let r2 = "";
  let parsed = parse3(path2);
  while (isAbsolute2(path2) || parsed.root) {
    const root = path2.charAt(0) === "/" && path2.slice(0, 4) !== "//?/" ? "/" : parsed.root;
    path2 = path2.slice(root.length);
    r2 += root;
    parsed = parse3(path2);
  }
  return [r2, path2];
};

// node_modules/tar/dist/esm/winchars.js
var raw = ["|", "<", ">", "?", ":"];
var win = raw.map((char) => String.fromCharCode(61440 + char.charCodeAt(0)));
var toWin = new Map(raw.map((char, i) => [char, win[i]]));
var toRaw = new Map(win.map((char, i) => [char, raw[i]]));
var encode2 = (s) => raw.reduce((s2, c2) => s2.split(c2).join(toWin.get(c2)), s);
var decode = (s) => win.reduce((s2, c2) => s2.split(c2).join(toRaw.get(c2)), s);

// node_modules/tar/dist/esm/write-entry.js
var prefixPath = (path3, prefix) => {
  if (!prefix) {
    return normalizeWindowsPath(path3);
  }
  path3 = normalizeWindowsPath(path3).replace(/^\.(\/|$)/, "");
  return stripTrailingSlashes(prefix) + "/" + path3;
};
var maxReadSize = 16 * 1024 * 1024;
var PROCESS = Symbol("process");
var FILE = Symbol("file");
var DIRECTORY = Symbol("directory");
var SYMLINK = Symbol("symlink");
var HARDLINK = Symbol("hardlink");
var HEADER = Symbol("header");
var READ4 = Symbol("read");
var LSTAT = Symbol("lstat");
var ONLSTAT = Symbol("onlstat");
var ONREAD = Symbol("onread");
var ONREADLINK = Symbol("onreadlink");
var OPENFILE = Symbol("openfile");
var ONOPENFILE = Symbol("onopenfile");
var CLOSE = Symbol("close");
var MODE = Symbol("mode");
var AWAITDRAIN = Symbol("awaitDrain");
var ONDRAIN = Symbol("ondrain");
var PREFIX = Symbol("prefix");

class WriteEntry extends Minipass3 {
  path;
  portable;
  myuid = process.getuid && process.getuid() || 0;
  myuser = process.env.USER || "";
  maxReadSize;
  linkCache;
  statCache;
  preservePaths;
  cwd;
  strict;
  mtime;
  noPax;
  noMtime;
  prefix;
  fd;
  blockLen = 0;
  blockRemain = 0;
  buf;
  pos = 0;
  remain = 0;
  length = 0;
  offset = 0;
  win32;
  absolute;
  header;
  type;
  linkpath;
  stat;
  onWriteEntry;
  #hadError = false;
  constructor(p, opt_ = {}) {
    const opt = dealias(opt_);
    super();
    this.path = normalizeWindowsPath(p);
    this.portable = !!opt.portable;
    this.maxReadSize = opt.maxReadSize || maxReadSize;
    this.linkCache = opt.linkCache || new Map;
    this.statCache = opt.statCache || new Map;
    this.preservePaths = !!opt.preservePaths;
    this.cwd = normalizeWindowsPath(opt.cwd || process.cwd());
    this.strict = !!opt.strict;
    this.noPax = !!opt.noPax;
    this.noMtime = !!opt.noMtime;
    this.mtime = opt.mtime;
    this.prefix = opt.prefix ? normalizeWindowsPath(opt.prefix) : undefined;
    this.onWriteEntry = opt.onWriteEntry;
    if (typeof opt.onwarn === "function") {
      this.on("warn", opt.onwarn);
    }
    let pathWarn = false;
    if (!this.preservePaths) {
      const [root, stripped] = stripAbsolutePath(this.path);
      if (root && typeof stripped === "string") {
        this.path = stripped;
        pathWarn = root;
      }
    }
    this.win32 = !!opt.win32 || process.platform === "win32";
    if (this.win32) {
      this.path = decode(this.path.replace(/\\/g, "/"));
      p = p.replace(/\\/g, "/");
    }
    this.absolute = normalizeWindowsPath(opt.absolute || path2.resolve(this.cwd, p));
    if (this.path === "") {
      this.path = "./";
    }
    if (pathWarn) {
      this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
        entry: this,
        path: pathWarn + this.path
      });
    }
    const cs = this.statCache.get(this.absolute);
    if (cs) {
      this[ONLSTAT](cs);
    } else {
      this[LSTAT]();
    }
  }
  warn(code2, message, data = {}) {
    return warnMethod(this, code2, message, data);
  }
  emit(ev, ...data) {
    if (ev === "error") {
      this.#hadError = true;
    }
    return super.emit(ev, ...data);
  }
  [LSTAT]() {
    fs5.lstat(this.absolute, (er, stat3) => {
      if (er) {
        return this.emit("error", er);
      }
      this[ONLSTAT](stat3);
    });
  }
  [ONLSTAT](stat3) {
    this.statCache.set(this.absolute, stat3);
    this.stat = stat3;
    if (!stat3.isFile()) {
      stat3.size = 0;
    }
    this.type = getType(stat3);
    this.emit("stat", stat3);
    this[PROCESS]();
  }
  [PROCESS]() {
    switch (this.type) {
      case "File":
        return this[FILE]();
      case "Directory":
        return this[DIRECTORY]();
      case "SymbolicLink":
        return this[SYMLINK]();
      default:
        return this.end();
    }
  }
  [MODE](mode) {
    return modeFix(mode, this.type === "Directory", this.portable);
  }
  [PREFIX](path3) {
    return prefixPath(path3, this.prefix);
  }
  [HEADER]() {
    if (!this.stat) {
      throw new Error("cannot write header before stat");
    }
    if (this.type === "Directory" && this.portable) {
      this.noMtime = true;
    }
    this.onWriteEntry?.(this);
    this.header = new Header({
      path: this[PREFIX](this.path),
      linkpath: this.type === "Link" && this.linkpath !== undefined ? this[PREFIX](this.linkpath) : this.linkpath,
      mode: this[MODE](this.stat.mode),
      uid: this.portable ? undefined : this.stat.uid,
      gid: this.portable ? undefined : this.stat.gid,
      size: this.stat.size,
      mtime: this.noMtime ? undefined : this.mtime || this.stat.mtime,
      type: this.type === "Unsupported" ? undefined : this.type,
      uname: this.portable ? undefined : this.stat.uid === this.myuid ? this.myuser : "",
      atime: this.portable ? undefined : this.stat.atime,
      ctime: this.portable ? undefined : this.stat.ctime
    });
    if (this.header.encode() && !this.noPax) {
      super.write(new Pax({
        atime: this.portable ? undefined : this.header.atime,
        ctime: this.portable ? undefined : this.header.ctime,
        gid: this.portable ? undefined : this.header.gid,
        mtime: this.noMtime ? undefined : this.mtime || this.header.mtime,
        path: this[PREFIX](this.path),
        linkpath: this.type === "Link" && this.linkpath !== undefined ? this[PREFIX](this.linkpath) : this.linkpath,
        size: this.header.size,
        uid: this.portable ? undefined : this.header.uid,
        uname: this.portable ? undefined : this.header.uname,
        dev: this.portable ? undefined : this.stat.dev,
        ino: this.portable ? undefined : this.stat.ino,
        nlink: this.portable ? undefined : this.stat.nlink
      }).encode());
    }
    const block = this.header?.block;
    if (!block) {
      throw new Error("failed to encode header");
    }
    super.write(block);
  }
  [DIRECTORY]() {
    if (!this.stat) {
      throw new Error("cannot create directory entry without stat");
    }
    if (this.path.slice(-1) !== "/") {
      this.path += "/";
    }
    this.stat.size = 0;
    this[HEADER]();
    this.end();
  }
  [SYMLINK]() {
    fs5.readlink(this.absolute, (er, linkpath) => {
      if (er) {
        return this.emit("error", er);
      }
      this[ONREADLINK](linkpath);
    });
  }
  [ONREADLINK](linkpath) {
    this.linkpath = normalizeWindowsPath(linkpath);
    this[HEADER]();
    this.end();
  }
  [HARDLINK](linkpath) {
    if (!this.stat) {
      throw new Error("cannot create link entry without stat");
    }
    this.type = "Link";
    this.linkpath = normalizeWindowsPath(path2.relative(this.cwd, linkpath));
    this.stat.size = 0;
    this[HEADER]();
    this.end();
  }
  [FILE]() {
    if (!this.stat) {
      throw new Error("cannot create file entry without stat");
    }
    if (this.stat.nlink > 1) {
      const linkKey = `${this.stat.dev}:${this.stat.ino}`;
      const linkpath = this.linkCache.get(linkKey);
      if (linkpath?.indexOf(this.cwd) === 0) {
        return this[HARDLINK](linkpath);
      }
      this.linkCache.set(linkKey, this.absolute);
    }
    this[HEADER]();
    if (this.stat.size === 0) {
      return this.end();
    }
    this[OPENFILE]();
  }
  [OPENFILE]() {
    fs5.open(this.absolute, "r", (er, fd) => {
      if (er) {
        return this.emit("error", er);
      }
      this[ONOPENFILE](fd);
    });
  }
  [ONOPENFILE](fd) {
    this.fd = fd;
    if (this.#hadError) {
      return this[CLOSE]();
    }
    if (!this.stat) {
      throw new Error("should stat before calling onopenfile");
    }
    this.blockLen = 512 * Math.ceil(this.stat.size / 512);
    this.blockRemain = this.blockLen;
    const bufLen = Math.min(this.blockLen, this.maxReadSize);
    this.buf = Buffer.allocUnsafe(bufLen);
    this.offset = 0;
    this.pos = 0;
    this.remain = this.stat.size;
    this.length = this.buf.length;
    this[READ4]();
  }
  [READ4]() {
    const { fd, buf, offset, length, pos: pos2 } = this;
    if (fd === undefined || buf === undefined) {
      throw new Error("cannot read file without first opening");
    }
    fs5.read(fd, buf, offset, length, pos2, (er, bytesRead) => {
      if (er) {
        return this[CLOSE](() => this.emit("error", er));
      }
      this[ONREAD](bytesRead);
    });
  }
  [CLOSE](cb = () => {}) {
    if (this.fd !== undefined)
      fs5.close(this.fd, cb);
  }
  [ONREAD](bytesRead) {
    if (bytesRead <= 0 && this.remain > 0) {
      const er = Object.assign(new Error("encountered unexpected EOF"), {
        path: this.absolute,
        syscall: "read",
        code: "EOF"
      });
      return this[CLOSE](() => this.emit("error", er));
    }
    if (bytesRead > this.remain) {
      const er = Object.assign(new Error("did not encounter expected EOF"), {
        path: this.absolute,
        syscall: "read",
        code: "EOF"
      });
      return this[CLOSE](() => this.emit("error", er));
    }
    if (!this.buf) {
      throw new Error("should have created buffer prior to reading");
    }
    if (bytesRead === this.remain) {
      for (let i = bytesRead;i < this.length && bytesRead < this.blockRemain; i++) {
        this.buf[i + this.offset] = 0;
        bytesRead++;
        this.remain++;
      }
    }
    const chunk = this.offset === 0 && bytesRead === this.buf.length ? this.buf : this.buf.subarray(this.offset, this.offset + bytesRead);
    const flushed = this.write(chunk);
    if (!flushed) {
      this[AWAITDRAIN](() => this[ONDRAIN]());
    } else {
      this[ONDRAIN]();
    }
  }
  [AWAITDRAIN](cb) {
    this.once("drain", cb);
  }
  write(chunk, encoding, cb) {
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = undefined;
    }
    if (typeof chunk === "string") {
      chunk = Buffer.from(chunk, typeof encoding === "string" ? encoding : "utf8");
    }
    if (this.blockRemain < chunk.length) {
      const er = Object.assign(new Error("writing more data than expected"), {
        path: this.absolute
      });
      return this.emit("error", er);
    }
    this.remain -= chunk.length;
    this.blockRemain -= chunk.length;
    this.pos += chunk.length;
    this.offset += chunk.length;
    return super.write(chunk, null, cb);
  }
  [ONDRAIN]() {
    if (!this.remain) {
      if (this.blockRemain) {
        super.write(Buffer.alloc(this.blockRemain));
      }
      return this[CLOSE]((er) => er ? this.emit("error", er) : this.end());
    }
    if (!this.buf) {
      throw new Error("buffer lost somehow in ONDRAIN");
    }
    if (this.offset >= this.length) {
      this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length));
      this.offset = 0;
    }
    this.length = this.buf.length - this.offset;
    this[READ4]();
  }
}

class WriteEntrySync extends WriteEntry {
  sync = true;
  [LSTAT]() {
    this[ONLSTAT](fs5.lstatSync(this.absolute));
  }
  [SYMLINK]() {
    this[ONREADLINK](fs5.readlinkSync(this.absolute));
  }
  [OPENFILE]() {
    this[ONOPENFILE](fs5.openSync(this.absolute, "r"));
  }
  [READ4]() {
    let threw = true;
    try {
      const { fd, buf, offset, length, pos: pos2 } = this;
      if (fd === undefined || buf === undefined) {
        throw new Error("fd and buf must be set in READ method");
      }
      const bytesRead = fs5.readSync(fd, buf, offset, length, pos2);
      this[ONREAD](bytesRead);
      threw = false;
    } finally {
      if (threw) {
        try {
          this[CLOSE](() => {});
        } catch (er) {}
      }
    }
  }
  [AWAITDRAIN](cb) {
    cb();
  }
  [CLOSE](cb = () => {}) {
    if (this.fd !== undefined)
      fs5.closeSync(this.fd);
    cb();
  }
}

class WriteEntryTar extends Minipass3 {
  blockLen = 0;
  blockRemain = 0;
  buf = 0;
  pos = 0;
  remain = 0;
  length = 0;
  preservePaths;
  portable;
  strict;
  noPax;
  noMtime;
  readEntry;
  type;
  prefix;
  path;
  mode;
  uid;
  gid;
  uname;
  gname;
  header;
  mtime;
  atime;
  ctime;
  linkpath;
  size;
  onWriteEntry;
  warn(code2, message, data = {}) {
    return warnMethod(this, code2, message, data);
  }
  constructor(readEntry, opt_ = {}) {
    const opt = dealias(opt_);
    super();
    this.preservePaths = !!opt.preservePaths;
    this.portable = !!opt.portable;
    this.strict = !!opt.strict;
    this.noPax = !!opt.noPax;
    this.noMtime = !!opt.noMtime;
    this.onWriteEntry = opt.onWriteEntry;
    this.readEntry = readEntry;
    const { type } = readEntry;
    if (type === "Unsupported") {
      throw new Error("writing entry that should be ignored");
    }
    this.type = type;
    if (this.type === "Directory" && this.portable) {
      this.noMtime = true;
    }
    this.prefix = opt.prefix;
    this.path = normalizeWindowsPath(readEntry.path);
    this.mode = readEntry.mode !== undefined ? this[MODE](readEntry.mode) : undefined;
    this.uid = this.portable ? undefined : readEntry.uid;
    this.gid = this.portable ? undefined : readEntry.gid;
    this.uname = this.portable ? undefined : readEntry.uname;
    this.gname = this.portable ? undefined : readEntry.gname;
    this.size = readEntry.size;
    this.mtime = this.noMtime ? undefined : opt.mtime || readEntry.mtime;
    this.atime = this.portable ? undefined : readEntry.atime;
    this.ctime = this.portable ? undefined : readEntry.ctime;
    this.linkpath = readEntry.linkpath !== undefined ? normalizeWindowsPath(readEntry.linkpath) : undefined;
    if (typeof opt.onwarn === "function") {
      this.on("warn", opt.onwarn);
    }
    let pathWarn = false;
    if (!this.preservePaths) {
      const [root, stripped] = stripAbsolutePath(this.path);
      if (root && typeof stripped === "string") {
        this.path = stripped;
        pathWarn = root;
      }
    }
    this.remain = readEntry.size;
    this.blockRemain = readEntry.startBlockSize;
    this.onWriteEntry?.(this);
    this.header = new Header({
      path: this[PREFIX](this.path),
      linkpath: this.type === "Link" && this.linkpath !== undefined ? this[PREFIX](this.linkpath) : this.linkpath,
      mode: this.mode,
      uid: this.portable ? undefined : this.uid,
      gid: this.portable ? undefined : this.gid,
      size: this.size,
      mtime: this.noMtime ? undefined : this.mtime,
      type: this.type,
      uname: this.portable ? undefined : this.uname,
      atime: this.portable ? undefined : this.atime,
      ctime: this.portable ? undefined : this.ctime
    });
    if (pathWarn) {
      this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
        entry: this,
        path: pathWarn + this.path
      });
    }
    if (this.header.encode() && !this.noPax) {
      super.write(new Pax({
        atime: this.portable ? undefined : this.atime,
        ctime: this.portable ? undefined : this.ctime,
        gid: this.portable ? undefined : this.gid,
        mtime: this.noMtime ? undefined : this.mtime,
        path: this[PREFIX](this.path),
        linkpath: this.type === "Link" && this.linkpath !== undefined ? this[PREFIX](this.linkpath) : this.linkpath,
        size: this.size,
        uid: this.portable ? undefined : this.uid,
        uname: this.portable ? undefined : this.uname,
        dev: this.portable ? undefined : this.readEntry.dev,
        ino: this.portable ? undefined : this.readEntry.ino,
        nlink: this.portable ? undefined : this.readEntry.nlink
      }).encode());
    }
    const b3 = this.header?.block;
    if (!b3)
      throw new Error("failed to encode header");
    super.write(b3);
    readEntry.pipe(this);
  }
  [PREFIX](path3) {
    return prefixPath(path3, this.prefix);
  }
  [MODE](mode) {
    return modeFix(mode, this.type === "Directory", this.portable);
  }
  write(chunk, encoding, cb) {
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = undefined;
    }
    if (typeof chunk === "string") {
      chunk = Buffer.from(chunk, typeof encoding === "string" ? encoding : "utf8");
    }
    const writeLen = chunk.length;
    if (writeLen > this.blockRemain) {
      throw new Error("writing more to entry than is appropriate");
    }
    this.blockRemain -= writeLen;
    return super.write(chunk, cb);
  }
  end(chunk, encoding, cb) {
    if (this.blockRemain) {
      super.write(Buffer.alloc(this.blockRemain));
    }
    if (typeof chunk === "function") {
      cb = chunk;
      encoding = undefined;
      chunk = undefined;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = undefined;
    }
    if (typeof chunk === "string") {
      chunk = Buffer.from(chunk, encoding ?? "utf8");
    }
    if (cb)
      this.once("finish", cb);
    chunk ? super.end(chunk, cb) : super.end(cb);
    return this;
  }
}
var getType = (stat3) => stat3.isFile() ? "File" : stat3.isDirectory() ? "Directory" : stat3.isSymbolicLink() ? "SymbolicLink" : "Unsupported";

// node_modules/yallist/dist/esm/index.js
class Yallist {
  tail;
  head;
  length = 0;
  static create(list2 = []) {
    return new Yallist(list2);
  }
  constructor(list2 = []) {
    for (const item of list2) {
      this.push(item);
    }
  }
  *[Symbol.iterator]() {
    for (let walker = this.head;walker; walker = walker.next) {
      yield walker.value;
    }
  }
  removeNode(node) {
    if (node.list !== this) {
      throw new Error("removing node which does not belong to this list");
    }
    const next = node.next;
    const prev = node.prev;
    if (next) {
      next.prev = prev;
    }
    if (prev) {
      prev.next = next;
    }
    if (node === this.head) {
      this.head = next;
    }
    if (node === this.tail) {
      this.tail = prev;
    }
    this.length--;
    node.next = undefined;
    node.prev = undefined;
    node.list = undefined;
    return next;
  }
  unshiftNode(node) {
    if (node === this.head) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    const head = this.head;
    node.list = this;
    node.next = head;
    if (head) {
      head.prev = node;
    }
    this.head = node;
    if (!this.tail) {
      this.tail = node;
    }
    this.length++;
  }
  pushNode(node) {
    if (node === this.tail) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    const tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) {
      tail.next = node;
    }
    this.tail = node;
    if (!this.head) {
      this.head = node;
    }
    this.length++;
  }
  push(...args) {
    for (let i = 0, l2 = args.length;i < l2; i++) {
      push(this, args[i]);
    }
    return this.length;
  }
  unshift(...args) {
    for (var i = 0, l2 = args.length;i < l2; i++) {
      unshift(this, args[i]);
    }
    return this.length;
  }
  pop() {
    if (!this.tail) {
      return;
    }
    const res = this.tail.value;
    const t = this.tail;
    this.tail = this.tail.prev;
    if (this.tail) {
      this.tail.next = undefined;
    } else {
      this.head = undefined;
    }
    t.list = undefined;
    this.length--;
    return res;
  }
  shift() {
    if (!this.head) {
      return;
    }
    const res = this.head.value;
    const h2 = this.head;
    this.head = this.head.next;
    if (this.head) {
      this.head.prev = undefined;
    } else {
      this.tail = undefined;
    }
    h2.list = undefined;
    this.length--;
    return res;
  }
  forEach(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this.head, i = 0;walker; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  }
  forEachReverse(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this.tail, i = this.length - 1;walker; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  }
  get(n) {
    let i = 0;
    let walker = this.head;
    for (;!!walker && i < n; i++) {
      walker = walker.next;
    }
    if (i === n && !!walker) {
      return walker.value;
    }
  }
  getReverse(n) {
    let i = 0;
    let walker = this.tail;
    for (;!!walker && i < n; i++) {
      walker = walker.prev;
    }
    if (i === n && !!walker) {
      return walker.value;
    }
  }
  map(fn, thisp) {
    thisp = thisp || this;
    const res = new Yallist;
    for (let walker = this.head;walker; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }
    return res;
  }
  mapReverse(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist;
    for (let walker = this.tail;walker; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }
    return res;
  }
  reduce(fn, initial) {
    let acc;
    let walker = this.head;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = 0;walker; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }
    return acc;
  }
  reduceReverse(fn, initial) {
    let acc;
    let walker = this.tail;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (let i = this.length - 1;walker; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }
    return acc;
  }
  toArray() {
    const arr = new Array(this.length);
    for (let i = 0, walker = this.head;walker; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }
    return arr;
  }
  toArrayReverse() {
    const arr = new Array(this.length);
    for (let i = 0, walker = this.tail;walker; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }
    return arr;
  }
  slice(from = 0, to = this.length) {
    if (to < 0) {
      to += this.length;
    }
    if (from < 0) {
      from += this.length;
    }
    const ret = new Yallist;
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    let walker = this.head;
    let i = 0;
    for (i = 0;!!walker && i < from; i++) {
      walker = walker.next;
    }
    for (;!!walker && i < to; i++, walker = walker.next) {
      ret.push(walker.value);
    }
    return ret;
  }
  sliceReverse(from = 0, to = this.length) {
    if (to < 0) {
      to += this.length;
    }
    if (from < 0) {
      from += this.length;
    }
    const ret = new Yallist;
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    let i = this.length;
    let walker = this.tail;
    for (;!!walker && i > to; i--) {
      walker = walker.prev;
    }
    for (;!!walker && i > from; i--, walker = walker.prev) {
      ret.push(walker.value);
    }
    return ret;
  }
  splice(start, deleteCount = 0, ...nodes) {
    if (start > this.length) {
      start = this.length - 1;
    }
    if (start < 0) {
      start = this.length + start;
    }
    let walker = this.head;
    for (let i = 0;!!walker && i < start; i++) {
      walker = walker.next;
    }
    const ret = [];
    for (let i = 0;!!walker && i < deleteCount; i++) {
      ret.push(walker.value);
      walker = this.removeNode(walker);
    }
    if (!walker) {
      walker = this.tail;
    } else if (walker !== this.tail) {
      walker = walker.prev;
    }
    for (const v2 of nodes) {
      walker = insertAfter(this, walker, v2);
    }
    return ret;
  }
  reverse() {
    const head = this.head;
    const tail = this.tail;
    for (let walker = head;walker; walker = walker.prev) {
      const p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
  }
}
function insertAfter(self2, node, value) {
  const prev = node;
  const next = node ? node.next : self2.head;
  const inserted = new Node2(value, prev, next, self2);
  if (inserted.next === undefined) {
    self2.tail = inserted;
  }
  if (inserted.prev === undefined) {
    self2.head = inserted;
  }
  self2.length++;
  return inserted;
}
function push(self2, item) {
  self2.tail = new Node2(item, self2.tail, undefined, self2);
  if (!self2.head) {
    self2.head = self2.tail;
  }
  self2.length++;
}
function unshift(self2, item) {
  self2.head = new Node2(item, undefined, self2.head, self2);
  if (!self2.tail) {
    self2.tail = self2.head;
  }
  self2.length++;
}

class Node2 {
  list;
  next;
  prev;
  value;
  constructor(value, prev, next, list2) {
    this.list = list2;
    this.value = value;
    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = undefined;
    }
    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = undefined;
    }
  }
}

// node_modules/tar/dist/esm/pack.js
import path3 from "path";
class PackJob {
  path;
  absolute;
  entry;
  stat;
  readdir;
  pending = false;
  ignore = false;
  piped = false;
  constructor(path4, absolute) {
    this.path = path4 || "./";
    this.absolute = absolute;
  }
}
var EOF4 = Buffer.alloc(1024);
var ONSTAT = Symbol("onStat");
var ENDED2 = Symbol("ended");
var QUEUE2 = Symbol("queue");
var CURRENT = Symbol("current");
var PROCESS2 = Symbol("process");
var PROCESSING = Symbol("processing");
var PROCESSJOB = Symbol("processJob");
var JOBS = Symbol("jobs");
var JOBDONE = Symbol("jobDone");
var ADDFSENTRY = Symbol("addFSEntry");
var ADDTARENTRY = Symbol("addTarEntry");
var STAT = Symbol("stat");
var READDIR = Symbol("readdir");
var ONREADDIR = Symbol("onreaddir");
var PIPE = Symbol("pipe");
var ENTRY = Symbol("entry");
var ENTRYOPT = Symbol("entryOpt");
var WRITEENTRYCLASS = Symbol("writeEntryClass");
var WRITE = Symbol("write");
var ONDRAIN2 = Symbol("ondrain");

class Pack extends Minipass3 {
  sync = false;
  opt;
  cwd;
  maxReadSize;
  preservePaths;
  strict;
  noPax;
  prefix;
  linkCache;
  statCache;
  file;
  portable;
  zip;
  readdirCache;
  noDirRecurse;
  follow;
  noMtime;
  mtime;
  filter;
  jobs;
  [WRITEENTRYCLASS];
  onWriteEntry;
  [QUEUE2];
  [JOBS] = 0;
  [PROCESSING] = false;
  [ENDED2] = false;
  constructor(opt = {}) {
    super();
    this.opt = opt;
    this.file = opt.file || "";
    this.cwd = opt.cwd || process.cwd();
    this.maxReadSize = opt.maxReadSize;
    this.preservePaths = !!opt.preservePaths;
    this.strict = !!opt.strict;
    this.noPax = !!opt.noPax;
    this.prefix = normalizeWindowsPath(opt.prefix || "");
    this.linkCache = opt.linkCache || new Map;
    this.statCache = opt.statCache || new Map;
    this.readdirCache = opt.readdirCache || new Map;
    this.onWriteEntry = opt.onWriteEntry;
    this[WRITEENTRYCLASS] = WriteEntry;
    if (typeof opt.onwarn === "function") {
      this.on("warn", opt.onwarn);
    }
    this.portable = !!opt.portable;
    if (opt.gzip || opt.brotli || opt.zstd) {
      if ((opt.gzip ? 1 : 0) + (opt.brotli ? 1 : 0) + (opt.zstd ? 1 : 0) > 1) {
        throw new TypeError("gzip, brotli, zstd are mutually exclusive");
      }
      if (opt.gzip) {
        if (typeof opt.gzip !== "object") {
          opt.gzip = {};
        }
        if (this.portable) {
          opt.gzip.portable = true;
        }
        this.zip = new Gzip(opt.gzip);
      }
      if (opt.brotli) {
        if (typeof opt.brotli !== "object") {
          opt.brotli = {};
        }
        this.zip = new BrotliCompress(opt.brotli);
      }
      if (opt.zstd) {
        if (typeof opt.zstd !== "object") {
          opt.zstd = {};
        }
        this.zip = new ZstdCompress(opt.zstd);
      }
      if (!this.zip)
        throw new Error("impossible");
      const zip = this.zip;
      zip.on("data", (chunk) => super.write(chunk));
      zip.on("end", () => super.end());
      zip.on("drain", () => this[ONDRAIN2]());
      this.on("resume", () => zip.resume());
    } else {
      this.on("drain", this[ONDRAIN2]);
    }
    this.noDirRecurse = !!opt.noDirRecurse;
    this.follow = !!opt.follow;
    this.noMtime = !!opt.noMtime;
    if (opt.mtime)
      this.mtime = opt.mtime;
    this.filter = typeof opt.filter === "function" ? opt.filter : () => true;
    this[QUEUE2] = new Yallist;
    this[JOBS] = 0;
    this.jobs = Number(opt.jobs) || 4;
    this[PROCESSING] = false;
    this[ENDED2] = false;
  }
  [WRITE](chunk) {
    return super.write(chunk);
  }
  add(path4) {
    this.write(path4);
    return this;
  }
  end(path4, encoding, cb) {
    if (typeof path4 === "function") {
      cb = path4;
      path4 = undefined;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = undefined;
    }
    if (path4) {
      this.add(path4);
    }
    this[ENDED2] = true;
    this[PROCESS2]();
    if (cb)
      cb();
    return this;
  }
  write(path4) {
    if (this[ENDED2]) {
      throw new Error("write after end");
    }
    if (path4 instanceof ReadEntry) {
      this[ADDTARENTRY](path4);
    } else {
      this[ADDFSENTRY](path4);
    }
    return this.flowing;
  }
  [ADDTARENTRY](p) {
    const absolute = normalizeWindowsPath(path3.resolve(this.cwd, p.path));
    if (!this.filter(p.path, p)) {
      p.resume();
    } else {
      const job = new PackJob(p.path, absolute);
      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));
      job.entry.on("end", () => this[JOBDONE](job));
      this[JOBS] += 1;
      this[QUEUE2].push(job);
    }
    this[PROCESS2]();
  }
  [ADDFSENTRY](p) {
    const absolute = normalizeWindowsPath(path3.resolve(this.cwd, p));
    this[QUEUE2].push(new PackJob(p, absolute));
    this[PROCESS2]();
  }
  [STAT](job) {
    job.pending = true;
    this[JOBS] += 1;
    const stat3 = this.follow ? "stat" : "lstat";
    fs6[stat3](job.absolute, (er, stat4) => {
      job.pending = false;
      this[JOBS] -= 1;
      if (er) {
        this.emit("error", er);
      } else {
        this[ONSTAT](job, stat4);
      }
    });
  }
  [ONSTAT](job, stat3) {
    this.statCache.set(job.absolute, stat3);
    job.stat = stat3;
    if (!this.filter(job.path, stat3)) {
      job.ignore = true;
    } else if (stat3.isFile() && stat3.nlink > 1 && job === this[CURRENT] && !this.linkCache.get(`${stat3.dev}:${stat3.ino}`) && !this.sync) {
      this[PROCESSJOB](job);
    }
    this[PROCESS2]();
  }
  [READDIR](job) {
    job.pending = true;
    this[JOBS] += 1;
    fs6.readdir(job.absolute, (er, entries) => {
      job.pending = false;
      this[JOBS] -= 1;
      if (er) {
        return this.emit("error", er);
      }
      this[ONREADDIR](job, entries);
    });
  }
  [ONREADDIR](job, entries) {
    this.readdirCache.set(job.absolute, entries);
    job.readdir = entries;
    this[PROCESS2]();
  }
  [PROCESS2]() {
    if (this[PROCESSING]) {
      return;
    }
    this[PROCESSING] = true;
    for (let w3 = this[QUEUE2].head;!!w3 && this[JOBS] < this.jobs; w3 = w3.next) {
      this[PROCESSJOB](w3.value);
      if (w3.value.ignore) {
        const p = w3.next;
        this[QUEUE2].removeNode(w3);
        w3.next = p;
      }
    }
    this[PROCESSING] = false;
    if (this[ENDED2] && !this[QUEUE2].length && this[JOBS] === 0) {
      if (this.zip) {
        this.zip.end(EOF4);
      } else {
        super.write(EOF4);
        super.end();
      }
    }
  }
  get [CURRENT]() {
    return this[QUEUE2] && this[QUEUE2].head && this[QUEUE2].head.value;
  }
  [JOBDONE](_job) {
    this[QUEUE2].shift();
    this[JOBS] -= 1;
    this[PROCESS2]();
  }
  [PROCESSJOB](job) {
    if (job.pending) {
      return;
    }
    if (job.entry) {
      if (job === this[CURRENT] && !job.piped) {
        this[PIPE](job);
      }
      return;
    }
    if (!job.stat) {
      const sc = this.statCache.get(job.absolute);
      if (sc) {
        this[ONSTAT](job, sc);
      } else {
        this[STAT](job);
      }
    }
    if (!job.stat) {
      return;
    }
    if (job.ignore) {
      return;
    }
    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {
      const rc = this.readdirCache.get(job.absolute);
      if (rc) {
        this[ONREADDIR](job, rc);
      } else {
        this[READDIR](job);
      }
      if (!job.readdir) {
        return;
      }
    }
    job.entry = this[ENTRY](job);
    if (!job.entry) {
      job.ignore = true;
      return;
    }
    if (job === this[CURRENT] && !job.piped) {
      this[PIPE](job);
    }
  }
  [ENTRYOPT](job) {
    return {
      onwarn: (code2, msg, data) => this.warn(code2, msg, data),
      noPax: this.noPax,
      cwd: this.cwd,
      absolute: job.absolute,
      preservePaths: this.preservePaths,
      maxReadSize: this.maxReadSize,
      strict: this.strict,
      portable: this.portable,
      linkCache: this.linkCache,
      statCache: this.statCache,
      noMtime: this.noMtime,
      mtime: this.mtime,
      prefix: this.prefix,
      onWriteEntry: this.onWriteEntry
    };
  }
  [ENTRY](job) {
    this[JOBS] += 1;
    try {
      const e2 = new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job));
      return e2.on("end", () => this[JOBDONE](job)).on("error", (er) => this.emit("error", er));
    } catch (er) {
      this.emit("error", er);
    }
  }
  [ONDRAIN2]() {
    if (this[CURRENT] && this[CURRENT].entry) {
      this[CURRENT].entry.resume();
    }
  }
  [PIPE](job) {
    job.piped = true;
    if (job.readdir) {
      job.readdir.forEach((entry) => {
        const p = job.path;
        const base = p === "./" ? "" : p.replace(/\/*$/, "/");
        this[ADDFSENTRY](base + entry);
      });
    }
    const source = job.entry;
    const zip = this.zip;
    if (!source)
      throw new Error("cannot pipe without source");
    if (zip) {
      source.on("data", (chunk) => {
        if (!zip.write(chunk)) {
          source.pause();
        }
      });
    } else {
      source.on("data", (chunk) => {
        if (!super.write(chunk)) {
          source.pause();
        }
      });
    }
  }
  pause() {
    if (this.zip) {
      this.zip.pause();
    }
    return super.pause();
  }
  warn(code2, message, data = {}) {
    warnMethod(this, code2, message, data);
  }
}

class PackSync extends Pack {
  sync = true;
  constructor(opt) {
    super(opt);
    this[WRITEENTRYCLASS] = WriteEntrySync;
  }
  pause() {}
  resume() {}
  [STAT](job) {
    const stat3 = this.follow ? "statSync" : "lstatSync";
    this[ONSTAT](job, fs6[stat3](job.absolute));
  }
  [READDIR](job) {
    this[ONREADDIR](job, fs6.readdirSync(job.absolute));
  }
  [PIPE](job) {
    const source = job.entry;
    const zip = this.zip;
    if (job.readdir) {
      job.readdir.forEach((entry) => {
        const p = job.path;
        const base = p === "./" ? "" : p.replace(/\/*$/, "/");
        this[ADDFSENTRY](base + entry);
      });
    }
    if (!source)
      throw new Error("Cannot pipe without source");
    if (zip) {
      source.on("data", (chunk) => {
        zip.write(chunk);
      });
    } else {
      source.on("data", (chunk) => {
        super[WRITE](chunk);
      });
    }
  }
}

// node_modules/tar/dist/esm/create.js
var createFileSync = (opt, files) => {
  const p = new PackSync(opt);
  const stream = new WriteStreamSync(opt.file, {
    mode: opt.mode || 438
  });
  p.pipe(stream);
  addFilesSync(p, files);
};
var createFile = (opt, files) => {
  const p = new Pack(opt);
  const stream = new WriteStream(opt.file, {
    mode: opt.mode || 438
  });
  p.pipe(stream);
  const promise = new Promise((res, rej) => {
    stream.on("error", rej);
    stream.on("close", res);
    p.on("error", rej);
  });
  addFilesAsync(p, files);
  return promise;
};
var addFilesSync = (p, files) => {
  files.forEach((file) => {
    if (file.charAt(0) === "@") {
      list({
        file: path4.resolve(p.cwd, file.slice(1)),
        sync: true,
        noResume: true,
        onReadEntry: (entry) => p.add(entry)
      });
    } else {
      p.add(file);
    }
  });
  p.end();
};
var addFilesAsync = async (p, files) => {
  for (let i = 0;i < files.length; i++) {
    const file = String(files[i]);
    if (file.charAt(0) === "@") {
      await list({
        file: path4.resolve(String(p.cwd), file.slice(1)),
        noResume: true,
        onReadEntry: (entry) => {
          p.add(entry);
        }
      });
    } else {
      p.add(file);
    }
  }
  p.end();
};
var createSync = (opt, files) => {
  const p = new PackSync(opt);
  addFilesSync(p, files);
  return p;
};
var createAsync = (opt, files) => {
  const p = new Pack(opt);
  addFilesAsync(p, files);
  return p;
};
var create = makeCommand(createFileSync, createFile, createSync, createAsync, (_opt, files) => {
  if (!files?.length) {
    throw new TypeError("no paths specified to add to archive");
  }
});
// node_modules/tar/dist/esm/extract.js
import fs11 from "node:fs";

// node_modules/tar/dist/esm/unpack.js
import assert2 from "node:assert";
import { randomBytes } from "node:crypto";
import fs10 from "node:fs";
import path7 from "node:path";

// node_modules/tar/dist/esm/get-write-flag.js
import fs7 from "fs";
var platform7 = process.env.__FAKE_PLATFORM__ || process.platform;
var isWindows2 = platform7 === "win32";
var { O_CREAT, O_TRUNC, O_WRONLY } = fs7.constants;
var UV_FS_O_FILEMAP = Number(process.env.__FAKE_FS_O_FILENAME__) || fs7.constants.UV_FS_O_FILEMAP || 0;
var fMapEnabled = isWindows2 && !!UV_FS_O_FILEMAP;
var fMapLimit = 512 * 1024;
var fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;
var getWriteFlag = !fMapEnabled ? () => "w" : (size) => size < fMapLimit ? fMapFlag : "w";

// node_modules/chownr/dist/esm/index.js
import fs8 from "node:fs";
import path5 from "node:path";
var lchownSync = (path6, uid, gid) => {
  try {
    return fs8.lchownSync(path6, uid, gid);
  } catch (er) {
    if (er?.code !== "ENOENT")
      throw er;
  }
};
var chown = (cpath, uid, gid, cb) => {
  fs8.lchown(cpath, uid, gid, (er) => {
    cb(er && er?.code !== "ENOENT" ? er : null);
  });
};
var chownrKid = (p, child, uid, gid, cb) => {
  if (child.isDirectory()) {
    chownr(path5.resolve(p, child.name), uid, gid, (er) => {
      if (er)
        return cb(er);
      const cpath = path5.resolve(p, child.name);
      chown(cpath, uid, gid, cb);
    });
  } else {
    const cpath = path5.resolve(p, child.name);
    chown(cpath, uid, gid, cb);
  }
};
var chownr = (p, uid, gid, cb) => {
  fs8.readdir(p, { withFileTypes: true }, (er, children) => {
    if (er) {
      if (er.code === "ENOENT")
        return cb();
      else if (er.code !== "ENOTDIR" && er.code !== "ENOTSUP")
        return cb(er);
    }
    if (er || !children.length)
      return chown(p, uid, gid, cb);
    let len = children.length;
    let errState = null;
    const then = (er2) => {
      if (errState)
        return;
      if (er2)
        return cb(errState = er2);
      if (--len === 0)
        return chown(p, uid, gid, cb);
    };
    for (const child of children) {
      chownrKid(p, child, uid, gid, then);
    }
  });
};
var chownrKidSync = (p, child, uid, gid) => {
  if (child.isDirectory())
    chownrSync(path5.resolve(p, child.name), uid, gid);
  lchownSync(path5.resolve(p, child.name), uid, gid);
};
var chownrSync = (p, uid, gid) => {
  let children;
  try {
    children = fs8.readdirSync(p, { withFileTypes: true });
  } catch (er) {
    const e2 = er;
    if (e2?.code === "ENOENT")
      return;
    else if (e2?.code === "ENOTDIR" || e2?.code === "ENOTSUP")
      return lchownSync(p, uid, gid);
    else
      throw e2;
  }
  for (const child of children) {
    chownrKidSync(p, child, uid, gid);
  }
  return lchownSync(p, uid, gid);
};

// node_modules/tar/dist/esm/mkdir.js
import fs9 from "node:fs";
import fsp from "node:fs/promises";
import path6 from "node:path";

// node_modules/tar/dist/esm/cwd-error.js
class CwdError extends Error {
  path;
  code;
  syscall = "chdir";
  constructor(path6, code2) {
    super(`${code2}: Cannot cd into '${path6}'`);
    this.path = path6;
    this.code = code2;
  }
  get name() {
    return "CwdError";
  }
}

// node_modules/tar/dist/esm/symlink-error.js
class SymlinkError extends Error {
  path;
  symlink;
  syscall = "symlink";
  code = "TAR_SYMLINK_ERROR";
  constructor(symlink3, path6) {
    super("TAR_SYMLINK_ERROR: Cannot extract through symbolic link");
    this.symlink = symlink3;
    this.path = path6;
  }
  get name() {
    return "SymlinkError";
  }
}

// node_modules/tar/dist/esm/mkdir.js
var checkCwd = (dir, cb) => {
  fs9.stat(dir, (er, st) => {
    if (er || !st.isDirectory()) {
      er = new CwdError(dir, er?.code || "ENOTDIR");
    }
    cb(er);
  });
};
var mkdir10 = (dir, opt, cb) => {
  dir = normalizeWindowsPath(dir);
  const umask = opt.umask ?? 18;
  const mode = opt.mode | 448;
  const needChmod = (mode & umask) !== 0;
  const uid = opt.uid;
  const gid = opt.gid;
  const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
  const preserve = opt.preserve;
  const unlink6 = opt.unlink;
  const cwd = normalizeWindowsPath(opt.cwd);
  const done = (er, created) => {
    if (er) {
      cb(er);
    } else {
      if (created && doChown) {
        chownr(created, uid, gid, (er2) => done(er2));
      } else if (needChmod) {
        fs9.chmod(dir, mode, cb);
      } else {
        cb();
      }
    }
  };
  if (dir === cwd) {
    return checkCwd(dir, done);
  }
  if (preserve) {
    return fsp.mkdir(dir, { mode, recursive: true }).then((made) => done(null, made ?? undefined), done);
  }
  const sub = normalizeWindowsPath(path6.relative(cwd, dir));
  const parts = sub.split("/");
  mkdir_(cwd, parts, mode, unlink6, cwd, undefined, done);
};
var mkdir_ = (base, parts, mode, unlink6, cwd, created, cb) => {
  if (!parts.length) {
    return cb(null, created);
  }
  const p = parts.shift();
  const part = normalizeWindowsPath(path6.resolve(base + "/" + p));
  fs9.mkdir(part, mode, onmkdir(part, parts, mode, unlink6, cwd, created, cb));
};
var onmkdir = (part, parts, mode, unlink6, cwd, created, cb) => (er) => {
  if (er) {
    fs9.lstat(part, (statEr, st) => {
      if (statEr) {
        statEr.path = statEr.path && normalizeWindowsPath(statEr.path);
        cb(statEr);
      } else if (st.isDirectory()) {
        mkdir_(part, parts, mode, unlink6, cwd, created, cb);
      } else if (unlink6) {
        fs9.unlink(part, (er2) => {
          if (er2) {
            return cb(er2);
          }
          fs9.mkdir(part, mode, onmkdir(part, parts, mode, unlink6, cwd, created, cb));
        });
      } else if (st.isSymbolicLink()) {
        return cb(new SymlinkError(part, part + "/" + parts.join("/")));
      } else {
        cb(er);
      }
    });
  } else {
    created = created || part;
    mkdir_(part, parts, mode, unlink6, cwd, created, cb);
  }
};
var checkCwdSync = (dir) => {
  let ok = false;
  let code2 = undefined;
  try {
    ok = fs9.statSync(dir).isDirectory();
  } catch (er) {
    code2 = er?.code;
  } finally {
    if (!ok) {
      throw new CwdError(dir, code2 ?? "ENOTDIR");
    }
  }
};
var mkdirSync = (dir, opt) => {
  dir = normalizeWindowsPath(dir);
  const umask = opt.umask ?? 18;
  const mode = opt.mode | 448;
  const needChmod = (mode & umask) !== 0;
  const uid = opt.uid;
  const gid = opt.gid;
  const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
  const preserve = opt.preserve;
  const unlink6 = opt.unlink;
  const cwd = normalizeWindowsPath(opt.cwd);
  const done = (created2) => {
    if (created2 && doChown) {
      chownrSync(created2, uid, gid);
    }
    if (needChmod) {
      fs9.chmodSync(dir, mode);
    }
  };
  if (dir === cwd) {
    checkCwdSync(cwd);
    return done();
  }
  if (preserve) {
    return done(fs9.mkdirSync(dir, { mode, recursive: true }) ?? undefined);
  }
  const sub = normalizeWindowsPath(path6.relative(cwd, dir));
  const parts = sub.split("/");
  let created = undefined;
  for (let p = parts.shift(), part = cwd;p && (part += "/" + p); p = parts.shift()) {
    part = normalizeWindowsPath(path6.resolve(part));
    try {
      fs9.mkdirSync(part, mode);
      created = created || part;
    } catch (er) {
      const st = fs9.lstatSync(part);
      if (st.isDirectory()) {
        continue;
      } else if (unlink6) {
        fs9.unlinkSync(part);
        fs9.mkdirSync(part, mode);
        created = created || part;
        continue;
      } else if (st.isSymbolicLink()) {
        return new SymlinkError(part, part + "/" + parts.join("/"));
      }
    }
  }
  return done(created);
};

// node_modules/tar/dist/esm/path-reservations.js
import { join as join33 } from "node:path";

// node_modules/tar/dist/esm/normalize-unicode.js
var normalizeCache = Object.create(null);
var MAX = 1e4;
var cache = new Set;
var normalizeUnicode = (s) => {
  if (!cache.has(s)) {
    normalizeCache[s] = s.normalize("NFD").toLocaleLowerCase("en").toLocaleUpperCase("en");
  } else {
    cache.delete(s);
  }
  cache.add(s);
  const ret = normalizeCache[s];
  let i = cache.size - MAX;
  if (i > MAX / 10) {
    for (const s2 of cache) {
      cache.delete(s2);
      delete normalizeCache[s2];
      if (--i <= 0)
        break;
    }
  }
  return ret;
};

// node_modules/tar/dist/esm/path-reservations.js
var platform8 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
var isWindows3 = platform8 === "win32";
var getDirs = (path7) => {
  const dirs = path7.split("/").slice(0, -1).reduce((set, path8) => {
    const s = set[set.length - 1];
    if (s !== undefined) {
      path8 = join33(s, path8);
    }
    set.push(path8 || "/");
    return set;
  }, []);
  return dirs;
};

class PathReservations {
  #queues = new Map;
  #reservations = new Map;
  #running = new Set;
  reserve(paths, fn) {
    paths = isWindows3 ? ["win32 parallelization disabled"] : paths.map((p) => {
      return stripTrailingSlashes(join33(normalizeUnicode(p)));
    });
    const dirs = new Set(paths.map((path7) => getDirs(path7)).reduce((a3, b3) => a3.concat(b3)));
    this.#reservations.set(fn, { dirs, paths });
    for (const p of paths) {
      const q3 = this.#queues.get(p);
      if (!q3) {
        this.#queues.set(p, [fn]);
      } else {
        q3.push(fn);
      }
    }
    for (const dir of dirs) {
      const q3 = this.#queues.get(dir);
      if (!q3) {
        this.#queues.set(dir, [new Set([fn])]);
      } else {
        const l2 = q3[q3.length - 1];
        if (l2 instanceof Set) {
          l2.add(fn);
        } else {
          q3.push(new Set([fn]));
        }
      }
    }
    return this.#run(fn);
  }
  #getQueues(fn) {
    const res = this.#reservations.get(fn);
    if (!res) {
      throw new Error("function does not have any path reservations");
    }
    return {
      paths: res.paths.map((path7) => this.#queues.get(path7)),
      dirs: [...res.dirs].map((path7) => this.#queues.get(path7))
    };
  }
  check(fn) {
    const { paths, dirs } = this.#getQueues(fn);
    return paths.every((q3) => q3 && q3[0] === fn) && dirs.every((q3) => q3 && q3[0] instanceof Set && q3[0].has(fn));
  }
  #run(fn) {
    if (this.#running.has(fn) || !this.check(fn)) {
      return false;
    }
    this.#running.add(fn);
    fn(() => this.#clear(fn));
    return true;
  }
  #clear(fn) {
    if (!this.#running.has(fn)) {
      return false;
    }
    const res = this.#reservations.get(fn);
    if (!res) {
      throw new Error("invalid reservation");
    }
    const { paths, dirs } = res;
    const next = new Set;
    for (const path7 of paths) {
      const q3 = this.#queues.get(path7);
      if (!q3 || q3?.[0] !== fn) {
        continue;
      }
      const q0 = q3[1];
      if (!q0) {
        this.#queues.delete(path7);
        continue;
      }
      q3.shift();
      if (typeof q0 === "function") {
        next.add(q0);
      } else {
        for (const f3 of q0) {
          next.add(f3);
        }
      }
    }
    for (const dir of dirs) {
      const q3 = this.#queues.get(dir);
      const q0 = q3?.[0];
      if (!q3 || !(q0 instanceof Set))
        continue;
      if (q0.size === 1 && q3.length === 1) {
        this.#queues.delete(dir);
        continue;
      } else if (q0.size === 1) {
        q3.shift();
        const n = q3[0];
        if (typeof n === "function") {
          next.add(n);
        }
      } else {
        q0.delete(fn);
      }
    }
    this.#running.delete(fn);
    next.forEach((fn2) => this.#run(fn2));
    return true;
  }
}

// node_modules/tar/dist/esm/unpack.js
var ONENTRY = Symbol("onEntry");
var CHECKFS = Symbol("checkFs");
var CHECKFS2 = Symbol("checkFs2");
var ISREUSABLE = Symbol("isReusable");
var MAKEFS = Symbol("makeFs");
var FILE2 = Symbol("file");
var DIRECTORY2 = Symbol("directory");
var LINK = Symbol("link");
var SYMLINK2 = Symbol("symlink");
var HARDLINK2 = Symbol("hardlink");
var UNSUPPORTED = Symbol("unsupported");
var CHECKPATH = Symbol("checkPath");
var STRIPABSOLUTEPATH = Symbol("stripAbsolutePath");
var MKDIR = Symbol("mkdir");
var ONERROR = Symbol("onError");
var PENDING = Symbol("pending");
var PEND = Symbol("pend");
var UNPEND = Symbol("unpend");
var ENDED3 = Symbol("ended");
var MAYBECLOSE = Symbol("maybeClose");
var SKIP = Symbol("skip");
var DOCHOWN = Symbol("doChown");
var UID = Symbol("uid");
var GID = Symbol("gid");
var CHECKED_CWD = Symbol("checkedCwd");
var platform9 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
var isWindows4 = platform9 === "win32";
var DEFAULT_MAX_DEPTH = 1024;
var unlinkFile = (path8, cb) => {
  if (!isWindows4) {
    return fs10.unlink(path8, cb);
  }
  const name2 = path8 + ".DELETE." + randomBytes(16).toString("hex");
  fs10.rename(path8, name2, (er) => {
    if (er) {
      return cb(er);
    }
    fs10.unlink(name2, cb);
  });
};
var unlinkFileSync = (path8) => {
  if (!isWindows4) {
    return fs10.unlinkSync(path8);
  }
  const name2 = path8 + ".DELETE." + randomBytes(16).toString("hex");
  fs10.renameSync(path8, name2);
  fs10.unlinkSync(name2);
};
var uint32 = (a3, b3, c2) => a3 !== undefined && a3 === a3 >>> 0 ? a3 : b3 !== undefined && b3 === b3 >>> 0 ? b3 : c2;

class Unpack extends Parser {
  [ENDED3] = false;
  [CHECKED_CWD] = false;
  [PENDING] = 0;
  reservations = new PathReservations;
  transform;
  writable = true;
  readable = false;
  uid;
  gid;
  setOwner;
  preserveOwner;
  processGid;
  processUid;
  maxDepth;
  forceChown;
  win32;
  newer;
  keep;
  noMtime;
  preservePaths;
  unlink;
  cwd;
  strip;
  processUmask;
  umask;
  dmode;
  fmode;
  chmod;
  constructor(opt = {}) {
    opt.ondone = () => {
      this[ENDED3] = true;
      this[MAYBECLOSE]();
    };
    super(opt);
    this.transform = opt.transform;
    this.chmod = !!opt.chmod;
    if (typeof opt.uid === "number" || typeof opt.gid === "number") {
      if (typeof opt.uid !== "number" || typeof opt.gid !== "number") {
        throw new TypeError("cannot set owner without number uid and gid");
      }
      if (opt.preserveOwner) {
        throw new TypeError("cannot preserve owner in archive and also set owner explicitly");
      }
      this.uid = opt.uid;
      this.gid = opt.gid;
      this.setOwner = true;
    } else {
      this.uid = undefined;
      this.gid = undefined;
      this.setOwner = false;
    }
    if (opt.preserveOwner === undefined && typeof opt.uid !== "number") {
      this.preserveOwner = !!(process.getuid && process.getuid() === 0);
    } else {
      this.preserveOwner = !!opt.preserveOwner;
    }
    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : undefined;
    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : undefined;
    this.maxDepth = typeof opt.maxDepth === "number" ? opt.maxDepth : DEFAULT_MAX_DEPTH;
    this.forceChown = opt.forceChown === true;
    this.win32 = !!opt.win32 || isWindows4;
    this.newer = !!opt.newer;
    this.keep = !!opt.keep;
    this.noMtime = !!opt.noMtime;
    this.preservePaths = !!opt.preservePaths;
    this.unlink = !!opt.unlink;
    this.cwd = normalizeWindowsPath(path7.resolve(opt.cwd || process.cwd()));
    this.strip = Number(opt.strip) || 0;
    this.processUmask = !this.chmod ? 0 : typeof opt.processUmask === "number" ? opt.processUmask : process.umask();
    this.umask = typeof opt.umask === "number" ? opt.umask : this.processUmask;
    this.dmode = opt.dmode || 511 & ~this.umask;
    this.fmode = opt.fmode || 438 & ~this.umask;
    this.on("entry", (entry) => this[ONENTRY](entry));
  }
  warn(code2, msg, data = {}) {
    if (code2 === "TAR_BAD_ARCHIVE" || code2 === "TAR_ABORT") {
      data.recoverable = false;
    }
    return super.warn(code2, msg, data);
  }
  [MAYBECLOSE]() {
    if (this[ENDED3] && this[PENDING] === 0) {
      this.emit("prefinish");
      this.emit("finish");
      this.emit("end");
    }
  }
  [STRIPABSOLUTEPATH](entry, field) {
    const p = entry[field];
    if (!p || this.preservePaths)
      return true;
    const parts = p.split("/");
    if (parts.includes("..") || isWindows4 && /^[a-z]:\.\.$/i.test(parts[0] ?? "")) {
      if (field === "path") {
        this.warn("TAR_ENTRY_ERROR", `${field} contains '..'`, {
          entry,
          [field]: p
        });
        return false;
      } else {
        const entryDir = path7.posix.dirname(entry.path);
        const resolved = path7.posix.normalize(path7.posix.join(entryDir, p));
        if (resolved.startsWith("../") || resolved === "..") {
          this.warn("TAR_ENTRY_ERROR", `${field} escapes extraction directory`, {
            entry,
            [field]: p
          });
          return false;
        }
      }
    }
    const [root, stripped] = stripAbsolutePath(p);
    if (root) {
      entry[field] = String(stripped);
      this.warn("TAR_ENTRY_INFO", `stripping ${root} from absolute ${field}`, {
        entry,
        [field]: p
      });
    }
    return true;
  }
  [CHECKPATH](entry) {
    const p = normalizeWindowsPath(entry.path);
    const parts = p.split("/");
    if (this.strip) {
      if (parts.length < this.strip) {
        return false;
      }
      if (entry.type === "Link") {
        const linkparts = normalizeWindowsPath(String(entry.linkpath)).split("/");
        if (linkparts.length >= this.strip) {
          entry.linkpath = linkparts.slice(this.strip).join("/");
        } else {
          return false;
        }
      }
      parts.splice(0, this.strip);
      entry.path = parts.join("/");
    }
    if (isFinite(this.maxDepth) && parts.length > this.maxDepth) {
      this.warn("TAR_ENTRY_ERROR", "path excessively deep", {
        entry,
        path: p,
        depth: parts.length,
        maxDepth: this.maxDepth
      });
      return false;
    }
    if (!this[STRIPABSOLUTEPATH](entry, "path") || !this[STRIPABSOLUTEPATH](entry, "linkpath")) {
      return false;
    }
    if (path7.isAbsolute(entry.path)) {
      entry.absolute = normalizeWindowsPath(path7.resolve(entry.path));
    } else {
      entry.absolute = normalizeWindowsPath(path7.resolve(this.cwd, entry.path));
    }
    if (!this.preservePaths && typeof entry.absolute === "string" && entry.absolute.indexOf(this.cwd + "/") !== 0 && entry.absolute !== this.cwd) {
      this.warn("TAR_ENTRY_ERROR", "path escaped extraction target", {
        entry,
        path: normalizeWindowsPath(entry.path),
        resolvedPath: entry.absolute,
        cwd: this.cwd
      });
      return false;
    }
    if (entry.absolute === this.cwd && entry.type !== "Directory" && entry.type !== "GNUDumpDir") {
      return false;
    }
    if (this.win32) {
      const { root: aRoot } = path7.win32.parse(String(entry.absolute));
      entry.absolute = aRoot + encode2(String(entry.absolute).slice(aRoot.length));
      const { root: pRoot } = path7.win32.parse(entry.path);
      entry.path = pRoot + encode2(entry.path.slice(pRoot.length));
    }
    return true;
  }
  [ONENTRY](entry) {
    if (!this[CHECKPATH](entry)) {
      return entry.resume();
    }
    assert2.equal(typeof entry.absolute, "string");
    switch (entry.type) {
      case "Directory":
      case "GNUDumpDir":
        if (entry.mode) {
          entry.mode = entry.mode | 448;
        }
      case "File":
      case "OldFile":
      case "ContiguousFile":
      case "Link":
      case "SymbolicLink":
        return this[CHECKFS](entry);
      case "CharacterDevice":
      case "BlockDevice":
      case "FIFO":
      default:
        return this[UNSUPPORTED](entry);
    }
  }
  [ONERROR](er, entry) {
    if (er.name === "CwdError") {
      this.emit("error", er);
    } else {
      this.warn("TAR_ENTRY_ERROR", er, { entry });
      this[UNPEND]();
      entry.resume();
    }
  }
  [MKDIR](dir, mode, cb) {
    mkdir10(normalizeWindowsPath(dir), {
      uid: this.uid,
      gid: this.gid,
      processUid: this.processUid,
      processGid: this.processGid,
      umask: this.processUmask,
      preserve: this.preservePaths,
      unlink: this.unlink,
      cwd: this.cwd,
      mode
    }, cb);
  }
  [DOCHOWN](entry) {
    return this.forceChown || this.preserveOwner && (typeof entry.uid === "number" && entry.uid !== this.processUid || typeof entry.gid === "number" && entry.gid !== this.processGid) || typeof this.uid === "number" && this.uid !== this.processUid || typeof this.gid === "number" && this.gid !== this.processGid;
  }
  [UID](entry) {
    return uint32(this.uid, entry.uid, this.processUid);
  }
  [GID](entry) {
    return uint32(this.gid, entry.gid, this.processGid);
  }
  [FILE2](entry, fullyDone) {
    const mode = typeof entry.mode === "number" ? entry.mode & 4095 : this.fmode;
    const stream = new WriteStream(String(entry.absolute), {
      flags: getWriteFlag(entry.size),
      mode,
      autoClose: false
    });
    stream.on("error", (er) => {
      if (stream.fd) {
        fs10.close(stream.fd, () => {});
      }
      stream.write = () => true;
      this[ONERROR](er, entry);
      fullyDone();
    });
    let actions = 1;
    const done = (er) => {
      if (er) {
        if (stream.fd) {
          fs10.close(stream.fd, () => {});
        }
        this[ONERROR](er, entry);
        fullyDone();
        return;
      }
      if (--actions === 0) {
        if (stream.fd !== undefined) {
          fs10.close(stream.fd, (er2) => {
            if (er2) {
              this[ONERROR](er2, entry);
            } else {
              this[UNPEND]();
            }
            fullyDone();
          });
        }
      }
    };
    stream.on("finish", () => {
      const abs = String(entry.absolute);
      const fd = stream.fd;
      if (typeof fd === "number" && entry.mtime && !this.noMtime) {
        actions++;
        const atime = entry.atime || new Date;
        const mtime = entry.mtime;
        fs10.futimes(fd, atime, mtime, (er) => er ? fs10.utimes(abs, atime, mtime, (er2) => done(er2 && er)) : done());
      }
      if (typeof fd === "number" && this[DOCHOWN](entry)) {
        actions++;
        const uid = this[UID](entry);
        const gid = this[GID](entry);
        if (typeof uid === "number" && typeof gid === "number") {
          fs10.fchown(fd, uid, gid, (er) => er ? fs10.chown(abs, uid, gid, (er2) => done(er2 && er)) : done());
        }
      }
      done();
    });
    const tx = this.transform ? this.transform(entry) || entry : entry;
    if (tx !== entry) {
      tx.on("error", (er) => {
        this[ONERROR](er, entry);
        fullyDone();
      });
      entry.pipe(tx);
    }
    tx.pipe(stream);
  }
  [DIRECTORY2](entry, fullyDone) {
    const mode = typeof entry.mode === "number" ? entry.mode & 4095 : this.dmode;
    this[MKDIR](String(entry.absolute), mode, (er) => {
      if (er) {
        this[ONERROR](er, entry);
        fullyDone();
        return;
      }
      let actions = 1;
      const done = () => {
        if (--actions === 0) {
          fullyDone();
          this[UNPEND]();
          entry.resume();
        }
      };
      if (entry.mtime && !this.noMtime) {
        actions++;
        fs10.utimes(String(entry.absolute), entry.atime || new Date, entry.mtime, done);
      }
      if (this[DOCHOWN](entry)) {
        actions++;
        fs10.chown(String(entry.absolute), Number(this[UID](entry)), Number(this[GID](entry)), done);
      }
      done();
    });
  }
  [UNSUPPORTED](entry) {
    entry.unsupported = true;
    this.warn("TAR_ENTRY_UNSUPPORTED", `unsupported entry type: ${entry.type}`, { entry });
    entry.resume();
  }
  [SYMLINK2](entry, done) {
    this[LINK](entry, String(entry.linkpath), "symlink", done);
  }
  [HARDLINK2](entry, done) {
    const linkpath = normalizeWindowsPath(path7.resolve(this.cwd, String(entry.linkpath)));
    this[LINK](entry, linkpath, "link", done);
  }
  [PEND]() {
    this[PENDING]++;
  }
  [UNPEND]() {
    this[PENDING]--;
    this[MAYBECLOSE]();
  }
  [SKIP](entry) {
    this[UNPEND]();
    entry.resume();
  }
  [ISREUSABLE](entry, st) {
    return entry.type === "File" && !this.unlink && st.isFile() && st.nlink <= 1 && !isWindows4;
  }
  [CHECKFS](entry) {
    this[PEND]();
    const paths = [entry.path];
    if (entry.linkpath) {
      paths.push(entry.linkpath);
    }
    this.reservations.reserve(paths, (done) => this[CHECKFS2](entry, done));
  }
  [CHECKFS2](entry, fullyDone) {
    const done = (er) => {
      fullyDone(er);
    };
    const checkCwd2 = () => {
      this[MKDIR](this.cwd, this.dmode, (er) => {
        if (er) {
          this[ONERROR](er, entry);
          done();
          return;
        }
        this[CHECKED_CWD] = true;
        start();
      });
    };
    const start = () => {
      if (entry.absolute !== this.cwd) {
        const parent = normalizeWindowsPath(path7.dirname(String(entry.absolute)));
        if (parent !== this.cwd) {
          return this[MKDIR](parent, this.dmode, (er) => {
            if (er) {
              this[ONERROR](er, entry);
              done();
              return;
            }
            afterMakeParent();
          });
        }
      }
      afterMakeParent();
    };
    const afterMakeParent = () => {
      fs10.lstat(String(entry.absolute), (lstatEr, st) => {
        if (st && (this.keep || this.newer && st.mtime > (entry.mtime ?? st.mtime))) {
          this[SKIP](entry);
          done();
          return;
        }
        if (lstatEr || this[ISREUSABLE](entry, st)) {
          return this[MAKEFS](null, entry, done);
        }
        if (st.isDirectory()) {
          if (entry.type === "Directory") {
            const needChmod = this.chmod && entry.mode && (st.mode & 4095) !== entry.mode;
            const afterChmod = (er) => this[MAKEFS](er ?? null, entry, done);
            if (!needChmod) {
              return afterChmod();
            }
            return fs10.chmod(String(entry.absolute), Number(entry.mode), afterChmod);
          }
          if (entry.absolute !== this.cwd) {
            return fs10.rmdir(String(entry.absolute), (er) => this[MAKEFS](er ?? null, entry, done));
          }
        }
        if (entry.absolute === this.cwd) {
          return this[MAKEFS](null, entry, done);
        }
        unlinkFile(String(entry.absolute), (er) => this[MAKEFS](er ?? null, entry, done));
      });
    };
    if (this[CHECKED_CWD]) {
      start();
    } else {
      checkCwd2();
    }
  }
  [MAKEFS](er, entry, done) {
    if (er) {
      this[ONERROR](er, entry);
      done();
      return;
    }
    switch (entry.type) {
      case "File":
      case "OldFile":
      case "ContiguousFile":
        return this[FILE2](entry, done);
      case "Link":
        return this[HARDLINK2](entry, done);
      case "SymbolicLink":
        return this[SYMLINK2](entry, done);
      case "Directory":
      case "GNUDumpDir":
        return this[DIRECTORY2](entry, done);
    }
  }
  [LINK](entry, linkpath, link, done) {
    fs10[link](linkpath, String(entry.absolute), (er) => {
      if (er) {
        this[ONERROR](er, entry);
      } else {
        this[UNPEND]();
        entry.resume();
      }
      done();
    });
  }
}
var callSync = (fn) => {
  try {
    return [null, fn()];
  } catch (er) {
    return [er, null];
  }
};

class UnpackSync extends Unpack {
  sync = true;
  [MAKEFS](er, entry) {
    return super[MAKEFS](er, entry, () => {});
  }
  [CHECKFS](entry) {
    if (!this[CHECKED_CWD]) {
      const er2 = this[MKDIR](this.cwd, this.dmode);
      if (er2) {
        return this[ONERROR](er2, entry);
      }
      this[CHECKED_CWD] = true;
    }
    if (entry.absolute !== this.cwd) {
      const parent = normalizeWindowsPath(path7.dirname(String(entry.absolute)));
      if (parent !== this.cwd) {
        const mkParent = this[MKDIR](parent, this.dmode);
        if (mkParent) {
          return this[ONERROR](mkParent, entry);
        }
      }
    }
    const [lstatEr, st] = callSync(() => fs10.lstatSync(String(entry.absolute)));
    if (st && (this.keep || this.newer && st.mtime > (entry.mtime ?? st.mtime))) {
      return this[SKIP](entry);
    }
    if (lstatEr || this[ISREUSABLE](entry, st)) {
      return this[MAKEFS](null, entry);
    }
    if (st.isDirectory()) {
      if (entry.type === "Directory") {
        const needChmod = this.chmod && entry.mode && (st.mode & 4095) !== entry.mode;
        const [er3] = needChmod ? callSync(() => {
          fs10.chmodSync(String(entry.absolute), Number(entry.mode));
        }) : [];
        return this[MAKEFS](er3, entry);
      }
      const [er2] = callSync(() => fs10.rmdirSync(String(entry.absolute)));
      this[MAKEFS](er2, entry);
    }
    const [er] = entry.absolute === this.cwd ? [] : callSync(() => unlinkFileSync(String(entry.absolute)));
    this[MAKEFS](er, entry);
  }
  [FILE2](entry, done) {
    const mode = typeof entry.mode === "number" ? entry.mode & 4095 : this.fmode;
    const oner = (er) => {
      let closeError;
      try {
        fs10.closeSync(fd);
      } catch (e2) {
        closeError = e2;
      }
      if (er || closeError) {
        this[ONERROR](er || closeError, entry);
      }
      done();
    };
    let fd;
    try {
      fd = fs10.openSync(String(entry.absolute), getWriteFlag(entry.size), mode);
    } catch (er) {
      return oner(er);
    }
    const tx = this.transform ? this.transform(entry) || entry : entry;
    if (tx !== entry) {
      tx.on("error", (er) => this[ONERROR](er, entry));
      entry.pipe(tx);
    }
    tx.on("data", (chunk) => {
      try {
        fs10.writeSync(fd, chunk, 0, chunk.length);
      } catch (er) {
        oner(er);
      }
    });
    tx.on("end", () => {
      let er = null;
      if (entry.mtime && !this.noMtime) {
        const atime = entry.atime || new Date;
        const mtime = entry.mtime;
        try {
          fs10.futimesSync(fd, atime, mtime);
        } catch (futimeser) {
          try {
            fs10.utimesSync(String(entry.absolute), atime, mtime);
          } catch (utimeser) {
            er = futimeser;
          }
        }
      }
      if (this[DOCHOWN](entry)) {
        const uid = this[UID](entry);
        const gid = this[GID](entry);
        try {
          fs10.fchownSync(fd, Number(uid), Number(gid));
        } catch (fchowner) {
          try {
            fs10.chownSync(String(entry.absolute), Number(uid), Number(gid));
          } catch (chowner) {
            er = er || fchowner;
          }
        }
      }
      oner(er);
    });
  }
  [DIRECTORY2](entry, done) {
    const mode = typeof entry.mode === "number" ? entry.mode & 4095 : this.dmode;
    const er = this[MKDIR](String(entry.absolute), mode);
    if (er) {
      this[ONERROR](er, entry);
      done();
      return;
    }
    if (entry.mtime && !this.noMtime) {
      try {
        fs10.utimesSync(String(entry.absolute), entry.atime || new Date, entry.mtime);
      } catch (er2) {}
    }
    if (this[DOCHOWN](entry)) {
      try {
        fs10.chownSync(String(entry.absolute), Number(this[UID](entry)), Number(this[GID](entry)));
      } catch (er2) {}
    }
    done();
    entry.resume();
  }
  [MKDIR](dir, mode) {
    try {
      return mkdirSync(normalizeWindowsPath(dir), {
        uid: this.uid,
        gid: this.gid,
        processUid: this.processUid,
        processGid: this.processGid,
        umask: this.processUmask,
        preserve: this.preservePaths,
        unlink: this.unlink,
        cwd: this.cwd,
        mode
      });
    } catch (er) {
      return er;
    }
  }
  [LINK](entry, linkpath, link, done) {
    const ls = `${link}Sync`;
    try {
      fs10[ls](linkpath, String(entry.absolute));
      done();
      entry.resume();
    } catch (er) {
      return this[ONERROR](er, entry);
    }
  }
}

// node_modules/tar/dist/esm/extract.js
var extractFileSync = (opt) => {
  const u = new UnpackSync(opt);
  const file = opt.file;
  const stat3 = fs11.statSync(file);
  const readSize = opt.maxReadSize || 16 * 1024 * 1024;
  const stream = new ReadStreamSync(file, {
    readSize,
    size: stat3.size
  });
  stream.pipe(u);
};
var extractFile = (opt, _3) => {
  const u = new Unpack(opt);
  const readSize = opt.maxReadSize || 16 * 1024 * 1024;
  const file = opt.file;
  const p = new Promise((resolve5, reject) => {
    u.on("error", reject);
    u.on("close", resolve5);
    fs11.stat(file, (er, stat3) => {
      if (er) {
        reject(er);
      } else {
        const stream = new ReadStream(file, {
          readSize,
          size: stat3.size
        });
        stream.on("error", reject);
        stream.pipe(u);
      }
    });
  });
  return p;
};
var extract = makeCommand(extractFileSync, extractFile, (opt) => new UnpackSync(opt), (opt) => new Unpack(opt), (opt, files) => {
  if (files?.length)
    filesFilter(opt, files);
});
// node_modules/tar/dist/esm/replace.js
import fs12 from "node:fs";
import path8 from "node:path";
var replaceSync = (opt, files) => {
  const p = new PackSync(opt);
  let threw = true;
  let fd;
  let position;
  try {
    try {
      fd = fs12.openSync(opt.file, "r+");
    } catch (er) {
      if (er?.code === "ENOENT") {
        fd = fs12.openSync(opt.file, "w+");
      } else {
        throw er;
      }
    }
    const st = fs12.fstatSync(fd);
    const headBuf = Buffer.alloc(512);
    POSITION:
      for (position = 0;position < st.size; position += 512) {
        for (let bufPos = 0, bytes = 0;bufPos < 512; bufPos += bytes) {
          bytes = fs12.readSync(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos);
          if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139) {
            throw new Error("cannot append to compressed archives");
          }
          if (!bytes) {
            break POSITION;
          }
        }
        const h2 = new Header(headBuf);
        if (!h2.cksumValid) {
          break;
        }
        const entryBlockSize = 512 * Math.ceil((h2.size || 0) / 512);
        if (position + entryBlockSize + 512 > st.size) {
          break;
        }
        position += entryBlockSize;
        if (opt.mtimeCache && h2.mtime) {
          opt.mtimeCache.set(String(h2.path), h2.mtime);
        }
      }
    threw = false;
    streamSync(opt, p, position, fd, files);
  } finally {
    if (threw) {
      try {
        fs12.closeSync(fd);
      } catch (er) {}
    }
  }
};
var streamSync = (opt, p, position, fd, files) => {
  const stream = new WriteStreamSync(opt.file, {
    fd,
    start: position
  });
  p.pipe(stream);
  addFilesSync2(p, files);
};
var replaceAsync = (opt, files) => {
  files = Array.from(files);
  const p = new Pack(opt);
  const getPos = (fd, size, cb_) => {
    const cb = (er, pos2) => {
      if (er) {
        fs12.close(fd, (_3) => cb_(er));
      } else {
        cb_(null, pos2);
      }
    };
    let position = 0;
    if (size === 0) {
      return cb(null, 0);
    }
    let bufPos = 0;
    const headBuf = Buffer.alloc(512);
    const onread = (er, bytes) => {
      if (er || typeof bytes === "undefined") {
        return cb(er);
      }
      bufPos += bytes;
      if (bufPos < 512 && bytes) {
        return fs12.read(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos, onread);
      }
      if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139) {
        return cb(new Error("cannot append to compressed archives"));
      }
      if (bufPos < 512) {
        return cb(null, position);
      }
      const h2 = new Header(headBuf);
      if (!h2.cksumValid) {
        return cb(null, position);
      }
      const entryBlockSize = 512 * Math.ceil((h2.size ?? 0) / 512);
      if (position + entryBlockSize + 512 > size) {
        return cb(null, position);
      }
      position += entryBlockSize + 512;
      if (position >= size) {
        return cb(null, position);
      }
      if (opt.mtimeCache && h2.mtime) {
        opt.mtimeCache.set(String(h2.path), h2.mtime);
      }
      bufPos = 0;
      fs12.read(fd, headBuf, 0, 512, position, onread);
    };
    fs12.read(fd, headBuf, 0, 512, position, onread);
  };
  const promise = new Promise((resolve5, reject) => {
    p.on("error", reject);
    let flag = "r+";
    const onopen = (er, fd) => {
      if (er && er.code === "ENOENT" && flag === "r+") {
        flag = "w+";
        return fs12.open(opt.file, flag, onopen);
      }
      if (er || !fd) {
        return reject(er);
      }
      fs12.fstat(fd, (er2, st) => {
        if (er2) {
          return fs12.close(fd, () => reject(er2));
        }
        getPos(fd, st.size, (er3, position) => {
          if (er3) {
            return reject(er3);
          }
          const stream = new WriteStream(opt.file, {
            fd,
            start: position
          });
          p.pipe(stream);
          stream.on("error", reject);
          stream.on("close", resolve5);
          addFilesAsync2(p, files);
        });
      });
    };
    fs12.open(opt.file, flag, onopen);
  });
  return promise;
};
var addFilesSync2 = (p, files) => {
  files.forEach((file) => {
    if (file.charAt(0) === "@") {
      list({
        file: path8.resolve(p.cwd, file.slice(1)),
        sync: true,
        noResume: true,
        onReadEntry: (entry) => p.add(entry)
      });
    } else {
      p.add(file);
    }
  });
  p.end();
};
var addFilesAsync2 = async (p, files) => {
  for (let i = 0;i < files.length; i++) {
    const file = String(files[i]);
    if (file.charAt(0) === "@") {
      await list({
        file: path8.resolve(String(p.cwd), file.slice(1)),
        noResume: true,
        onReadEntry: (entry) => p.add(entry)
      });
    } else {
      p.add(file);
    }
  }
  p.end();
};
var replace = makeCommand(replaceSync, replaceAsync, () => {
  throw new TypeError("file is required");
}, () => {
  throw new TypeError("file is required");
}, (opt, entries) => {
  if (!isFile(opt)) {
    throw new TypeError("file is required");
  }
  if (opt.gzip || opt.brotli || opt.zstd || opt.file.endsWith(".br") || opt.file.endsWith(".tbr")) {
    throw new TypeError("cannot append to compressed archives");
  }
  if (!entries?.length) {
    throw new TypeError("no paths specified to add/replace");
  }
});
// node_modules/tar/dist/esm/update.js
var update = makeCommand(replace.syncFile, replace.asyncFile, replace.syncNoFile, replace.asyncNoFile, (opt, entries = []) => {
  replace.validate?.(opt, entries);
  mtimeFilter(opt);
});
var mtimeFilter = (opt) => {
  const filter = opt.filter;
  if (!opt.mtimeCache) {
    opt.mtimeCache = new Map;
  }
  opt.filter = filter ? (path9, stat3) => filter(path9, stat3) && !((opt.mtimeCache?.get(path9) ?? stat3.mtime ?? 0) > (stat3.mtime ?? 0)) : (path9, stat3) => !((opt.mtimeCache?.get(path9) ?? stat3.mtime ?? 0) > (stat3.mtime ?? 0));
};
// src/domains/installation/utils/archive-utils.ts
init_types2();
function detectArchiveType(filename) {
  if (filename.endsWith(".tar.gz") || filename.endsWith(".tgz")) {
    return "tar.gz";
  }
  if (filename.endsWith(".zip")) {
    return "zip";
  }
  throw new ExtractionError(`Cannot detect archive type from filename: ${filename}`);
}
function isWrapperDirectory(dirName) {
  const versionPattern = /^[\w-]+-v?\d+\.\d+\.\d+(-[\w.]+)?$/;
  const hashPattern = /^[\w-]+-[a-f0-9]{7,40}$/;
  return versionPattern.test(dirName) || hashPattern.test(dirName);
}

// src/domains/installation/utils/encoding-utils.ts
init_logger();
import { Buffer as Buffer3 } from "node:buffer";
import { TextDecoder } from "node:util";
var UTF8_DECODER = new TextDecoder("utf-8", { fatal: false });
function normalizeZipEntryName(entryName) {
  if (entryName instanceof Uint8Array) {
    const decoded = UTF8_DECODER.decode(entryName);
    return decoded;
  }
  if (typeof entryName === "string") {
    if (/[]/u.test(entryName)) {
      try {
        const repaired = Buffer3.from(entryName, "latin1").toString("utf8");
        if (!repaired.includes("")) {
          logger.debug(`Recovered zip entry name: ${entryName} -> ${repaired}`);
          return repaired;
        }
      } catch (error) {
        logger.debug(`Failed to repair zip entry name ${entryName}: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    return entryName;
  }
  return String(entryName);
}
function decodeFilePath(path9) {
  if (!path9.includes("%")) {
    return path9;
  }
  try {
    if (/%[0-9A-F]{2}/i.test(path9)) {
      const decoded = decodeURIComponent(path9);
      logger.debug(`Decoded path: ${path9} -> ${decoded}`);
      return decoded;
    }
    return path9;
  } catch (error) {
    logger.warning(`Failed to decode path "${path9}": ${error instanceof Error ? error.message : "Unknown error"}`);
    return path9;
  }
}

// src/domains/installation/utils/file-utils.ts
init_logger();
init_types2();
import { copyFile, lstat as lstat2, mkdir as mkdir11, readdir as readdir5 } from "node:fs/promises";
import { join as join34, relative as relative4 } from "node:path";
async function withRetry(fn, retries = 3) {
  for (let i = 0;i < retries; i++) {
    try {
      return await fn();
    } catch (e2) {
      if (!isRetryable(e2) || i === retries - 1)
        throw e2;
      await delay(100 * 2 ** i);
    }
  }
  throw new Error("Unreachable");
}
var isRetryable = (e2) => {
  const code2 = e2.code ?? "";
  return ["EBUSY", "EPERM", "EACCES"].includes(code2);
};
var delay = (ms) => new Promise((r2) => setTimeout(r2, ms));
async function moveDirectoryContents(sourceDir, destDir, shouldExclude, sizeTracker) {
  await mkdir11(destDir, { recursive: true });
  const entries = await readdir5(sourceDir, { encoding: "utf8" });
  for (const entry of entries) {
    const sourcePath = join34(sourceDir, entry);
    const destPath = join34(destDir, entry);
    const relativePath = relative4(sourceDir, sourcePath);
    if (!isPathSafe(destDir, destPath)) {
      logger.warning(`Skipping unsafe path: ${relativePath}`);
      throw new ExtractionError(`Path traversal attempt detected: ${relativePath}`);
    }
    if (shouldExclude(relativePath)) {
      logger.debug(`Excluding: ${relativePath}`);
      continue;
    }
    const entryStat = await lstat2(sourcePath);
    if (entryStat.isDirectory()) {
      await copyDirectory(sourcePath, destPath, shouldExclude, sizeTracker);
    } else if (entryStat.isFile()) {
      if (sizeTracker) {
        sizeTracker.checkExtractionSize(entryStat.size);
      }
      await withRetry(() => copyFile(sourcePath, destPath));
    } else {
      throw new ExtractionError(`Not a regular file: ${relativePath}`);
    }
  }
}
async function copyDirectory(sourceDir, destDir, shouldExclude, sizeTracker) {
  await mkdir11(destDir, { recursive: true });
  const entries = await readdir5(sourceDir, { encoding: "utf8" });
  for (const entry of entries) {
    const sourcePath = join34(sourceDir, entry);
    const destPath = join34(destDir, entry);
    const relativePath = relative4(sourceDir, sourcePath);
    if (!isPathSafe(destDir, destPath)) {
      logger.warning(`Skipping unsafe path: ${relativePath}`);
      throw new ExtractionError(`Path traversal attempt detected: ${relativePath}`);
    }
    if (shouldExclude(relativePath)) {
      logger.debug(`Excluding: ${relativePath}`);
      continue;
    }
    const entryStat = await lstat2(sourcePath);
    if (entryStat.isDirectory()) {
      await copyDirectory(sourcePath, destPath, shouldExclude, sizeTracker);
    } else if (entryStat.isFile()) {
      if (sizeTracker) {
        sizeTracker.checkExtractionSize(entryStat.size);
      }
      await withRetry(() => copyFile(sourcePath, destPath));
    } else {
      throw new ExtractionError(`Not a regular file: ${relativePath}`);
    }
  }
}

// src/domains/installation/extraction/tar-extractor.ts
class TarExtractor {
  async extract(archivePath, destDir, shouldExclude, sizeTracker) {
    const tempExtractDir = `${destDir}-temp`;
    await mkdir12(tempExtractDir, { recursive: true });
    try {
      await extract({
        file: archivePath,
        cwd: tempExtractDir,
        strip: 0,
        filter: (path9) => {
          const decodedPath = decodeFilePath(path9);
          const shouldInclude = !shouldExclude(decodedPath);
          if (!shouldInclude) {
            logger.debug(`Excluding: ${decodedPath}`);
          }
          return shouldInclude;
        }
      });
      logger.debug(`Extracted TAR.GZ to temp: ${tempExtractDir}`);
      const entries = await readdir6(tempExtractDir, { encoding: "utf8" });
      logger.debug(`Root entries: ${entries.join(", ")}`);
      if (entries.length === 1) {
        const rootEntry = entries[0];
        const rootPath = join35(tempExtractDir, rootEntry);
        const rootStat = await stat3(rootPath);
        if (rootStat.isDirectory()) {
          const rootContents = await readdir6(rootPath, { encoding: "utf8" });
          logger.debug(`Root directory '${rootEntry}' contains: ${rootContents.join(", ")}`);
          const isWrapper = isWrapperDirectory(rootEntry);
          logger.debug(`Is wrapper directory: ${isWrapper}`);
          if (isWrapper) {
            logger.debug(`Stripping wrapper directory: ${rootEntry}`);
            await moveDirectoryContents(rootPath, destDir, shouldExclude, sizeTracker);
          } else {
            logger.debug("Preserving complete directory structure");
            await moveDirectoryContents(tempExtractDir, destDir, shouldExclude, sizeTracker);
          }
        } else {
          await mkdir12(destDir, { recursive: true });
          await copyFile2(rootPath, join35(destDir, rootEntry));
        }
      } else {
        logger.debug("Multiple root entries - moving all");
        await moveDirectoryContents(tempExtractDir, destDir, shouldExclude, sizeTracker);
      }
      logger.debug(`Moved contents to: ${destDir}`);
      await rm(tempExtractDir, { recursive: true, force: true });
    } catch (error) {
      try {
        await rm(tempExtractDir, { recursive: true, force: true });
      } catch {}
      throw error;
    }
  }
}

// src/domains/installation/extraction/zip-extractor.ts
init_environment();
init_logger();
var import_extract_zip = __toESM(require_extract_zip(), 1);
import { execFile as execFile2 } from "node:child_process";
import { copyFile as copyFile3, mkdir as mkdir13, readdir as readdir7, rm as rm2, stat as stat4 } from "node:fs/promises";
import { join as join36 } from "node:path";
class ZipExtractor {
  async tryNativeUnzip(archivePath, destDir) {
    if (!isMacOS()) {
      return false;
    }
    return new Promise((resolve5) => {
      mkdir13(destDir, { recursive: true }).then(() => {
        execFile2("unzip", ["-o", "-q", archivePath, "-d", destDir], (error, _stdout, stderr) => {
          if (error) {
            logger.debug(`Native unzip failed: ${stderr || error.message}`);
            resolve5(false);
            return;
          }
          logger.debug("Native unzip succeeded");
          resolve5(true);
        });
      }).catch((err) => {
        logger.debug(`Failed to create directory for native unzip: ${err.message}`);
        resolve5(false);
      });
    });
  }
  async extract(archivePath, destDir, shouldExclude, sizeTracker) {
    const tempExtractDir = `${destDir}-temp`;
    await mkdir13(tempExtractDir, { recursive: true });
    try {
      const nativeSuccess = await this.tryNativeUnzip(archivePath, tempExtractDir);
      if (!nativeSuccess) {
        logger.debug("Using extract-zip library");
        let extractedCount = 0;
        const zipOptions = {
          dir: tempExtractDir,
          onEntry: (entry) => {
            const normalized = normalizeZipEntryName(entry.fileName);
            entry.fileName = normalized;
            extractedCount++;
          },
          yauzl: { decodeStrings: false }
        };
        await import_extract_zip.default(archivePath, zipOptions);
        logger.verbose(`Extracted ${extractedCount} files`);
      }
      logger.debug(`Extracted ZIP to temp: ${tempExtractDir}`);
      const entries = await readdir7(tempExtractDir, { encoding: "utf8" });
      logger.debug(`Root entries: ${entries.join(", ")}`);
      if (entries.length === 1) {
        const rootEntry = entries[0];
        const rootPath = join36(tempExtractDir, rootEntry);
        const rootStat = await stat4(rootPath);
        if (rootStat.isDirectory()) {
          const rootContents = await readdir7(rootPath, { encoding: "utf8" });
          logger.debug(`Root directory '${rootEntry}' contains: ${rootContents.join(", ")}`);
          const isWrapper = isWrapperDirectory(rootEntry);
          logger.debug(`Is wrapper directory: ${isWrapper}`);
          if (isWrapper) {
            logger.debug(`Stripping wrapper directory: ${rootEntry}`);
            await moveDirectoryContents(rootPath, destDir, shouldExclude, sizeTracker);
          } else {
            logger.debug("Preserving complete directory structure");
            await moveDirectoryContents(tempExtractDir, destDir, shouldExclude, sizeTracker);
          }
        } else {
          await mkdir13(destDir, { recursive: true });
          await copyFile3(rootPath, join36(destDir, rootEntry));
        }
      } else {
        logger.debug("Multiple root entries - moving all");
        await moveDirectoryContents(tempExtractDir, destDir, shouldExclude, sizeTracker);
      }
      logger.debug(`Moved contents to: ${destDir}`);
      await rm2(tempExtractDir, { recursive: true, force: true });
    } catch (error) {
      try {
        await rm2(tempExtractDir, { recursive: true, force: true });
      } catch {}
      throw error;
    }
  }
}
// src/domains/installation/download-manager.ts
var SLOW_EXTRACTION_THRESHOLD_MS = 30000;
var MAX_ARCHIVE_SIZE = 100 * 1024 * 1024;
var EXCLUDE_PATTERNS = [
  ".git",
  ".git/**",
  ".github",
  ".github/**",
  "node_modules",
  "node_modules/**",
  ".DS_Store",
  "Thumbs.db",
  "*.log"
];

class DownloadManager {
  static tempDirCounter = 0;
  fileDownloader = new FileDownloader;
  tarExtractor = new TarExtractor;
  zipExtractor = new ZipExtractor;
  sizeTracker = new ExtractionSizeTracker;
  ig;
  userExcludePatterns = [];
  constructor() {
    this.ig = import_ignore.default().add(EXCLUDE_PATTERNS);
  }
  setExcludePatterns(patterns) {
    this.userExcludePatterns = patterns;
    this.ig = import_ignore.default().add([...EXCLUDE_PATTERNS, ...this.userExcludePatterns]);
    if (patterns.length > 0) {
      logger.info(`Added ${patterns.length} custom exclude pattern(s)`);
      patterns.forEach((p) => logger.debug(`  - ${p}`));
    }
  }
  shouldExclude = (filePath) => {
    return this.ig.ignores(filePath);
  };
  async downloadAsset(asset, destDir) {
    return this.fileDownloader.downloadAsset(asset, destDir);
  }
  async downloadFile(params) {
    return this.fileDownloader.downloadFile(params);
  }
  async extractArchive(archivePath, destDir, archiveType) {
    const archiveStats = await stat5(archivePath);
    if (archiveStats.size > MAX_ARCHIVE_SIZE) {
      throw new ExtractionError(`Archive exceeds ${formatBytes(MAX_ARCHIVE_SIZE)} limit: ${formatBytes(archiveStats.size)}`);
    }
    const spinner = createSpinner("Extracting files...").start();
    const slowExtractionWarning = setTimeout(() => {
      spinner.text = "Extracting files... (this may take a while on macOS)";
      if (isMacOS()) {
        logger.debug("Slow extraction detected on macOS - Spotlight indexing may be interfering");
      }
    }, SLOW_EXTRACTION_THRESHOLD_MS);
    try {
      this.sizeTracker.reset();
      const detectedType = archiveType || detectArchiveType(archivePath);
      await mkdir14(destDir, { recursive: true });
      if (detectedType === "tar.gz") {
        await this.tarExtractor.extract(archivePath, destDir, this.shouldExclude, this.sizeTracker);
      } else if (detectedType === "zip") {
        await this.zipExtractor.extract(archivePath, destDir, this.shouldExclude, this.sizeTracker);
      } else {
        throw new ExtractionError(`Unsupported archive type: ${detectedType}`);
      }
      clearTimeout(slowExtractionWarning);
      spinner.succeed("Files extracted successfully");
    } catch (error) {
      clearTimeout(slowExtractionWarning);
      spinner.fail("Extraction failed");
      if (isMacOS()) {
        logger.debug("macOS extraction tip: Try disabling Spotlight for the target directory with: sudo mdutil -i off <path>");
      }
      throw new ExtractionError(`Failed to extract archive: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  async validateExtraction(extractDir) {
    return validateExtraction(extractDir);
  }
  async createTempDir() {
    const timestamp = Date.now();
    const counter = DownloadManager.tempDirCounter++;
    const primaryTempDir = join37(tmpdir3(), `claudekit-${timestamp}-${counter}`);
    try {
      await mkdir14(primaryTempDir, { recursive: true });
      logger.debug(`Created temp directory: ${primaryTempDir}`);
      return primaryTempDir;
    } catch (primaryError) {
      logger.debug(`Failed to create temp directory in OS temp: ${primaryError instanceof Error ? primaryError.message : "Unknown error"}`);
      const homeDir = process.env.HOME || process.env.USERPROFILE;
      if (!homeDir) {
        throw new DownloadError(`Cannot create temporary directory. Permission denied for ${primaryTempDir} and HOME directory not found.

Solutions:
  1. Run with elevated permissions
  2. Set HOME environment variable
  3. Try running from a different directory`);
      }
      const fallbackTempDir = join37(homeDir, ".claudekit", "tmp", `claudekit-${timestamp}-${counter}`);
      try {
        await mkdir14(fallbackTempDir, { recursive: true });
        logger.debug(`Created temp directory (fallback): ${fallbackTempDir}`);
        logger.warning(`Using fallback temp directory: ${fallbackTempDir}
  (OS temp directory was not accessible)`);
        return fallbackTempDir;
      } catch (fallbackError) {
        const errorMsg = fallbackError instanceof Error ? fallbackError.message : "Permission denied";
        throw new DownloadError(`Cannot create temporary directory.

Primary location failed: ${primaryTempDir}
Fallback location failed: ${fallbackTempDir}

Error: ${errorMsg}

Solutions:
  1. Check disk space and permissions
  2. Run with elevated permissions
  3. Try running from a different directory`);
      }
    }
  }
}

// src/domains/installation/download-extractor.ts
init_logger();
init_output_manager();
var RELEASE_ALLOWLIST = [
  ".claude",
  "plans",
  "CLAUDE.md",
  ".gitignore",
  ".repomixignore"
];
async function filterGitClone(cloneDir) {
  const claudeDir = path9.join(cloneDir, ".claude");
  try {
    const stat6 = await fs13.promises.stat(claudeDir);
    if (!stat6.isDirectory()) {
      throw new Error(`.claude exists but is not a directory.

` + "This kit may be corrupted, or the release may be malformed.");
    }
  } catch (error) {
    if (error.code === "ENOENT") {
      throw new Error(`Repository does not contain a .claude directory.

` + "This kit may not be a ClaudeKit project, or the release may be malformed.");
    }
    throw error;
  }
  const entries = await fs13.promises.readdir(cloneDir);
  let removedCount = 0;
  for (const entry of entries) {
    if (!RELEASE_ALLOWLIST.includes(entry)) {
      const fullPath = path9.join(cloneDir, entry);
      await fs13.promises.rm(fullPath, { recursive: true, force: true });
      removedCount++;
    }
  }
  logger.verbose("Filtered git clone (allowlist)", {
    kept: RELEASE_ALLOWLIST.filter((p) => entries.includes(p)),
    removedCount,
    extractDir: cloneDir
  });
  return { extractDir: cloneDir, tempDir: cloneDir };
}
async function downloadAndExtract(options) {
  const { release, kit, exclude, useGit, isNonInteractive: isNonInteractive2, archive, kitPath } = options;
  const offlineOptions = [useGit, archive, kitPath].filter(Boolean);
  if (offlineOptions.length > 1) {
    throw new Error(`Options --use-git, --archive, and --kit-path are mutually exclusive.
` + "Please use only one download method.");
  }
  if (kitPath) {
    return useLocalKitPath(kitPath);
  }
  if (archive) {
    return extractLocalArchive(archive, exclude);
  }
  if (!release) {
    throw new Error(`Release information is required for download.

` + "Use --archive or --kit-path for offline installation without specifying a release.");
  }
  if (useGit) {
    return downloadViaGitClone(release, kit);
  }
  try {
    return await downloadViaApi(release, kit, exclude);
  } catch (error) {
    const canPrompt = isNonInteractive2 !== undefined ? !isNonInteractive2 : process.stdin.isTTY;
    if (isAuthError(error) && canPrompt) {
      return handleAuthErrorInteractively(error, release, kit, exclude);
    }
    throw error;
  }
}
function isAuthError(error) {
  if (error && typeof error === "object" && "name" in error) {
    return error.name === "AuthenticationError";
  }
  return false;
}
var MAX_AUTH_RETRIES = 3;
async function handleAuthErrorInteractively(_originalError, release, kit, exclude, retryCount = 0) {
  if (retryCount >= MAX_AUTH_RETRIES) {
    throw new Error(`Authentication failed after ${MAX_AUTH_RETRIES} attempts.

Please verify your token has the correct permissions:
   Classic PAT: requires 'repo' scope
   Fine-grained PAT: cannot access collaborator repos

Or try: ck new --use-git`);
  }
  const result = await promptForAuth();
  switch (result.method) {
    case "git":
      logger.info("Switching to git clone method...");
      return downloadViaGitClone(release, kit);
    case "token":
      if (result.token) {
        process.env.GITHUB_TOKEN = result.token.trim();
        AuthManager.clearToken();
        const attempt = retryCount + 1;
        logger.info(`Token set, retrying download (attempt ${attempt}/${MAX_AUTH_RETRIES})...`);
        try {
          return await downloadViaApi(release, kit, exclude);
        } catch (error) {
          if (isAuthError(error)) {
            logger.warning("Token authentication failed. Please check your token.");
            return handleAuthErrorInteractively(error, release, kit, exclude, attempt);
          }
          throw error;
        }
      }
      throw new Error("No token provided");
    case "gh-cli":
      throw new Error(`Please run 'gh auth login' first, then retry the command.
` + "Select 'Login with a web browser' when prompted.");
    case "cancel":
      throw new Error("Authentication cancelled by user");
    default: {
      const _exhaustive = result.method;
      throw new Error(`Unknown auth method: ${_exhaustive}`);
    }
  }
}
async function useLocalKitPath(kitPath) {
  logger.verbose("Using local kit path", { kitPath });
  output.section("Using local kit");
  const absolutePath = path9.resolve(kitPath);
  try {
    const stat6 = await fs13.promises.stat(absolutePath);
    if (!stat6.isDirectory()) {
      throw new Error(`--kit-path must point to a directory, not a file.

Provided path: ${absolutePath}

If you meant to use an archive file, use --archive instead.`);
    }
  } catch (error) {
    if (error.code === "ENOENT") {
      throw new Error(`Kit directory not found: ${absolutePath}

Please verify the path exists and is accessible.`);
    }
    throw error;
  }
  const claudeDir = path9.join(absolutePath, ".claude");
  try {
    const stat6 = await fs13.promises.stat(claudeDir);
    if (!stat6.isDirectory()) {
      logger.warning(`Warning: ${claudeDir} exists but is not a directory.
This may not be a valid ClaudeKit installation.`);
    }
  } catch (error) {
    if (error.code === "ENOENT") {
      logger.warning(`Warning: No .claude directory found in ${absolutePath}
This may not be a valid ClaudeKit installation. Proceeding anyway...`);
    }
  }
  logger.info(`Using kit from: ${absolutePath}`);
  return {
    tempDir: absolutePath,
    archivePath: "",
    extractDir: absolutePath
  };
}
var VALID_ARCHIVE_FORMATS = [".zip", ".tar.gz", ".tgz", ".tar"];
function validateArchiveFormat(archivePath) {
  const lowerPath = archivePath.toLowerCase();
  const isValid2 = VALID_ARCHIVE_FORMATS.some((ext) => lowerPath.endsWith(ext));
  if (!isValid2) {
    const ext = path9.extname(archivePath) || "(no extension)";
    throw new Error(`Unsupported archive format: ${ext}

` + `Supported formats: ${VALID_ARCHIVE_FORMATS.join(", ")}`);
  }
}
async function extractLocalArchive(archivePath, exclude) {
  logger.verbose("Using local archive", { archivePath });
  output.section("Extracting local archive");
  const absolutePath = path9.resolve(archivePath);
  validateArchiveFormat(absolutePath);
  try {
    const stat6 = await fs13.promises.stat(absolutePath);
    if (!stat6.isFile()) {
      throw new Error(`--archive must point to a file, not a directory.

Provided path: ${absolutePath}

If you meant to use an extracted kit directory, use --kit-path instead.`);
    }
    if (stat6.size === 0) {
      throw new Error(`Archive file is empty: ${absolutePath}

The file exists but contains no data. Please verify the archive is not corrupted.`);
    }
  } catch (error) {
    if (error.code === "ENOENT") {
      throw new Error(`Archive file not found: ${absolutePath}

Please verify the file exists and is accessible.`);
    }
    throw error;
  }
  const downloadManager = new DownloadManager;
  const tempDir = await downloadManager.createTempDir();
  if (exclude && exclude.length > 0) {
    downloadManager.setExcludePatterns(exclude);
  }
  const extractDir = `${tempDir}/extracted`;
  logger.verbose("Extraction", { archivePath: absolutePath, extractDir });
  await downloadManager.extractArchive(absolutePath, extractDir);
  await downloadManager.validateExtraction(extractDir);
  logger.info(`Extracted from: ${absolutePath}`);
  return {
    tempDir,
    archivePath: absolutePath,
    extractDir
  };
}
async function downloadViaGitClone(release, kit) {
  logger.verbose("Using git clone method", { tag: release.tag_name });
  output.section("Downloading (git clone)");
  if (!GitCloneManager.isGitInstalled()) {
    throw new Error(`Git is not installed.

` + `The --use-git flag requires git to be installed.
` + `Install git from: https://git-scm.com/downloads

` + "Or remove --use-git to use GitHub API instead.");
  }
  const gitCloneManager = new GitCloneManager;
  const result = await gitCloneManager.clone({
    kit,
    tag: release.tag_name,
    preferSsh: GitCloneManager.hasSshKeys()
  });
  logger.verbose("Git clone complete", { cloneDir: result.cloneDir, method: result.method });
  const { extractDir, tempDir } = await filterGitClone(result.cloneDir);
  return {
    tempDir,
    archivePath: "",
    extractDir
  };
}
async function downloadViaApi(release, kit, exclude) {
  const downloadInfo = GitHubClient.getDownloadableAsset(release);
  logger.verbose("Release info", {
    tag: release.tag_name,
    prerelease: release.prerelease,
    downloadType: downloadInfo.type,
    assetSize: downloadInfo.size
  });
  output.section("Downloading");
  const downloadManager = new DownloadManager;
  if (exclude && exclude.length > 0) {
    downloadManager.setExcludePatterns(exclude);
  }
  const tempDir = await downloadManager.createTempDir();
  const { token } = await AuthManager.getToken();
  let archivePath;
  try {
    archivePath = await downloadManager.downloadFile({
      url: downloadInfo.url,
      name: downloadInfo.name,
      size: downloadInfo.size,
      destDir: tempDir,
      token
    });
  } catch (error) {
    if (downloadInfo.type === "asset") {
      logger.warning("Asset download failed, falling back to GitHub tarball...");
      const tarballInfo = {
        type: "github-tarball",
        url: release.tarball_url,
        name: `${kit.repo}-${release.tag_name}.tar.gz`,
        size: 0
      };
      archivePath = await downloadManager.downloadFile({
        url: tarballInfo.url,
        name: tarballInfo.name,
        size: tarballInfo.size,
        destDir: tempDir,
        token
      });
    } else {
      throw error;
    }
  }
  const extractDir = `${tempDir}/extracted`;
  logger.verbose("Extraction", { archivePath, extractDir });
  await downloadManager.extractArchive(archivePath, extractDir);
  await downloadManager.validateExtraction(extractDir);
  return {
    tempDir,
    archivePath,
    extractDir
  };
}

// src/commands/init/phases/download-handler.ts
async function handleDownload(ctx) {
  if (ctx.cancelled || !ctx.kit)
    return ctx;
  const usingOfflineMethod = ctx.options.archive || ctx.options.kitPath;
  if (!ctx.release && !usingOfflineMethod)
    return ctx;
  const result = await downloadAndExtract({
    release: ctx.release,
    kit: ctx.kit,
    exclude: ctx.options.exclude,
    useGit: ctx.options.useGit,
    isNonInteractive: ctx.isNonInteractive,
    archive: ctx.options.archive,
    kitPath: ctx.options.kitPath
  });
  return {
    ...ctx,
    tempDir: result.tempDir,
    archivePath: result.archivePath,
    extractDir: result.extractDir
  };
}
// src/commands/init/phases/merge-handler.ts
import { join as join53 } from "node:path";

// src/domains/installation/file-merger.ts
init_logger();
init_types2();
init_dist2();

// src/domains/installation/merger/copy-executor.ts
init_logger();
init_types2();
var import_fs_extra10 = __toESM(require_lib(), 1);
var import_ignore3 = __toESM(require_ignore(), 1);
import { dirname as dirname8, join as join43, relative as relative6 } from "node:path";

// src/domains/installation/selective-merger.ts
import { stat as stat6 } from "node:fs/promises";

// src/services/file-operations/manifest/manifest-reader.ts
import { join as join39 } from "node:path";
init_logger();
init_types2();
var import_fs_extra6 = __toESM(require_lib(), 1);
async function readManifest(claudeDir) {
  const metadataPath = join39(claudeDir, "metadata.json");
  if (!await import_fs_extra6.pathExists(metadataPath)) {
    return null;
  }
  try {
    const content = await import_fs_extra6.readFile(metadataPath, "utf-8");
    const parsed = JSON.parse(content);
    return MetadataSchema.parse(parsed);
  } catch (error) {
    logger.debug(`Failed to read manifest: ${error}`);
    return null;
  }
}
async function readKitManifest(claudeDir, kit) {
  const metadata = await readManifest(claudeDir);
  if (!metadata)
    return null;
  return getKitMetadata(metadata, kit);
}
async function findFileInInstalledKits(claudeDir, relativePath, excludeKit) {
  const metadata = await readManifest(claudeDir);
  if (!metadata?.kits) {
    return {
      exists: false,
      ownerKit: null,
      checksum: null,
      version: null,
      sourceTimestamp: null,
      installedAt: null
    };
  }
  for (const [kitName, kitMeta] of Object.entries(metadata.kits)) {
    const kit = kitName;
    if (kit === excludeKit)
      continue;
    if (!kitMeta.files)
      continue;
    const file = kitMeta.files.find((f3) => f3.path === relativePath);
    if (file) {
      return {
        exists: true,
        ownerKit: kit,
        checksum: file.checksum,
        version: kitMeta.version,
        sourceTimestamp: file.sourceTimestamp ?? null,
        installedAt: file.installedAt ?? null
      };
    }
  }
  return {
    exists: false,
    ownerKit: null,
    checksum: null,
    version: null,
    sourceTimestamp: null,
    installedAt: null
  };
}
async function getUninstallManifest(claudeDir, kit) {
  const detection = await detectMetadataFormat(claudeDir);
  if (detection.format === "multi-kit" && detection.metadata?.kits) {
    const installedKits = Object.keys(detection.metadata.kits);
    if (kit) {
      const kitMeta = detection.metadata.kits[kit];
      if (!kitMeta?.files) {
        return {
          filesToRemove: [],
          filesToPreserve: USER_CONFIG_PATTERNS,
          hasManifest: true,
          isMultiKit: true,
          remainingKits: installedKits.filter((k2) => k2 !== kit)
        };
      }
      const kitFiles = kitMeta.files.map((f3) => f3.path);
      const sharedFiles = new Set;
      for (const otherKit of installedKits) {
        if (otherKit !== kit) {
          const otherMeta = detection.metadata.kits[otherKit];
          if (otherMeta?.files) {
            for (const f3 of otherMeta.files) {
              sharedFiles.add(f3.path);
            }
          }
        }
      }
      const filesToRemove = kitFiles.filter((f3) => !sharedFiles.has(f3));
      const filesToPreserve = [
        ...USER_CONFIG_PATTERNS,
        ...kitFiles.filter((f3) => sharedFiles.has(f3))
      ];
      return {
        filesToRemove,
        filesToPreserve,
        hasManifest: true,
        isMultiKit: true,
        remainingKits: installedKits.filter((k2) => k2 !== kit)
      };
    }
    const allFiles = getAllTrackedFiles(detection.metadata);
    return {
      filesToRemove: allFiles.map((f3) => f3.path),
      filesToPreserve: USER_CONFIG_PATTERNS,
      hasManifest: true,
      isMultiKit: true,
      remainingKits: []
    };
  }
  if (detection.format === "legacy" && detection.metadata) {
    const legacyFiles2 = detection.metadata.files?.map((f3) => f3.path) || [];
    const installedFiles = detection.metadata.installedFiles || [];
    const hasFiles = legacyFiles2.length > 0 || installedFiles.length > 0;
    if (!hasFiles) {
      const legacyDirs2 = ["commands", "agents", "skills", "rules", "workflows", "hooks", "scripts"];
      const legacyFileList = ["metadata.json"];
      return {
        filesToRemove: [...legacyDirs2, ...legacyFileList],
        filesToPreserve: USER_CONFIG_PATTERNS,
        hasManifest: false,
        isMultiKit: false,
        remainingKits: []
      };
    }
    return {
      filesToRemove: legacyFiles2.length > 0 ? legacyFiles2 : installedFiles,
      filesToPreserve: detection.metadata.userConfigFiles || USER_CONFIG_PATTERNS,
      hasManifest: true,
      isMultiKit: false,
      remainingKits: []
    };
  }
  const legacyDirs = ["commands", "agents", "skills", "rules", "workflows", "hooks", "scripts"];
  const legacyFiles = ["metadata.json"];
  return {
    filesToRemove: [...legacyDirs, ...legacyFiles],
    filesToPreserve: USER_CONFIG_PATTERNS,
    hasManifest: false,
    isMultiKit: false,
    remainingKits: []
  };
}

// src/domains/installation/selective-merger.ts
init_logger();
var import_semver = __toESM(require_semver2(), 1);

class SelectiveMerger {
  manifest;
  manifestMap;
  claudeDir = null;
  installingKit = null;
  constructor(manifest) {
    this.manifest = manifest;
    this.manifestMap = new Map;
    if (manifest) {
      for (const file of manifest.files) {
        this.manifestMap.set(file.path, file);
      }
    }
  }
  setMultiKitContext(claudeDir, installingKit) {
    this.claudeDir = claudeDir;
    this.installingKit = installingKit;
  }
  async shouldCopyFile(destPath, relativePath) {
    let destStat;
    try {
      destStat = await stat6(destPath);
    } catch {
      if (this.claudeDir && this.installingKit) {
        const installed = await findFileInInstalledKits(this.claudeDir, relativePath, this.installingKit);
        if (installed.exists) {
          logger.debug(`File ${relativePath} tracked by ${installed.ownerKit} but missing on disk`);
        }
      }
      return { changed: true, reason: "new" };
    }
    const manifestEntry = this.manifestMap.get(relativePath);
    if (!manifestEntry) {
      logger.debug(`No manifest entry for ${relativePath}, will copy`);
      return { changed: true, reason: "new" };
    }
    if (this.claudeDir && this.installingKit) {
      const installed = await findFileInInstalledKits(this.claudeDir, relativePath, this.installingKit);
      if (installed.exists && installed.checksum && installed.ownerKit) {
        if (installed.checksum === manifestEntry.checksum) {
          logger.debug(`Shared identical: ${relativePath} (owned by ${installed.ownerKit})`);
          return {
            changed: false,
            reason: "shared-identical",
            sourceChecksum: manifestEntry.checksum,
            destChecksum: installed.checksum,
            sharedWithKit: installed.ownerKit
          };
        }
        const incomingTimestamp = manifestEntry.lastModified ?? null;
        const existingTimestamp = installed.sourceTimestamp;
        const conflictBase = {
          relativePath,
          incomingKit: this.installingKit,
          existingKit: installed.ownerKit,
          incomingTimestamp,
          existingTimestamp
        };
        if (incomingTimestamp && existingTimestamp) {
          const incomingTime = new Date(incomingTimestamp).getTime();
          const existingTime = new Date(existingTimestamp).getTime();
          if (Number.isNaN(incomingTime) || Number.isNaN(existingTime)) {
            logger.debug(`Invalid timestamp for ${relativePath}, falling back to version`);
          } else if (incomingTime > existingTime) {
            logger.debug(`Shared newer: ${relativePath} - incoming ${incomingTimestamp} > existing ${existingTimestamp}`);
            return {
              changed: true,
              reason: "shared-newer",
              sourceChecksum: manifestEntry.checksum,
              destChecksum: installed.checksum,
              sharedWithKit: installed.ownerKit,
              conflictInfo: { ...conflictBase, winner: "incoming", reason: "newer" }
            };
          } else if (incomingTime < existingTime) {
            logger.debug(`Shared older: ${relativePath} - incoming ${incomingTimestamp} < existing ${existingTimestamp}`);
            return {
              changed: false,
              reason: "shared-older",
              sourceChecksum: manifestEntry.checksum,
              destChecksum: installed.checksum,
              sharedWithKit: installed.ownerKit,
              conflictInfo: { ...conflictBase, winner: "existing", reason: "existing-newer" }
            };
          } else {
            logger.debug(`Shared tie: ${relativePath} - same timestamp, keeping existing`);
            return {
              changed: false,
              reason: "shared-older",
              sourceChecksum: manifestEntry.checksum,
              destChecksum: installed.checksum,
              sharedWithKit: installed.ownerKit,
              conflictInfo: { ...conflictBase, winner: "existing", reason: "tie" }
            };
          }
        } else if (installed.version) {
          const incomingVersion = this.manifest?.version || "0.0.0";
          const installedVersion = installed.version;
          const incomingSemver = import_semver.default.coerce(incomingVersion);
          const installedSemver = import_semver.default.coerce(installedVersion);
          if (incomingSemver && installedSemver) {
            if (import_semver.default.lte(incomingSemver, installedSemver)) {
              logger.debug(`Shared older (version fallback): ${relativePath} - incoming ${incomingVersion} <= installed ${installedVersion}`);
              return {
                changed: false,
                reason: "shared-older",
                sourceChecksum: manifestEntry.checksum,
                destChecksum: installed.checksum,
                sharedWithKit: installed.ownerKit,
                conflictInfo: { ...conflictBase, winner: "existing", reason: "no-timestamps" }
              };
            }
            logger.debug(`Updating shared file (version fallback): ${relativePath} - incoming ${incomingVersion} > installed ${installedVersion}`);
            return {
              changed: true,
              reason: "shared-newer",
              sourceChecksum: manifestEntry.checksum,
              destChecksum: installed.checksum,
              sharedWithKit: installed.ownerKit,
              conflictInfo: { ...conflictBase, winner: "incoming", reason: "no-timestamps" }
            };
          }
          logger.debug(`Shared file version comparison skipped (non-semver): ${relativePath} - incoming ${incomingVersion}, installed ${installedVersion}`);
          return {
            changed: false,
            reason: "shared-older",
            sourceChecksum: manifestEntry.checksum,
            destChecksum: installed.checksum,
            sharedWithKit: installed.ownerKit,
            conflictInfo: { ...conflictBase, winner: "existing", reason: "no-timestamps" }
          };
        }
      }
    }
    if (destStat.size !== manifestEntry.size) {
      logger.debug(`Size differs for ${relativePath}: ${destStat.size} vs ${manifestEntry.size}`);
      return {
        changed: true,
        reason: "size-differ",
        sourceChecksum: manifestEntry.checksum
      };
    }
    const destChecksum = await OwnershipChecker.calculateChecksum(destPath);
    if (destChecksum !== manifestEntry.checksum) {
      logger.debug(`Checksum differs for ${relativePath}`);
      return {
        changed: true,
        reason: "checksum-differ",
        sourceChecksum: manifestEntry.checksum,
        destChecksum
      };
    }
    logger.debug(`Unchanged: ${relativePath}`);
    return {
      changed: false,
      reason: "unchanged",
      sourceChecksum: manifestEntry.checksum,
      destChecksum
    };
  }
  hasManifest() {
    return this.manifest !== null && this.manifestMap.size > 0;
  }
  getManifestFileCount() {
    return this.manifestMap.size;
  }
}

// src/domains/installation/merger/file-scanner.ts
init_logger();
var import_fs_extra7 = __toESM(require_lib(), 1);
var import_ignore2 = __toESM(require_ignore(), 1);
import { relative as relative5 } from "node:path";
import { join as join40 } from "node:path";

// node_modules/@isaacs/balanced-match/dist/esm/index.js
var balanced = (a3, b3, str) => {
  const ma = a3 instanceof RegExp ? maybeMatch(a3, str) : a3;
  const mb = b3 instanceof RegExp ? maybeMatch(b3, str) : b3;
  const r2 = ma !== null && mb != null && range(ma, mb, str);
  return r2 && {
    start: r2[0],
    end: r2[1],
    pre: str.slice(0, r2[0]),
    body: str.slice(r2[0] + ma.length, r2[1]),
    post: str.slice(r2[1] + mb.length)
  };
};
var maybeMatch = (reg, str) => {
  const m2 = str.match(reg);
  return m2 ? m2[0] : null;
};
var range = (a3, b3, str) => {
  let begs, beg, left, right = undefined, result;
  let ai = str.indexOf(a3);
  let bi = str.indexOf(b3, ai + 1);
  let i = ai;
  if (ai >= 0 && bi > 0) {
    if (a3 === b3) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;
    while (i >= 0 && !result) {
      if (i === ai) {
        begs.push(i);
        ai = str.indexOf(a3, i + 1);
      } else if (begs.length === 1) {
        const r2 = begs.pop();
        if (r2 !== undefined)
          result = [r2, bi];
      } else {
        beg = begs.pop();
        if (beg !== undefined && beg < left) {
          left = beg;
          right = bi;
        }
        bi = str.indexOf(b3, i + 1);
      }
      i = ai < bi && ai >= 0 ? ai : bi;
    }
    if (begs.length && right !== undefined) {
      result = [left, right];
    }
  }
  return result;
};

// node_modules/@isaacs/brace-expansion/dist/esm/index.js
var escSlash = "\x00SLASH" + Math.random() + "\x00";
var escOpen = "\x00OPEN" + Math.random() + "\x00";
var escClose = "\x00CLOSE" + Math.random() + "\x00";
var escComma = "\x00COMMA" + Math.random() + "\x00";
var escPeriod = "\x00PERIOD" + Math.random() + "\x00";
var escSlashPattern = new RegExp(escSlash, "g");
var escOpenPattern = new RegExp(escOpen, "g");
var escClosePattern = new RegExp(escClose, "g");
var escCommaPattern = new RegExp(escComma, "g");
var escPeriodPattern = new RegExp(escPeriod, "g");
var slashPattern = /\\\\/g;
var openPattern = /\\{/g;
var closePattern = /\\}/g;
var commaPattern = /\\,/g;
var periodPattern = /\\./g;
function numeric(str) {
  return !isNaN(str) ? parseInt(str, 10) : str.charCodeAt(0);
}
function escapeBraces(str) {
  return str.replace(slashPattern, escSlash).replace(openPattern, escOpen).replace(closePattern, escClose).replace(commaPattern, escComma).replace(periodPattern, escPeriod);
}
function unescapeBraces(str) {
  return str.replace(escSlashPattern, "\\").replace(escOpenPattern, "{").replace(escClosePattern, "}").replace(escCommaPattern, ",").replace(escPeriodPattern, ".");
}
function parseCommaParts(str) {
  if (!str) {
    return [""];
  }
  const parts = [];
  const m2 = balanced("{", "}", str);
  if (!m2) {
    return str.split(",");
  }
  const { pre, body, post } = m2;
  const p = pre.split(",");
  p[p.length - 1] += "{" + body + "}";
  const postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length - 1] += postParts.shift();
    p.push.apply(p, postParts);
  }
  parts.push.apply(parts, p);
  return parts;
}
function expand(str) {
  if (!str) {
    return [];
  }
  if (str.slice(0, 2) === "{}") {
    str = "\\{\\}" + str.slice(2);
  }
  return expand_(escapeBraces(str), true).map(unescapeBraces);
}
function embrace(str) {
  return "{" + str + "}";
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}
function lte(i, y3) {
  return i <= y3;
}
function gte(i, y3) {
  return i >= y3;
}
function expand_(str, isTop) {
  const expansions = [];
  const m2 = balanced("{", "}", str);
  if (!m2)
    return [str];
  const pre = m2.pre;
  const post = m2.post.length ? expand_(m2.post, false) : [""];
  if (/\$$/.test(m2.pre)) {
    for (let k2 = 0;k2 < post.length; k2++) {
      const expansion = pre + "{" + m2.body + "}" + post[k2];
      expansions.push(expansion);
    }
  } else {
    const isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m2.body);
    const isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m2.body);
    const isSequence = isNumericSequence || isAlphaSequence;
    const isOptions = m2.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m2.post.match(/,(?!,).*\}/)) {
        str = m2.pre + "{" + m2.body + escClose + m2.post;
        return expand_(str);
      }
      return [str];
    }
    let n;
    if (isSequence) {
      n = m2.body.split(/\.\./);
    } else {
      n = parseCommaParts(m2.body);
      if (n.length === 1 && n[0] !== undefined) {
        n = expand_(n[0], false).map(embrace);
        if (n.length === 1) {
          return post.map((p) => m2.pre + n[0] + p);
        }
      }
    }
    let N2;
    if (isSequence && n[0] !== undefined && n[1] !== undefined) {
      const x3 = numeric(n[0]);
      const y3 = numeric(n[1]);
      const width = Math.max(n[0].length, n[1].length);
      let incr = n.length === 3 && n[2] !== undefined ? Math.abs(numeric(n[2])) : 1;
      let test = lte;
      const reverse = y3 < x3;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      const pad = n.some(isPadded);
      N2 = [];
      for (let i = x3;test(i, y3); i += incr) {
        let c2;
        if (isAlphaSequence) {
          c2 = String.fromCharCode(i);
          if (c2 === "\\") {
            c2 = "";
          }
        } else {
          c2 = String(i);
          if (pad) {
            const need = width - c2.length;
            if (need > 0) {
              const z3 = new Array(need + 1).join("0");
              if (i < 0) {
                c2 = "-" + z3 + c2.slice(1);
              } else {
                c2 = z3 + c2;
              }
            }
          }
        }
        N2.push(c2);
      }
    } else {
      N2 = [];
      for (let j2 = 0;j2 < n.length; j2++) {
        N2.push.apply(N2, expand_(n[j2], false));
      }
    }
    for (let j2 = 0;j2 < N2.length; j2++) {
      for (let k2 = 0;k2 < post.length; k2++) {
        const expansion = pre + N2[j2] + post[k2];
        if (!isTop || isSequence || expansion) {
          expansions.push(expansion);
        }
      }
    }
  }
  return expansions;
}

// node_modules/minimatch/dist/esm/assert-valid-pattern.js
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern) => {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};

// node_modules/minimatch/dist/esm/brace-expressions.js
var posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
  "[:alpha:]": ["\\p{L}\\p{Nl}", true],
  "[:ascii:]": ["\\x" + "00-\\x" + "7f", false],
  "[:blank:]": ["\\p{Zs}\\t", true],
  "[:cntrl:]": ["\\p{Cc}", true],
  "[:digit:]": ["\\p{Nd}", true],
  "[:graph:]": ["\\p{Z}\\p{C}", true, true],
  "[:lower:]": ["\\p{Ll}", true],
  "[:print:]": ["\\p{C}", true],
  "[:punct:]": ["\\p{P}", true],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
  "[:upper:]": ["\\p{Lu}", true],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
  "[:xdigit:]": ["A-Fa-f0-9", false]
};
var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var rangesToString = (ranges) => ranges.join("");
var parseClass = (glob, position) => {
  const pos2 = position;
  if (glob.charAt(pos2) !== "[") {
    throw new Error("not in a brace expression");
  }
  const ranges = [];
  const negs = [];
  let i = pos2 + 1;
  let sawStart = false;
  let uflag = false;
  let escaping = false;
  let negate = false;
  let endPos = pos2;
  let rangeStart = "";
  WHILE:
    while (i < glob.length) {
      const c2 = glob.charAt(i);
      if ((c2 === "!" || c2 === "^") && i === pos2 + 1) {
        negate = true;
        i++;
        continue;
      }
      if (c2 === "]" && sawStart && !escaping) {
        endPos = i + 1;
        break;
      }
      sawStart = true;
      if (c2 === "\\") {
        if (!escaping) {
          escaping = true;
          i++;
          continue;
        }
      }
      if (c2 === "[" && !escaping) {
        for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
          if (glob.startsWith(cls, i)) {
            if (rangeStart) {
              return ["$.", false, glob.length - pos2, true];
            }
            i += cls.length;
            if (neg)
              negs.push(unip);
            else
              ranges.push(unip);
            uflag = uflag || u;
            continue WHILE;
          }
        }
      }
      escaping = false;
      if (rangeStart) {
        if (c2 > rangeStart) {
          ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c2));
        } else if (c2 === rangeStart) {
          ranges.push(braceEscape(c2));
        }
        rangeStart = "";
        i++;
        continue;
      }
      if (glob.startsWith("-]", i + 1)) {
        ranges.push(braceEscape(c2 + "-"));
        i += 2;
        continue;
      }
      if (glob.startsWith("-", i + 1)) {
        rangeStart = c2;
        i += 2;
        continue;
      }
      ranges.push(braceEscape(c2));
      i++;
    }
  if (endPos < i) {
    return ["", false, 0, false];
  }
  if (!ranges.length && !negs.length) {
    return ["$.", false, glob.length - pos2, true];
  }
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
    const r2 = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r2), false, endPos - pos2, false];
  }
  const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
  const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
  const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
  return [comb, uflag, endPos - pos2, true];
};

// node_modules/minimatch/dist/esm/unescape.js
var unescape = (s, { windowsPathsNoEscape = false, magicalBraces = true } = {}) => {
  if (magicalBraces) {
    return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
  }
  return windowsPathsNoEscape ? s.replace(/\[([^\/\\{}])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\{}])\]/g, "$1$2").replace(/\\([^\/{}])/g, "$1");
};

// node_modules/minimatch/dist/esm/ast.js
var types2 = new Set(["!", "?", "+", "*", "@"]);
var isExtglobType = (c2) => types2.has(c2);
var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
var startNoDot = "(?!\\.)";
var addPatternStart = new Set(["[", "."]);
var justDots = new Set(["..", "."]);
var reSpecials = new Set("().*{}+?[]^$\\!");
var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var qmark = "[^/]";
var star = qmark + "*?";
var starNoEmpty = qmark + "+?";

class AST {
  type;
  #root;
  #hasMagic;
  #uflag = false;
  #parts = [];
  #parent;
  #parentIndex;
  #negs;
  #filledNegs = false;
  #options;
  #toString;
  #emptyExt = false;
  constructor(type, parent, options = {}) {
    this.type = type;
    if (type)
      this.#hasMagic = true;
    this.#parent = parent;
    this.#root = this.#parent ? this.#parent.#root : this;
    this.#options = this.#root === this ? options : this.#root.#options;
    this.#negs = this.#root === this ? [] : this.#root.#negs;
    if (type === "!" && !this.#root.#filledNegs)
      this.#negs.push(this);
    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
  }
  get hasMagic() {
    if (this.#hasMagic !== undefined)
      return this.#hasMagic;
    for (const p of this.#parts) {
      if (typeof p === "string")
        continue;
      if (p.type || p.hasMagic)
        return this.#hasMagic = true;
    }
    return this.#hasMagic;
  }
  toString() {
    if (this.#toString !== undefined)
      return this.#toString;
    if (!this.type) {
      return this.#toString = this.#parts.map((p) => String(p)).join("");
    } else {
      return this.#toString = this.type + "(" + this.#parts.map((p) => String(p)).join("|") + ")";
    }
  }
  #fillNegs() {
    if (this !== this.#root)
      throw new Error("should only call on root");
    if (this.#filledNegs)
      return this;
    this.toString();
    this.#filledNegs = true;
    let n;
    while (n = this.#negs.pop()) {
      if (n.type !== "!")
        continue;
      let p = n;
      let pp = p.#parent;
      while (pp) {
        for (let i = p.#parentIndex + 1;!pp.type && i < pp.#parts.length; i++) {
          for (const part of n.#parts) {
            if (typeof part === "string") {
              throw new Error("string part in extglob AST??");
            }
            part.copyIn(pp.#parts[i]);
          }
        }
        p = pp;
        pp = p.#parent;
      }
    }
    return this;
  }
  push(...parts) {
    for (const p of parts) {
      if (p === "")
        continue;
      if (typeof p !== "string" && !(p instanceof AST && p.#parent === this)) {
        throw new Error("invalid part: " + p);
      }
      this.#parts.push(p);
    }
  }
  toJSON() {
    const ret = this.type === null ? this.#parts.slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...this.#parts.map((p) => p.toJSON())];
    if (this.isStart() && !this.type)
      ret.unshift([]);
    if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!")) {
      ret.push({});
    }
    return ret;
  }
  isStart() {
    if (this.#root === this)
      return true;
    if (!this.#parent?.isStart())
      return false;
    if (this.#parentIndex === 0)
      return true;
    const p = this.#parent;
    for (let i = 0;i < this.#parentIndex; i++) {
      const pp = p.#parts[i];
      if (!(pp instanceof AST && pp.type === "!")) {
        return false;
      }
    }
    return true;
  }
  isEnd() {
    if (this.#root === this)
      return true;
    if (this.#parent?.type === "!")
      return true;
    if (!this.#parent?.isEnd())
      return false;
    if (!this.type)
      return this.#parent?.isEnd();
    const pl = this.#parent ? this.#parent.#parts.length : 0;
    return this.#parentIndex === pl - 1;
  }
  copyIn(part) {
    if (typeof part === "string")
      this.push(part);
    else
      this.push(part.clone(this));
  }
  clone(parent) {
    const c2 = new AST(this.type, parent);
    for (const p of this.#parts) {
      c2.copyIn(p);
    }
    return c2;
  }
  static #parseAST(str, ast, pos2, opt) {
    let escaping = false;
    let inBrace = false;
    let braceStart = -1;
    let braceNeg = false;
    if (ast.type === null) {
      let i2 = pos2;
      let acc2 = "";
      while (i2 < str.length) {
        const c2 = str.charAt(i2++);
        if (escaping || c2 === "\\") {
          escaping = !escaping;
          acc2 += c2;
          continue;
        }
        if (inBrace) {
          if (i2 === braceStart + 1) {
            if (c2 === "^" || c2 === "!") {
              braceNeg = true;
            }
          } else if (c2 === "]" && !(i2 === braceStart + 2 && braceNeg)) {
            inBrace = false;
          }
          acc2 += c2;
          continue;
        } else if (c2 === "[") {
          inBrace = true;
          braceStart = i2;
          braceNeg = false;
          acc2 += c2;
          continue;
        }
        if (!opt.noext && isExtglobType(c2) && str.charAt(i2) === "(") {
          ast.push(acc2);
          acc2 = "";
          const ext = new AST(c2, ast);
          i2 = AST.#parseAST(str, ext, i2, opt);
          ast.push(ext);
          continue;
        }
        acc2 += c2;
      }
      ast.push(acc2);
      return i2;
    }
    let i = pos2 + 1;
    let part = new AST(null, ast);
    const parts = [];
    let acc = "";
    while (i < str.length) {
      const c2 = str.charAt(i++);
      if (escaping || c2 === "\\") {
        escaping = !escaping;
        acc += c2;
        continue;
      }
      if (inBrace) {
        if (i === braceStart + 1) {
          if (c2 === "^" || c2 === "!") {
            braceNeg = true;
          }
        } else if (c2 === "]" && !(i === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc += c2;
        continue;
      } else if (c2 === "[") {
        inBrace = true;
        braceStart = i;
        braceNeg = false;
        acc += c2;
        continue;
      }
      if (isExtglobType(c2) && str.charAt(i) === "(") {
        part.push(acc);
        acc = "";
        const ext = new AST(c2, part);
        part.push(ext);
        i = AST.#parseAST(str, ext, i, opt);
        continue;
      }
      if (c2 === "|") {
        part.push(acc);
        acc = "";
        parts.push(part);
        part = new AST(null, ast);
        continue;
      }
      if (c2 === ")") {
        if (acc === "" && ast.#parts.length === 0) {
          ast.#emptyExt = true;
        }
        part.push(acc);
        acc = "";
        ast.push(...parts, part);
        return i;
      }
      acc += c2;
    }
    ast.type = null;
    ast.#hasMagic = undefined;
    ast.#parts = [str.substring(pos2 - 1)];
    return i;
  }
  static fromGlob(pattern, options = {}) {
    const ast = new AST(null, undefined, options);
    AST.#parseAST(pattern, ast, 0, options);
    return ast;
  }
  toMMPattern() {
    if (this !== this.#root)
      return this.#root.toMMPattern();
    const glob = this.toString();
    const [re2, body, hasMagic, uflag] = this.toRegExpSource();
    const anyMagic = hasMagic || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();
    if (!anyMagic) {
      return body;
    }
    const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
    return Object.assign(new RegExp(`^${re2}$`, flags), {
      _src: re2,
      _glob: glob
    });
  }
  get options() {
    return this.#options;
  }
  toRegExpSource(allowDot) {
    const dot = allowDot ?? !!this.#options.dot;
    if (this.#root === this)
      this.#fillNegs();
    if (!this.type) {
      const noEmpty = this.isStart() && this.isEnd() && !this.#parts.some((s) => typeof s !== "string");
      const src = this.#parts.map((p) => {
        const [re2, _3, hasMagic, uflag] = typeof p === "string" ? AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);
        this.#hasMagic = this.#hasMagic || hasMagic;
        this.#uflag = this.#uflag || uflag;
        return re2;
      }).join("");
      let start2 = "";
      if (this.isStart()) {
        if (typeof this.#parts[0] === "string") {
          const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
          if (!dotTravAllowed) {
            const aps = addPatternStart;
            const needNoTrav = dot && aps.has(src.charAt(0)) || src.startsWith("\\.") && aps.has(src.charAt(2)) || src.startsWith("\\.\\.") && aps.has(src.charAt(4));
            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
            start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
          }
        }
      }
      let end = "";
      if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!") {
        end = "(?:$|\\/)";
      }
      const final2 = start2 + src + end;
      return [
        final2,
        unescape(src),
        this.#hasMagic = !!this.#hasMagic,
        this.#uflag
      ];
    }
    const repeated = this.type === "*" || this.type === "+";
    const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let body = this.#partsToRegExp(dot);
    if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
      const s = this.toString();
      this.#parts = [s];
      this.type = null;
      this.#hasMagic = undefined;
      return [s, unescape(this.toString()), false, false];
    }
    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.#partsToRegExp(true);
    if (bodyDotAllowed === body) {
      bodyDotAllowed = "";
    }
    if (bodyDotAllowed) {
      body = `(?:${body})(?:${bodyDotAllowed})*?`;
    }
    let final = "";
    if (this.type === "!" && this.#emptyExt) {
      final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
    } else {
      const close = this.type === "!" ? "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")" : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
      final = start + body + close;
    }
    return [
      final,
      unescape(body),
      this.#hasMagic = !!this.#hasMagic,
      this.#uflag
    ];
  }
  #partsToRegExp(dot) {
    return this.#parts.map((p) => {
      if (typeof p === "string") {
        throw new Error("string type in extglob ast??");
      }
      const [re2, _3, _hasMagic, uflag] = p.toRegExpSource(dot);
      this.#uflag = this.#uflag || uflag;
      return re2;
    }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
  }
  static #parseGlob(glob, hasMagic, noEmpty = false) {
    let escaping = false;
    let re2 = "";
    let uflag = false;
    for (let i = 0;i < glob.length; i++) {
      const c2 = glob.charAt(i);
      if (escaping) {
        escaping = false;
        re2 += (reSpecials.has(c2) ? "\\" : "") + c2;
        continue;
      }
      if (c2 === "\\") {
        if (i === glob.length - 1) {
          re2 += "\\\\";
        } else {
          escaping = true;
        }
        continue;
      }
      if (c2 === "[") {
        const [src, needUflag, consumed, magic] = parseClass(glob, i);
        if (consumed) {
          re2 += src;
          uflag = uflag || needUflag;
          i += consumed - 1;
          hasMagic = hasMagic || magic;
          continue;
        }
      }
      if (c2 === "*") {
        re2 += noEmpty && glob === "*" ? starNoEmpty : star;
        hasMagic = true;
        continue;
      }
      if (c2 === "?") {
        re2 += qmark;
        hasMagic = true;
        continue;
      }
      re2 += regExpEscape(c2);
    }
    return [re2, unescape(glob), !!hasMagic, uflag];
  }
}

// node_modules/minimatch/dist/esm/escape.js
var escape = (s, { windowsPathsNoEscape = false, magicalBraces = false } = {}) => {
  if (magicalBraces) {
    return windowsPathsNoEscape ? s.replace(/[?*()[\]{}]/g, "[$&]") : s.replace(/[?*()[\]\\{}]/g, "\\$&");
  }
  return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
};

// node_modules/minimatch/dist/esm/index.js
var minimatch = (p, pattern, options = {}) => {
  assertValidPattern(pattern);
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern, options).match(p);
};
var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
var starDotExtTest = (ext) => (f3) => !f3.startsWith(".") && f3.endsWith(ext);
var starDotExtTestDot = (ext) => (f3) => f3.endsWith(ext);
var starDotExtTestNocase = (ext) => {
  ext = ext.toLowerCase();
  return (f3) => !f3.startsWith(".") && f3.toLowerCase().endsWith(ext);
};
var starDotExtTestNocaseDot = (ext) => {
  ext = ext.toLowerCase();
  return (f3) => f3.toLowerCase().endsWith(ext);
};
var starDotStarRE = /^\*+\.\*+$/;
var starDotStarTest = (f3) => !f3.startsWith(".") && f3.includes(".");
var starDotStarTestDot = (f3) => f3 !== "." && f3 !== ".." && f3.includes(".");
var dotStarRE = /^\.\*+$/;
var dotStarTest = (f3) => f3 !== "." && f3 !== ".." && f3.startsWith(".");
var starRE = /^\*+$/;
var starTest = (f3) => f3.length !== 0 && !f3.startsWith(".");
var starTestDot = (f3) => f3.length !== 0 && f3 !== "." && f3 !== "..";
var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
var qmarksTestNocase = ([$0, ext = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  if (!ext)
    return noext;
  ext = ext.toLowerCase();
  return (f3) => noext(f3) && f3.toLowerCase().endsWith(ext);
};
var qmarksTestNocaseDot = ([$0, ext = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  if (!ext)
    return noext;
  ext = ext.toLowerCase();
  return (f3) => noext(f3) && f3.toLowerCase().endsWith(ext);
};
var qmarksTestDot = ([$0, ext = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  return !ext ? noext : (f3) => noext(f3) && f3.endsWith(ext);
};
var qmarksTest = ([$0, ext = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  return !ext ? noext : (f3) => noext(f3) && f3.endsWith(ext);
};
var qmarksTestNoExt = ([$0]) => {
  const len = $0.length;
  return (f3) => f3.length === len && !f3.startsWith(".");
};
var qmarksTestNoExtDot = ([$0]) => {
  const len = $0.length;
  return (f3) => f3.length === len && f3 !== "." && f3 !== "..";
};
var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
var path10 = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
};
var sep = defaultPlatform === "win32" ? path10.win32.sep : path10.posix.sep;
minimatch.sep = sep;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark2 = "[^/]";
var star2 = qmark2 + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);
minimatch.filter = filter;
var ext = (a3, b3 = {}) => Object.assign({}, a3, b3);
var defaults = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  const orig = minimatch;
  const m2 = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
  return Object.assign(m2, {
    Minimatch: class Minimatch extends orig.Minimatch {
      constructor(pattern, options = {}) {
        super(pattern, ext(def, options));
      }
      static defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      }
    },
    AST: class AST2 extends orig.AST {
      constructor(type, parent, options = {}) {
        super(type, parent, ext(def, options));
      }
      static fromGlob(pattern, options = {}) {
        return orig.AST.fromGlob(pattern, ext(def, options));
      }
    },
    unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
    escape: (s, options = {}) => orig.escape(s, ext(def, options)),
    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
    defaults: (options) => orig.defaults(ext(def, options)),
    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
    match: (list3, pattern, options = {}) => orig.match(list3, pattern, ext(def, options)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults;
var braceExpand = (pattern, options = {}) => {
  assertValidPattern(pattern);
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return expand(pattern);
};
minimatch.braceExpand = braceExpand;
var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
var match = (list3, pattern, options = {}) => {
  const mm = new Minimatch(pattern, options);
  list3 = list3.filter((f3) => mm.match(f3));
  if (mm.options.nonull && !list3.length) {
    list3.push(pattern);
  }
  return list3;
};
minimatch.match = match;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
var regExpEscape2 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");

class Minimatch {
  options;
  set;
  pattern;
  windowsPathsNoEscape;
  nonegate;
  negate;
  comment;
  empty;
  preserveMultipleSlashes;
  partial;
  globSet;
  globParts;
  nocase;
  isWindows;
  platform;
  windowsNoMagicRoot;
  regexp;
  constructor(pattern, options = {}) {
    assertValidPattern(pattern);
    options = options || {};
    this.options = options;
    this.pattern = pattern;
    this.platform = options.platform || defaultPlatform;
    this.isWindows = this.platform === "win32";
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
    this.regexp = null;
    this.negate = false;
    this.nonegate = !!options.nonegate;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.nocase = !!this.options.nocase;
    this.windowsNoMagicRoot = options.windowsNoMagicRoot !== undefined ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
    this.globSet = [];
    this.globParts = [];
    this.set = [];
    this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) {
      return true;
    }
    for (const pattern of this.set) {
      for (const part of pattern) {
        if (typeof part !== "string")
          return true;
      }
    }
    return false;
  }
  debug(..._3) {}
  make() {
    const pattern = this.pattern;
    const options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    this.globSet = [...new Set(this.braceExpand())];
    if (options.debug) {
      this.debug = (...args) => console.error(...args);
    }
    this.debug(this.pattern, this.globSet);
    const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
    this.globParts = this.preprocess(rawGlobParts);
    this.debug(this.pattern, this.globParts);
    let set = this.globParts.map((s, _3, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
        const isDrive = /^[a-z]:/i.test(s[0]);
        if (isUNC) {
          return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
        } else if (isDrive) {
          return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
        }
      }
      return s.map((ss) => this.parse(ss));
    });
    this.debug(this.pattern, set);
    this.set = set.filter((s) => s.indexOf(false) === -1);
    if (this.isWindows) {
      for (let i = 0;i < this.set.length; i++) {
        const p = this.set[i];
        if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
          p[2] = "?";
        }
      }
    }
    this.debug(this.pattern, this.set);
  }
  preprocess(globParts) {
    if (this.options.noglobstar) {
      for (let i = 0;i < globParts.length; i++) {
        for (let j2 = 0;j2 < globParts[i].length; j2++) {
          if (globParts[i][j2] === "**") {
            globParts[i][j2] = "*";
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      globParts = this.firstPhasePreProcess(globParts);
      globParts = this.secondPhasePreProcess(globParts);
    } else if (optimizationLevel >= 1) {
      globParts = this.levelOneOptimize(globParts);
    } else {
      globParts = this.adjascentGlobstarOptimize(globParts);
    }
    return globParts;
  }
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs = -1;
      while ((gs = parts.indexOf("**", gs + 1)) !== -1) {
        let i = gs;
        while (parts[i + 1] === "**") {
          i++;
        }
        if (i !== gs) {
          parts.splice(gs, i - gs);
        }
      }
      return parts;
    });
  }
  levelOneOptimize(globParts) {
    return globParts.map((parts) => {
      parts = parts.reduce((set, part) => {
        const prev = set[set.length - 1];
        if (part === "**" && prev === "**") {
          return set;
        }
        if (part === "..") {
          if (prev && prev !== ".." && prev !== "." && prev !== "**") {
            set.pop();
            return set;
          }
        }
        set.push(part);
        return set;
      }, []);
      return parts.length === 0 ? [""] : parts;
    });
  }
  levelTwoFileOptimize(parts) {
    if (!Array.isArray(parts)) {
      parts = this.slashSplit(parts);
    }
    let didSomething = false;
    do {
      didSomething = false;
      if (!this.preserveMultipleSlashes) {
        for (let i = 1;i < parts.length - 1; i++) {
          const p = parts[i];
          if (i === 1 && p === "" && parts[0] === "")
            continue;
          if (p === "." || p === "") {
            didSomething = true;
            parts.splice(i, 1);
            i--;
          }
        }
        if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
          didSomething = true;
          parts.pop();
        }
      }
      let dd = 0;
      while ((dd = parts.indexOf("..", dd + 1)) !== -1) {
        const p = parts[dd - 1];
        if (p && p !== "." && p !== ".." && p !== "**") {
          didSomething = true;
          parts.splice(dd - 1, 2);
          dd -= 2;
        }
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  firstPhasePreProcess(globParts) {
    let didSomething = false;
    do {
      didSomething = false;
      for (let parts of globParts) {
        let gs = -1;
        while ((gs = parts.indexOf("**", gs + 1)) !== -1) {
          let gss = gs;
          while (parts[gss + 1] === "**") {
            gss++;
          }
          if (gss > gs) {
            parts.splice(gs + 1, gss - gs);
          }
          let next = parts[gs + 1];
          const p = parts[gs + 2];
          const p2 = parts[gs + 3];
          if (next !== "..")
            continue;
          if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
            continue;
          }
          didSomething = true;
          parts.splice(gs, 1);
          const other = parts.slice(0);
          other[gs] = "**";
          globParts.push(other);
          gs--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i = 1;i < parts.length - 1; i++) {
            const p = parts[i];
            if (i === 1 && p === "" && parts[0] === "")
              continue;
            if (p === "." || p === "") {
              didSomething = true;
              parts.splice(i, 1);
              i--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while ((dd = parts.indexOf("..", dd + 1)) !== -1) {
          const p = parts[dd - 1];
          if (p && p !== "." && p !== ".." && p !== "**") {
            didSomething = true;
            const needDot = dd === 1 && parts[dd + 1] === "**";
            const splin = needDot ? ["."] : [];
            parts.splice(dd - 1, 2, ...splin);
            if (parts.length === 0)
              parts.push("");
            dd -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  secondPhasePreProcess(globParts) {
    for (let i = 0;i < globParts.length - 1; i++) {
      for (let j2 = i + 1;j2 < globParts.length; j2++) {
        const matched = this.partsMatch(globParts[i], globParts[j2], !this.preserveMultipleSlashes);
        if (matched) {
          globParts[i] = [];
          globParts[j2] = matched;
          break;
        }
      }
    }
    return globParts.filter((gs) => gs.length);
  }
  partsMatch(a3, b3, emptyGSMatch = false) {
    let ai = 0;
    let bi = 0;
    let result = [];
    let which = "";
    while (ai < a3.length && bi < b3.length) {
      if (a3[ai] === b3[bi]) {
        result.push(which === "b" ? b3[bi] : a3[ai]);
        ai++;
        bi++;
      } else if (emptyGSMatch && a3[ai] === "**" && b3[bi] === a3[ai + 1]) {
        result.push(a3[ai]);
        ai++;
      } else if (emptyGSMatch && b3[bi] === "**" && a3[ai] === b3[bi + 1]) {
        result.push(b3[bi]);
        bi++;
      } else if (a3[ai] === "*" && b3[bi] && (this.options.dot || !b3[bi].startsWith(".")) && b3[bi] !== "**") {
        if (which === "b")
          return false;
        which = "a";
        result.push(a3[ai]);
        ai++;
        bi++;
      } else if (b3[bi] === "*" && a3[ai] && (this.options.dot || !a3[ai].startsWith(".")) && a3[ai] !== "**") {
        if (which === "a")
          return false;
        which = "b";
        result.push(b3[bi]);
        ai++;
        bi++;
      } else {
        return false;
      }
    }
    return a3.length === b3.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const pattern = this.pattern;
    let negate = false;
    let negateOffset = 0;
    for (let i = 0;i < pattern.length && pattern.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.slice(negateOffset);
    this.negate = negate;
  }
  matchOne(file, pattern, partial = false) {
    const options = this.options;
    if (this.isWindows) {
      const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
      const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
      const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
      const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
      const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;
      const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;
      if (typeof fdi === "number" && typeof pdi === "number") {
        const [fd, pd] = [file[fdi], pattern[pdi]];
        if (fd.toLowerCase() === pd.toLowerCase()) {
          pattern[pdi] = fd;
          if (pdi > fdi) {
            pattern = pattern.slice(pdi);
          } else if (fdi > pdi) {
            file = file.slice(fdi);
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      file = this.levelTwoFileOptimize(file);
    }
    this.debug("matchOne", this, { file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length;fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f3 = file[fi];
      this.debug(pattern, p, f3);
      if (p === false) {
        return false;
      }
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f3]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (;fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug(`
globstar while`, file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug(`
>>> no match, partial?`, file, fr, pattern, pr);
          if (fr === fl) {
            return true;
          }
        }
        return false;
      }
      let hit;
      if (typeof p === "string") {
        hit = f3 === p;
        this.debug("string match", p, f3, hit);
      } else {
        hit = p.test(f3);
        this.debug("pattern match", p, f3, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    } else {
      throw new Error("wtf?");
    }
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    const options = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m2;
    let fastTest = null;
    if (m2 = pattern.match(starRE)) {
      fastTest = options.dot ? starTestDot : starTest;
    } else if (m2 = pattern.match(starDotExtRE)) {
      fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m2[1]);
    } else if (m2 = pattern.match(qmarksRE)) {
      fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m2);
    } else if (m2 = pattern.match(starDotStarRE)) {
      fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
    } else if (m2 = pattern.match(dotStarRE)) {
      fastTest = dotStarTest;
    }
    const re2 = AST.fromGlob(pattern, this.options).toMMPattern();
    if (fastTest && typeof re2 === "object") {
      Reflect.defineProperty(re2, "test", { value: fastTest });
    }
    return re2;
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options = this.options;
    const twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot;
    const flags = new Set(options.nocase ? ["i"] : []);
    let re2 = set.map((pattern) => {
      const pp = pattern.map((p) => {
        if (p instanceof RegExp) {
          for (const f3 of p.flags.split(""))
            flags.add(f3);
        }
        return typeof p === "string" ? regExpEscape2(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
      });
      pp.forEach((p, i) => {
        const next = pp[i + 1];
        const prev = pp[i - 1];
        if (p !== GLOBSTAR || prev === GLOBSTAR) {
          return;
        }
        if (prev === undefined) {
          if (next !== undefined && next !== GLOBSTAR) {
            pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
          } else {
            pp[i] = twoStar;
          }
        } else if (next === undefined) {
          pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + ")?";
        } else if (next !== GLOBSTAR) {
          pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
          pp[i + 1] = GLOBSTAR;
        }
      });
      const filtered = pp.filter((p) => p !== GLOBSTAR);
      if (this.partial && filtered.length >= 1) {
        const prefixes = [];
        for (let i = 1;i <= filtered.length; i++) {
          prefixes.push(filtered.slice(0, i).join("/"));
        }
        return "(?:" + prefixes.join("|") + ")";
      }
      return filtered.join("/");
    }).join("|");
    const [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
    re2 = "^" + open + re2 + close + "$";
    if (this.partial) {
      re2 = "^(?:\\/|" + open + re2.slice(1, -1) + close + ")$";
    }
    if (this.negate)
      re2 = "^(?!" + re2 + ").+$";
    try {
      this.regexp = new RegExp(re2, [...flags].join(""));
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  slashSplit(p) {
    if (this.preserveMultipleSlashes) {
      return p.split("/");
    } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
      return ["", ...p.split(/\/+/)];
    } else {
      return p.split(/\/+/);
    }
  }
  match(f3, partial = this.partial) {
    this.debug("match", f3, this.pattern);
    if (this.comment) {
      return false;
    }
    if (this.empty) {
      return f3 === "";
    }
    if (f3 === "/" && partial) {
      return true;
    }
    const options = this.options;
    if (this.isWindows) {
      f3 = f3.split("\\").join("/");
    }
    const ff = this.slashSplit(f3);
    this.debug(this.pattern, "split", ff);
    const set = this.set;
    this.debug(this.pattern, "set", set);
    let filename = ff[ff.length - 1];
    if (!filename) {
      for (let i = ff.length - 2;!filename && i >= 0; i--) {
        filename = ff[i];
      }
    }
    for (let i = 0;i < set.length; i++) {
      const pattern = set[i];
      let file = ff;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      const hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate) {
          return true;
        }
        return !this.negate;
      }
    }
    if (options.flipNegate) {
      return false;
    }
    return this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
}
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;

// src/domains/installation/merger/file-scanner.ts
class FileScanner {
  includePatterns = [];
  neverCopyChecker;
  constructor(neverCopyPatterns) {
    this.neverCopyChecker = import_ignore2.default().add(neverCopyPatterns);
  }
  setIncludePatterns(patterns) {
    this.includePatterns = patterns;
  }
  addIgnorePatterns(patterns) {
    this.neverCopyChecker.add(patterns);
  }
  shouldNeverCopy(normalizedPath) {
    return this.neverCopyChecker.ignores(normalizedPath);
  }
  async getFiles(dir, baseDir = dir) {
    const files = [];
    const entries = await import_fs_extra7.readdir(dir, { encoding: "utf8" });
    for (const entry of entries) {
      const fullPath = join40(dir, entry);
      const relativePath = relative5(baseDir, fullPath);
      const normalizedRelativePath = relativePath.replace(/\\/g, "/");
      const stats = await import_fs_extra7.lstat(fullPath);
      if (stats.isSymbolicLink()) {
        logger.warning(`Skipping symbolic link: ${normalizedRelativePath}`);
        continue;
      }
      if (this.includePatterns.length > 0) {
        const shouldInclude = this.includePatterns.some((pattern) => {
          const globPattern = pattern.includes("*") ? pattern : `${pattern}/**`;
          if (!stats.isDirectory()) {
            return minimatch(normalizedRelativePath, globPattern, { dot: true });
          }
          const normalizedPattern = pattern.endsWith("/") ? pattern.slice(0, -1) : pattern;
          const normalizedPath = normalizedRelativePath.endsWith("/") ? normalizedRelativePath.slice(0, -1) : normalizedRelativePath;
          return normalizedPattern.startsWith(`${normalizedPath}/`) || normalizedPattern === normalizedPath || minimatch(normalizedRelativePath, globPattern, { dot: true });
        });
        if (!shouldInclude) {
          continue;
        }
      }
      if (stats.isDirectory()) {
        const subFiles = await this.getFiles(fullPath, baseDir);
        files.push(...subFiles);
      } else {
        files.push(fullPath);
      }
    }
    return files;
  }
}

// src/domains/config/installed-settings-tracker.ts
import { existsSync as existsSync17 } from "node:fs";
import { mkdir as mkdir15, readFile as readFile13, writeFile as writeFile10 } from "node:fs/promises";
import { dirname as dirname6, join as join41 } from "node:path";

// src/shared/index.ts
init_logger();
init_environment();
init_terminal_utils();
init_path_resolver();

// src/shared/command-normalizer.ts
function normalizeCommand(cmd) {
  if (!cmd)
    return "";
  let normalized = cmd;
  normalized = normalized.replace(/"\$HOME"/g, "$HOME");
  normalized = normalized.replace(/"\$CLAUDE_PROJECT_DIR"/g, "$HOME");
  normalized = normalized.replace(/"\$\{HOME\}"/g, "$HOME");
  normalized = normalized.replace(/\$CLAUDE_PROJECT_DIR/g, "$HOME");
  normalized = normalized.replace(/\$\{HOME\}/g, "$HOME");
  normalized = normalized.replace(/"%USERPROFILE%"/g, "$HOME");
  normalized = normalized.replace(/%USERPROFILE%/g, "$HOME");
  normalized = normalized.replace(/"%CLAUDE_PROJECT_DIR%"/g, "$HOME");
  normalized = normalized.replace(/%CLAUDE_PROJECT_DIR%/g, "$HOME");
  normalized = normalized.replace(/\\/g, "/");
  normalized = normalized.replace(/\s+/g, " ").trim();
  return normalized;
}
// src/domains/config/installed-settings-tracker.ts
var CK_JSON_FILE = ".ck.json";

class InstalledSettingsTracker {
  projectDir;
  isGlobal;
  kitName;
  constructor(projectDir, isGlobal, kitName = "engineer") {
    this.projectDir = projectDir;
    this.isGlobal = isGlobal;
    this.kitName = kitName;
  }
  getCkJsonPath() {
    if (this.isGlobal) {
      return join41(this.projectDir, CK_JSON_FILE);
    }
    return join41(this.projectDir, ".claude", CK_JSON_FILE);
  }
  async loadInstalledSettings() {
    const ckJsonPath = this.getCkJsonPath();
    if (!existsSync17(ckJsonPath)) {
      return { hooks: [], mcpServers: [] };
    }
    try {
      const content = await readFile13(ckJsonPath, "utf-8");
      const data = JSON.parse(content);
      const installed = data.kits?.[this.kitName]?.installedSettings;
      if (installed) {
        return installed;
      }
      return { hooks: [], mcpServers: [] };
    } catch (error) {
      logger.debug(`Failed to load installed settings: ${error instanceof Error ? error.message : "Unknown error"}`);
      return { hooks: [], mcpServers: [] };
    }
  }
  async saveInstalledSettings(settings) {
    const ckJsonPath = this.getCkJsonPath();
    try {
      let data = {};
      if (existsSync17(ckJsonPath)) {
        const content = await readFile13(ckJsonPath, "utf-8");
        data = JSON.parse(content);
      }
      if (!data.kits) {
        data.kits = {};
      }
      if (!data.kits[this.kitName]) {
        data.kits[this.kitName] = {};
      }
      data.kits[this.kitName].installedSettings = settings;
      await mkdir15(dirname6(ckJsonPath), { recursive: true });
      await writeFile10(ckJsonPath, JSON.stringify(data, null, 2), "utf-8");
      logger.debug(`Saved installed settings to ${ckJsonPath}`);
    } catch (error) {
      logger.warning(`Failed to save installed settings: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  wasHookInstalled(command, installed) {
    const normalizedCommand = normalizeCommand(command);
    return installed.hooks?.some((hook) => normalizeCommand(hook) === normalizedCommand) ?? false;
  }
  wasMcpServerInstalled(serverName, installed) {
    return installed.mcpServers?.includes(serverName) ?? false;
  }
  trackHook(command, settings) {
    if (!settings.hooks) {
      settings.hooks = [];
    }
    const normalizedCommand = normalizeCommand(command);
    const alreadyTracked = settings.hooks.some((hook) => normalizeCommand(hook) === normalizedCommand);
    if (!alreadyTracked) {
      settings.hooks.push(normalizedCommand);
    }
  }
  trackMcpServer(serverName, settings) {
    if (!settings.mcpServers) {
      settings.mcpServers = [];
    }
    if (!settings.mcpServers.includes(serverName)) {
      settings.mcpServers.push(serverName);
    }
  }
  async clearTracking() {
    await this.saveInstalledSettings({ hooks: [], mcpServers: [] });
    logger.debug("Cleared installed settings tracking");
  }
}

// src/domains/config/merger/diff-calculator.ts
function truncateCommand(cmd, maxLen = 50) {
  if (cmd.length <= maxLen)
    return cmd;
  return `${cmd.slice(0, maxLen - 3)}...`;
}
function deepCopyEntry(entry) {
  if ("hooks" in entry) {
    return {
      ...entry,
      hooks: entry.hooks ? [...entry.hooks.map((h2) => ({ ...h2 }))] : undefined
    };
  }
  return { ...entry };
}
function extractCommands(entries, commands) {
  for (const entry of entries) {
    if ("command" in entry && entry.command) {
      commands.add(normalizeCommand(entry.command));
    }
    if ("hooks" in entry && entry.hooks) {
      for (const hook of entry.hooks) {
        if (hook.command) {
          commands.add(normalizeCommand(hook.command));
        }
      }
    }
  }
}
function getEntryCommands(entry) {
  const commands = [];
  if ("command" in entry && entry.command) {
    commands.push(entry.command);
  }
  if ("hooks" in entry && entry.hooks) {
    for (const hook of entry.hooks) {
      if (hook.command) {
        commands.push(hook.command);
      }
    }
  }
  return commands;
}
function logDuplicates(duplicateCommands, eventName, result) {
  if (duplicateCommands.length > 0) {
    const summary = duplicateCommands.length === 1 ? `"${truncateCommand(duplicateCommands[0])}"` : `${duplicateCommands.length} commands`;
    result.conflictsDetected.push(`${eventName}: duplicate ${summary}`);
  }
}

// src/domains/config/merger/conflict-resolver.ts
function wasCommandInstalled(command, installedHooks) {
  const normalizedCommand = normalizeCommand(command);
  return installedHooks.some((hook) => normalizeCommand(hook) === normalizedCommand);
}
function dedupeDestinationEntries(entries) {
  const seenCommands = new Set;
  const deduped = [];
  let removedCount = 0;
  for (const entry of entries) {
    const commands = getEntryCommands(entry);
    if (commands.length === 0) {
      deduped.push(deepCopyEntry(entry));
      continue;
    }
    const uniqueCommands = commands.filter((cmd) => !seenCommands.has(normalizeCommand(cmd)));
    if (uniqueCommands.length === 0) {
      removedCount++;
      logger.verbose(`Removing duplicate hook entry: ${commands[0]?.slice(0, 50)}...`);
      continue;
    }
    if ("hooks" in entry && entry.hooks && uniqueCommands.length < commands.length) {
      const filteredHooks = entry.hooks.filter((h2) => !h2.command || !seenCommands.has(normalizeCommand(h2.command)));
      deduped.push({ ...entry, hooks: filteredHooks });
    } else {
      deduped.push(deepCopyEntry(entry));
    }
    for (const cmd of commands) {
      seenCommands.add(normalizeCommand(cmd));
    }
  }
  return { deduped, removedCount };
}
function mergeHookEntries(sourceEntries, destEntries, eventName, result, installedHooks = [], sourceKit) {
  const { deduped: dedupedDest, removedCount } = dedupeDestinationEntries(destEntries);
  if (removedCount > 0) {
    logger.info(`Cleaned up ${removedCount} duplicate hook(s) from existing settings`);
  }
  if (dedupedDest.length > 0) {
    result.hooksPreserved += dedupedDest.length;
  }
  const merged = dedupedDest;
  const matcherIndex = new Map;
  for (let i = 0;i < merged.length; i++) {
    const entry = merged[i];
    if ("matcher" in entry && entry.matcher) {
      matcherIndex.set(entry.matcher, i);
    }
  }
  const existingCommands = new Set;
  extractCommands(dedupedDest, existingCommands);
  for (const entry of sourceEntries) {
    const sourceMatcher = "matcher" in entry ? entry.matcher : undefined;
    const commands = getEntryCommands(entry);
    const userRemovedCommands = commands.filter((cmd) => !existingCommands.has(normalizeCommand(cmd)) && wasCommandInstalled(cmd, installedHooks));
    if (userRemovedCommands.length > 0) {
      result.hooksSkipped += userRemovedCommands.length;
      for (const cmd of userRemovedCommands) {
        logger.verbose(`Skipping hook (user removed): ${cmd.slice(0, 50)}...`);
      }
      if (userRemovedCommands.length === commands.length) {
        continue;
      }
    }
    if (sourceMatcher && matcherIndex.has(sourceMatcher)) {
      const existingIdx = matcherIndex.get(sourceMatcher);
      if (existingIdx === undefined)
        continue;
      const existingEntry = merged[existingIdx];
      const newCommands = commands.filter((cmd) => !existingCommands.has(normalizeCommand(cmd)) && !wasCommandInstalled(cmd, installedHooks));
      const duplicateCommands = commands.filter((cmd) => existingCommands.has(normalizeCommand(cmd)));
      logDuplicates(duplicateCommands, eventName, result);
      if (newCommands.length > 0 && "hooks" in entry && entry.hooks) {
        if (!existingEntry.hooks) {
          existingEntry.hooks = [];
        }
        for (const hook of entry.hooks) {
          if (hook.command && !existingCommands.has(normalizeCommand(hook.command)) && !wasCommandInstalled(hook.command, installedHooks)) {
            const taggedHook = sourceKit ? { ...hook, _origin: sourceKit } : hook;
            existingEntry.hooks.push(taggedHook);
            existingCommands.add(normalizeCommand(hook.command));
            result.newlyInstalledHooks.push(hook.command);
            if (sourceKit) {
              trackHookOrigin(result, sourceKit, hook.command);
            }
          }
        }
        result.hooksAdded++;
      }
    } else {
      const isFullyDuplicated = commands.length > 0 && commands.every((cmd) => existingCommands.has(normalizeCommand(cmd)));
      const duplicateCommands = commands.filter((cmd) => existingCommands.has(normalizeCommand(cmd)));
      logDuplicates(duplicateCommands, eventName, result);
      const hasNonRemovedCommands = commands.length === 0 || commands.some((cmd) => !existingCommands.has(normalizeCommand(cmd)) && !wasCommandInstalled(cmd, installedHooks));
      if (!isFullyDuplicated && hasNonRemovedCommands) {
        let filteredEntry = entry;
        if ("hooks" in entry && entry.hooks && userRemovedCommands.length > 0) {
          const filteredHooks = entry.hooks.filter((h2) => !h2.command || !wasCommandInstalled(h2.command, installedHooks));
          filteredEntry = { ...entry, hooks: filteredHooks };
        } else if ("command" in entry && wasCommandInstalled(entry.command, installedHooks)) {
          continue;
        }
        const taggedEntry = sourceKit ? tagHooksWithOrigin(filteredEntry, sourceKit) : filteredEntry;
        merged.push(taggedEntry);
        result.hooksAdded++;
        if (sourceMatcher) {
          matcherIndex.set(sourceMatcher, merged.length - 1);
        }
        for (const cmd of commands) {
          const normalizedCmd = normalizeCommand(cmd);
          if (!existingCommands.has(normalizedCmd) && !wasCommandInstalled(cmd, installedHooks)) {
            existingCommands.add(normalizedCmd);
            result.newlyInstalledHooks.push(cmd);
            if (sourceKit) {
              trackHookOrigin(result, sourceKit, cmd);
            }
          } else if (!existingCommands.has(normalizedCmd)) {
            existingCommands.add(normalizedCmd);
          }
        }
      }
    }
  }
  return merged;
}
function tagHooksWithOrigin(entry, kit) {
  if ("hooks" in entry && entry.hooks) {
    return {
      ...entry,
      hooks: entry.hooks.map((h2) => ({ ...h2, _origin: kit }))
    };
  }
  if ("command" in entry) {
    return { ...entry, _origin: kit };
  }
  return entry;
}
function trackHookOrigin(result, kit, command) {
  const existing = result.hooksByOrigin.get(kit) || [];
  existing.push(command);
  result.hooksByOrigin.set(kit, existing);
}

// src/domains/config/merger/merge-engine.ts
function mergeHooks(sourceHooks, destHooks, result, options) {
  const merged = { ...destHooks };
  const installedHooks = options?.installedSettings?.hooks ?? [];
  const sourceKit = options?.sourceKit;
  const sourceCommands = new Set;
  for (const entries of Object.values(sourceHooks)) {
    extractCommands(entries, sourceCommands);
  }
  for (const [eventName, sourceEntries] of Object.entries(sourceHooks)) {
    const destEntries = destHooks[eventName] || [];
    merged[eventName] = mergeHookEntries(sourceEntries, destEntries, eventName, result, installedHooks, sourceKit);
  }
  if (installedHooks.length > 0) {
    const deprecatedHooks = installedHooks.filter((hook) => !sourceCommands.has(normalizeCommand(hook)));
    if (deprecatedHooks.length > 0) {
      result.removedHooks = result.removedHooks ?? [];
      for (const [eventName, entries] of Object.entries(merged)) {
        const filtered = removeDeprecatedFromEntries(entries, deprecatedHooks, result);
        if (filtered.length > 0) {
          merged[eventName] = filtered;
        } else {
          delete merged[eventName];
        }
      }
    }
  }
  return merged;
}
function removeDeprecatedFromEntries(entries, deprecatedHooks, result) {
  const deprecatedSet = new Set(deprecatedHooks.map((h2) => normalizeCommand(h2)));
  const filtered = [];
  for (const entry of entries) {
    if ("hooks" in entry && entry.hooks) {
      const remainingHooks = entry.hooks.filter((h2) => {
        if (h2.command && deprecatedSet.has(normalizeCommand(h2.command))) {
          result.hooksRemoved++;
          result.removedHooks?.push(h2.command);
          logger.info(`Removed deprecated hook: ${h2.command.slice(0, 60)}...`);
          return false;
        }
        return true;
      });
      if (remainingHooks.length > 0) {
        filtered.push({ ...entry, hooks: remainingHooks });
      }
    } else if ("command" in entry) {
      if (deprecatedSet.has(normalizeCommand(entry.command))) {
        result.hooksRemoved++;
        result.removedHooks?.push(entry.command);
        logger.info(`Removed deprecated hook: ${entry.command.slice(0, 60)}...`);
      } else {
        filtered.push(entry);
      }
    } else {
      filtered.push(entry);
    }
  }
  return filtered;
}
function mergeMcp(sourceMcp, destMcp, result, options) {
  if (!sourceMcp)
    return destMcp;
  if (!destMcp)
    return sourceMcp;
  const merged = { ...destMcp };
  const installedServers = options?.installedSettings?.mcpServers ?? [];
  if (sourceMcp.servers) {
    const destServers = destMcp.servers || {};
    merged.servers = { ...destServers };
    const sourceTimestamps = options?.sourceTimestamps?.mcpServers ?? {};
    const destTimestamps = options?.installedSettings?.mcpServerTimestamps ?? {};
    for (const [serverName, serverConfig] of Object.entries(sourceMcp.servers)) {
      if (serverName in destServers) {
        const sourceTs = sourceTimestamps[serverName];
        const destTs = destTimestamps[serverName];
        if (sourceTs && destTs) {
          const sourceTime = new Date(sourceTs).getTime();
          const destTime = new Date(destTs).getTime();
          if (sourceTime > destTime) {
            merged.servers[serverName] = serverConfig;
            result.mcpServersOverwritten = (result.mcpServersOverwritten ?? 0) + 1;
            result.mcpConflicts = result.mcpConflicts ?? [];
            result.mcpConflicts.push({
              serverName,
              incomingKit: options?.sourceKit ?? "unknown",
              existingKit: "existing",
              winner: options?.sourceKit ?? "incoming",
              reason: "newer"
            });
            logger.debug(`Overwrote MCP server (newer): ${serverName}`);
            continue;
          }
          if (sourceTime < destTime) {
            result.mcpServersPreserved++;
            result.mcpConflicts = result.mcpConflicts ?? [];
            result.mcpConflicts.push({
              serverName,
              incomingKit: options?.sourceKit ?? "unknown",
              existingKit: "existing",
              winner: "existing",
              reason: "existing-newer"
            });
            logger.debug(`Preserved MCP server (existing newer): ${serverName}`);
            continue;
          }
          result.mcpServersPreserved++;
          result.mcpConflicts = result.mcpConflicts ?? [];
          result.mcpConflicts.push({
            serverName,
            incomingKit: options?.sourceKit ?? "unknown",
            existingKit: "existing",
            winner: "existing",
            reason: "tie"
          });
          logger.debug(`Preserved MCP server (tie): ${serverName}`);
          continue;
        }
        const userModified = JSON.stringify(serverConfig) !== JSON.stringify(destServers[serverName]);
        if (userModified) {
          result.mcpServersPreserved++;
          logger.debug(`Preserved user-modified MCP server: ${serverName}`);
        }
      } else {
        const wasInstalled = installedServers.includes(serverName);
        if (wasInstalled) {
          result.mcpServersSkipped++;
          logger.verbose(`Skipping MCP server (user removed): ${serverName}`);
        } else {
          merged.servers[serverName] = serverConfig;
          result.newlyInstalledServers.push(serverName);
          logger.debug(`Added ClaudeKit MCP server: ${serverName}`);
        }
      }
    }
  }
  if (installedServers.length > 0 && merged.servers) {
    const sourceServerNames = new Set(Object.keys(sourceMcp.servers || {}));
    const deprecatedServers = installedServers.filter((server) => !sourceServerNames.has(server));
    if (deprecatedServers.length > 0) {
      result.removedMcpServers = result.removedMcpServers ?? [];
      for (const serverName of deprecatedServers) {
        if (serverName in merged.servers) {
          delete merged.servers[serverName];
          result.mcpServersRemoved++;
          result.removedMcpServers.push(serverName);
          logger.info(`Removed deprecated MCP server: ${serverName}`);
        }
      }
      if (merged.servers && Object.keys(merged.servers).length === 0) {
        merged.servers = undefined;
      }
    }
  }
  for (const key of Object.keys(sourceMcp)) {
    if (key !== "servers" && !(key in merged)) {
      merged[key] = sourceMcp[key];
    }
  }
  return merged;
}
function mergeSettings(source, destination, options) {
  const result = {
    merged: { ...destination },
    hooksAdded: 0,
    hooksPreserved: 0,
    hooksSkipped: 0,
    hooksRemoved: 0,
    mcpServersPreserved: 0,
    mcpServersSkipped: 0,
    mcpServersRemoved: 0,
    conflictsDetected: [],
    newlyInstalledHooks: [],
    newlyInstalledServers: [],
    hooksByOrigin: new Map
  };
  if (source.hooks) {
    result.merged.hooks = mergeHooks(source.hooks, destination.hooks || {}, result, options);
  }
  if (source.mcp) {
    result.merged.mcp = mergeMcp(source.mcp, destination.mcp || {}, result, options);
  }
  for (const key of Object.keys(source)) {
    if (key !== "hooks" && key !== "mcp" && !(key in destination)) {
      result.merged[key] = structuredClone(source[key]);
    }
  }
  return result;
}
// src/domains/config/merger/file-io.ts
init_logger();
var import_fs_extra8 = __toESM(require_lib(), 1);
import { randomUUID } from "node:crypto";
import { dirname as dirname7, join as join42 } from "node:path";
function stripBOM(content) {
  return content.charCodeAt(0) === 65279 ? content.slice(1) : content;
}
async function readSettingsFile(filePath) {
  try {
    if (!await import_fs_extra8.pathExists(filePath)) {
      return null;
    }
    const rawContent = await import_fs_extra8.readFile(filePath, "utf-8");
    const content = stripBOM(rawContent);
    const parsed = JSON.parse(content);
    if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) {
      logger.warning(`Invalid settings file format (expected object): ${filePath}`);
      return null;
    }
    return parsed;
  } catch (error) {
    logger.warning(`Failed to parse settings file: ${filePath} - ${error}`);
    return null;
  }
}
async function atomicWriteFile(filePath, content) {
  const dir = dirname7(filePath);
  const tempPath = join42(dir, `.settings-${randomUUID()}.tmp`);
  try {
    await import_fs_extra8.writeFile(tempPath, content, "utf-8");
    await import_fs_extra8.rename(tempPath, filePath);
  } catch (error) {
    try {
      if (await import_fs_extra8.pathExists(tempPath)) {
        await import_fs_extra8.unlink(tempPath);
      }
    } catch {}
    throw error;
  }
}
async function writeSettingsFile(filePath, settings) {
  const content = JSON.stringify(settings, null, 2);
  await atomicWriteFile(filePath, content);
}
// src/domains/config/settings-merger.ts
class SettingsMerger {
  static merge(source, destination, options) {
    return mergeSettings(source, destination, options);
  }
  static async readSettingsFile(filePath) {
    return readSettingsFile(filePath);
  }
  static async writeSettingsFile(filePath, settings) {
    return writeSettingsFile(filePath, settings);
  }
  static async atomicWriteFile(filePath, content) {
    return atomicWriteFile(filePath, content);
  }
}

// src/domains/installation/merger/settings-processor.ts
init_environment();
init_logger();
var import_fs_extra9 = __toESM(require_lib(), 1);

class SettingsProcessor {
  isGlobal = false;
  forceOverwriteSettings = false;
  projectDir = "";
  kitName = "engineer";
  tracker = null;
  installingKit;
  setGlobalFlag(isGlobal) {
    this.isGlobal = isGlobal;
  }
  setForceOverwriteSettings(force) {
    this.forceOverwriteSettings = force;
  }
  setProjectDir(dir) {
    this.projectDir = dir;
    this.initTracker();
  }
  setKitName(kit) {
    this.kitName = kit;
    this.initTracker();
  }
  setInstallingKit(kit) {
    this.installingKit = kit;
  }
  initTracker() {
    if (this.projectDir) {
      this.tracker = new InstalledSettingsTracker(this.projectDir, this.isGlobal, this.kitName);
    }
  }
  async processSettingsJson(sourceFile, destFile) {
    try {
      const sourceContent = await import_fs_extra9.readFile(sourceFile, "utf-8");
      let transformedSource = sourceContent;
      if (this.isGlobal) {
        const homeVar = isWindows() ? '"%USERPROFILE%"' : '"$HOME"';
        transformedSource = this.transformClaudePaths(sourceContent, homeVar);
        if (transformedSource !== sourceContent) {
          logger.debug(`Transformed .claude/ paths to ${homeVar}/.claude/ in settings.json for global installation`);
        }
      } else {
        const projectDirVar = isWindows() ? '"%CLAUDE_PROJECT_DIR%"' : '"$CLAUDE_PROJECT_DIR"';
        transformedSource = this.transformClaudePaths(sourceContent, projectDirVar);
        if (transformedSource !== sourceContent) {
          logger.debug(`Transformed .claude/ paths to ${projectDirVar}/.claude/ in settings.json for local installation`);
        }
      }
      const destExists = await import_fs_extra9.pathExists(destFile);
      if (destExists && !this.forceOverwriteSettings) {
        await this.selectiveMergeSettings(transformedSource, destFile);
      } else {
        const formattedContent = this.formatJsonContent(transformedSource);
        await import_fs_extra9.writeFile(destFile, formattedContent, "utf-8");
        try {
          const parsedSettings = JSON.parse(formattedContent);
          if (this.forceOverwriteSettings && destExists) {
            logger.debug("Force overwrite enabled, replaced settings.json completely");
            if (this.tracker) {
              await this.tracker.clearTracking();
            }
          }
          await this.trackInstalledSettings(parsedSettings);
        } catch {}
      }
    } catch (error) {
      logger.error(`Failed to process settings.json: ${error}`);
      await import_fs_extra9.copy(sourceFile, destFile, { overwrite: true });
    }
  }
  async selectiveMergeSettings(transformedSourceContent, destFile) {
    let sourceSettings;
    try {
      sourceSettings = JSON.parse(transformedSourceContent);
    } catch {
      logger.warning("Failed to parse source settings.json, falling back to overwrite");
      const formattedContent = this.formatJsonContent(transformedSourceContent);
      await import_fs_extra9.writeFile(destFile, formattedContent, "utf-8");
      return;
    }
    let destSettings;
    if (this.isGlobal) {
      destSettings = await this.readAndNormalizeGlobalSettings(destFile);
    } else {
      destSettings = await SettingsMerger.readSettingsFile(destFile);
    }
    if (!destSettings) {
      await SettingsMerger.writeSettingsFile(destFile, sourceSettings);
      await this.trackInstalledSettings(sourceSettings);
      return;
    }
    let installedSettings = { hooks: [], mcpServers: [] };
    if (this.tracker) {
      installedSettings = await this.tracker.loadInstalledSettings();
    }
    const mergeResult = SettingsMerger.merge(sourceSettings, destSettings, {
      installedSettings,
      sourceKit: this.installingKit
    });
    logger.verbose("Settings merge details", {
      hooksAdded: mergeResult.hooksAdded,
      hooksPreserved: mergeResult.hooksPreserved,
      hooksSkipped: mergeResult.hooksSkipped,
      mcpServersPreserved: mergeResult.mcpServersPreserved,
      mcpServersSkipped: mergeResult.mcpServersSkipped,
      duplicatesSkipped: mergeResult.conflictsDetected.length
    });
    if (mergeResult.hooksSkipped > 0 || mergeResult.mcpServersSkipped > 0) {
      logger.info(`Preserved user preferences: ${mergeResult.hooksSkipped} hooks, ${mergeResult.mcpServersSkipped} MCP servers skipped`);
    }
    if (mergeResult.conflictsDetected.length > 0) {
      logger.warning(`Duplicate hooks skipped: ${mergeResult.conflictsDetected.length}`);
    }
    if (this.tracker && (mergeResult.newlyInstalledHooks.length > 0 || mergeResult.newlyInstalledServers.length > 0)) {
      for (const hook of mergeResult.newlyInstalledHooks) {
        this.tracker.trackHook(hook, installedSettings);
      }
      for (const server of mergeResult.newlyInstalledServers) {
        this.tracker.trackMcpServer(server, installedSettings);
      }
      await this.tracker.saveInstalledSettings(installedSettings);
    }
    await SettingsMerger.writeSettingsFile(destFile, mergeResult.merged);
    logger.success("Merged settings.json (user customizations preserved)");
  }
  async trackInstalledSettings(settings) {
    if (!this.tracker)
      return;
    const installedSettings = { hooks: [], mcpServers: [] };
    if (settings.hooks) {
      for (const entries of Object.values(settings.hooks)) {
        for (const entry of entries) {
          if ("command" in entry && entry.command) {
            this.tracker.trackHook(entry.command, installedSettings);
          }
          if ("hooks" in entry && entry.hooks) {
            for (const hook of entry.hooks) {
              if (hook.command) {
                this.tracker.trackHook(hook.command, installedSettings);
              }
            }
          }
        }
      }
    }
    if (settings.mcp?.servers) {
      for (const serverName of Object.keys(settings.mcp.servers)) {
        this.tracker.trackMcpServer(serverName, installedSettings);
      }
    }
    await this.tracker.saveInstalledSettings(installedSettings);
    logger.debug("Tracked installed settings for fresh install");
  }
  formatJsonContent(content) {
    try {
      const parsed = JSON.parse(content);
      return JSON.stringify(parsed, null, 2);
    } catch {
      return content;
    }
  }
  async readAndNormalizeGlobalSettings(destFile) {
    try {
      const content = await import_fs_extra9.readFile(destFile, "utf-8");
      if (!content.trim())
        return null;
      const homeVar = isWindows() ? "%USERPROFILE%" : "$HOME";
      let normalized = content;
      normalized = normalized.replace(/"\$CLAUDE_PROJECT_DIR"/g, `"${homeVar}"`);
      normalized = normalized.replace(/\$CLAUDE_PROJECT_DIR/g, homeVar);
      normalized = normalized.replace(/"%CLAUDE_PROJECT_DIR%"/g, `"${homeVar}"`);
      normalized = normalized.replace(/%CLAUDE_PROJECT_DIR%/g, homeVar);
      if (normalized !== content) {
        logger.debug("Normalized $CLAUDE_PROJECT_DIR paths to $HOME in existing global settings");
      }
      return JSON.parse(normalized);
    } catch {
      return null;
    }
  }
  transformClaudePaths(content, prefix) {
    if (/\.claude\/[^\s"']*[;`$&|><]/.test(content)) {
      logger.warning("Potentially unsafe characters detected in .claude/ paths");
      throw new Error("Settings file contains potentially unsafe path characters");
    }
    let transformed = content;
    const jsonSafePrefix = prefix.includes('"') ? prefix.replace(/"/g, "\\\"") : prefix;
    const rawPrefix = prefix.replace(/"/g, "");
    transformed = transformed.replace(/(node\s+)(?:\.\/)?\.claude\//g, `$1${jsonSafePrefix}/.claude/`);
    if (rawPrefix.includes("HOME") || rawPrefix.includes("USERPROFILE")) {
      transformed = transformed.replace(/\$CLAUDE_PROJECT_DIR/g, rawPrefix);
      transformed = transformed.replace(/%CLAUDE_PROJECT_DIR%/g, rawPrefix);
    }
    return transformed;
  }
}

// src/domains/installation/merger/copy-executor.ts
async function withRetry2(fn, retries = 3) {
  for (let i = 0;i < retries; i++) {
    try {
      return await fn();
    } catch (e2) {
      if (!isRetryable2(e2) || i === retries - 1)
        throw e2;
      await delay2(100 * 2 ** i);
    }
  }
  throw new Error("Unreachable");
}
var isRetryable2 = (e2) => {
  const code2 = e2.code ?? "";
  return ["EBUSY", "EPERM", "EACCES"].includes(code2);
};
var delay2 = (ms) => new Promise((r2) => setTimeout(r2, ms));

class CopyExecutor {
  userConfigChecker;
  fileScanner;
  settingsProcessor;
  selectiveMerger = null;
  unchangedSkipped = 0;
  sharedSkipped = 0;
  installedFiles = new Set;
  installedDirectories = new Set;
  fileConflicts = [];
  claudeDir = null;
  installingKit = null;
  constructor(neverCopyPatterns) {
    this.userConfigChecker = import_ignore3.default().add(USER_CONFIG_PATTERNS);
    this.fileScanner = new FileScanner(neverCopyPatterns);
    this.settingsProcessor = new SettingsProcessor;
  }
  setMultiKitContext(claudeDir, installingKit) {
    this.claudeDir = claudeDir;
    this.installingKit = installingKit;
    this.settingsProcessor.setInstallingKit(installingKit);
  }
  setIncludePatterns(patterns) {
    this.fileScanner.setIncludePatterns(patterns);
  }
  setGlobalFlag(isGlobal) {
    this.settingsProcessor.setGlobalFlag(isGlobal);
  }
  setForceOverwriteSettings(force) {
    this.settingsProcessor.setForceOverwriteSettings(force);
  }
  setProjectDir(dir) {
    this.settingsProcessor.setProjectDir(dir);
  }
  setKitName(kit) {
    this.settingsProcessor.setKitName(kit);
  }
  setManifest(manifest) {
    this.selectiveMerger = manifest ? new SelectiveMerger(manifest) : null;
    if (manifest && this.selectiveMerger?.hasManifest()) {
      if (this.claudeDir && this.installingKit) {
        this.selectiveMerger.setMultiKitContext(this.claudeDir, this.installingKit);
      }
      logger.debug(`Selective merge enabled with ${this.selectiveMerger.getManifestFileCount()} tracked files`);
    }
  }
  addIgnorePatterns(patterns) {
    this.fileScanner.addIgnorePatterns(patterns);
  }
  async getFiles(dir, baseDir) {
    return this.fileScanner.getFiles(dir, baseDir);
  }
  async detectConflicts(sourceDir, destDir) {
    const conflicts = [];
    const files = await this.fileScanner.getFiles(sourceDir, sourceDir);
    for (const file of files) {
      const relativePath = relative6(sourceDir, file);
      const normalizedRelativePath = relativePath.replace(/\\/g, "/");
      const destPath = join43(destDir, relativePath);
      if (await import_fs_extra10.pathExists(destPath)) {
        if (this.fileScanner.shouldNeverCopy(normalizedRelativePath)) {
          logger.debug(`Security-sensitive file exists but won't be overwritten: ${normalizedRelativePath}`);
          continue;
        }
        if (this.userConfigChecker.ignores(normalizedRelativePath)) {
          logger.debug(`User config file exists and will be preserved: ${normalizedRelativePath}`);
          continue;
        }
        conflicts.push(normalizedRelativePath);
      }
    }
    return conflicts;
  }
  async copyFiles(sourceDir, destDir) {
    const files = await this.fileScanner.getFiles(sourceDir, sourceDir);
    let copiedCount = 0;
    let skippedCount = 0;
    for (const file of files) {
      const relativePath = relative6(sourceDir, file);
      const normalizedRelativePath = relativePath.replace(/\\/g, "/");
      const destPath = join43(destDir, relativePath);
      if (this.fileScanner.shouldNeverCopy(normalizedRelativePath)) {
        logger.debug(`Skipping security-sensitive file: ${normalizedRelativePath}`);
        skippedCount++;
        continue;
      }
      if (this.userConfigChecker.ignores(normalizedRelativePath)) {
        const fileExists = await import_fs_extra10.pathExists(destPath);
        if (fileExists) {
          logger.debug(`Preserving user config: ${normalizedRelativePath}`);
          skippedCount++;
          continue;
        }
        logger.debug(`Copying user config (first-time): ${normalizedRelativePath}`);
      }
      if (normalizedRelativePath === "settings.json" || normalizedRelativePath === ".claude/settings.json") {
        await this.settingsProcessor.processSettingsJson(file, destPath);
        this.trackInstalledFile(normalizedRelativePath);
        copiedCount++;
        continue;
      }
      if (this.selectiveMerger?.hasManifest()) {
        const compareResult = await this.selectiveMerger.shouldCopyFile(destPath, normalizedRelativePath);
        if (compareResult.conflictInfo) {
          this.fileConflicts.push(compareResult.conflictInfo);
        }
        if (!compareResult.changed) {
          if (compareResult.reason === "shared-identical" || compareResult.reason === "shared-older") {
            logger.debug(`Preserving shared file: ${normalizedRelativePath} (${compareResult.reason})`);
            this.sharedSkipped++;
          } else {
            logger.debug(`Skipping unchanged: ${normalizedRelativePath}`);
            this.unchangedSkipped++;
          }
          this.trackInstalledFile(normalizedRelativePath);
          continue;
        }
      }
      await withRetry2(() => import_fs_extra10.copy(file, destPath, { overwrite: true }));
      this.trackInstalledFile(normalizedRelativePath);
      copiedCount++;
    }
    const parts = [];
    if (copiedCount > 0)
      parts.push(`Updated ${copiedCount} file(s)`);
    if (this.unchangedSkipped > 0)
      parts.push(`skipped ${this.unchangedSkipped} unchanged`);
    if (this.sharedSkipped > 0)
      parts.push(`preserved ${this.sharedSkipped} shared`);
    if (skippedCount > 0)
      parts.push(`skipped ${skippedCount} protected`);
    if (parts.length > 0) {
      logger.success(parts.join(", "));
    } else {
      logger.success(`Copied ${copiedCount} file(s), skipped ${skippedCount} protected file(s)`);
    }
  }
  getInstalledItems() {
    const topLevelItems = new Set;
    for (const file of this.installedFiles) {
      const parts = file.split("/");
      if (parts.length > 1) {
        topLevelItems.add(`${parts[0]}/`);
      } else {
        topLevelItems.add(file);
      }
    }
    return Array.from(topLevelItems).sort();
  }
  getAllInstalledFiles() {
    return Array.from(this.installedFiles).sort();
  }
  getFileConflicts() {
    return this.fileConflicts;
  }
  trackInstalledFile(relativePath) {
    this.installedFiles.add(relativePath);
    let dir = dirname8(relativePath);
    while (dir && dir !== "." && dir !== "/") {
      this.installedDirectories.add(`${dir}/`);
      dir = dirname8(dir);
    }
  }
}

// src/domains/installation/file-merger.ts
function detectCaseCollisions(paths) {
  const normalized = new Map;
  for (const p of paths) {
    const lower = p.toLowerCase();
    const existing = normalized.get(lower) || [];
    existing.push(p);
    normalized.set(lower, existing);
  }
  const collisions = new Map;
  for (const [key, values] of normalized) {
    if (values.length > 1) {
      collisions.set(key, values);
    }
  }
  return collisions;
}

class FileMerger {
  copyExecutor;
  constructor() {
    this.copyExecutor = new CopyExecutor(NEVER_COPY_PATTERNS);
  }
  setIncludePatterns(patterns) {
    this.copyExecutor.setIncludePatterns(patterns);
  }
  setGlobalFlag(isGlobal) {
    this.copyExecutor.setGlobalFlag(isGlobal);
  }
  setForceOverwriteSettings(force) {
    this.copyExecutor.setForceOverwriteSettings(force);
  }
  setProjectDir(dir) {
    this.copyExecutor.setProjectDir(dir);
  }
  setKitName(kit) {
    this.copyExecutor.setKitName(kit);
  }
  setManifest(manifest) {
    this.copyExecutor.setManifest(manifest);
  }
  setMultiKitContext(claudeDir, installingKit) {
    this.copyExecutor.setMultiKitContext(claudeDir, installingKit);
  }
  async merge(sourceDir, destDir, skipConfirmation = false) {
    const conflicts = await this.copyExecutor.detectConflicts(sourceDir, destDir);
    const allFiles = await this.copyExecutor.getFiles(sourceDir, sourceDir);
    const caseCollisions = detectCaseCollisions(allFiles);
    if (caseCollisions.size > 0) {
      logger.warning(`Case collision detected (may cause issues on Windows/macOS): ${caseCollisions.size} collision(s)`);
      for (const [, paths] of caseCollisions) {
        logger.warning(`  - ${paths.join(", ")}`);
      }
    }
    if (conflicts.length > 0 && !skipConfirmation) {
      logger.warning(`Found ${conflicts.length} file(s) that will be overwritten:`);
      conflicts.slice(0, 10).forEach((file) => logger.info(`  - ${file}`));
      if (conflicts.length > 10) {
        logger.info(`  ... and ${conflicts.length - 10} more`);
      }
      const confirm = await se({
        message: "Do you want to continue?"
      });
      if (lD(confirm) || !confirm) {
        throw new Error("Merge cancelled by user");
      }
    }
    await this.copyExecutor.copyFiles(sourceDir, destDir);
  }
  addIgnorePatterns(patterns) {
    this.copyExecutor.addIgnorePatterns(patterns);
  }
  getInstalledItems() {
    return this.copyExecutor.getInstalledItems();
  }
  getAllInstalledFiles() {
    return this.copyExecutor.getAllInstalledFiles();
  }
  getFileConflicts() {
    return this.copyExecutor.getFileConflicts();
  }
}

// src/domains/migration/legacy-migration.ts
import { readdir as readdir9, stat as stat7 } from "node:fs/promises";
import { join as join47, relative as relative7 } from "node:path";
// src/services/file-operations/manifest/manifest-tracker.ts
import { join as join46 } from "node:path";

// src/domains/migration/release-manifest.ts
init_logger();
var import_fs_extra11 = __toESM(require_lib(), 1);
init_zod();
import { join as join44 } from "node:path";
var ReleaseManifestFileSchema = exports_external.object({
  path: exports_external.string(),
  checksum: exports_external.string().regex(/^[a-f0-9]{64}$/),
  size: exports_external.number(),
  lastModified: exports_external.string().datetime({ offset: true }).optional()
});
var ReleaseManifestSchema = exports_external.object({
  version: exports_external.string(),
  generatedAt: exports_external.string(),
  files: exports_external.array(ReleaseManifestFileSchema)
});

class ReleaseManifestLoader {
  static async load(extractDir) {
    const manifestPath = join44(extractDir, "release-manifest.json");
    try {
      const content = await import_fs_extra11.readFile(manifestPath, "utf-8");
      const parsed = JSON.parse(content);
      return ReleaseManifestSchema.parse(parsed);
    } catch (error) {
      logger.debug(`Release manifest not found or invalid: ${error}`);
      return null;
    }
  }
  static findFile(manifest, relativePath) {
    return manifest.files.find((f3) => f3.path === relativePath);
  }
}

// src/services/file-operations/manifest/manifest-tracker.ts
init_environment();
init_logger();

// src/services/file-operations/manifest/manifest-updater.ts
import { join as join45 } from "node:path";
init_logger();
init_types2();
var import_fs_extra12 = __toESM(require_lib(), 1);
var import_proper_lockfile2 = __toESM(require_proper_lockfile(), 1);
async function writeManifest(claudeDir, kitName, version, scope, kitType, trackedFiles, userConfigFiles) {
  const metadataPath = join45(claudeDir, "metadata.json");
  const kit = kitType || (/\bmarketing\b/i.test(kitName) ? "marketing" : "engineer");
  await import_fs_extra12.ensureFile(metadataPath);
  let release = null;
  try {
    release = await import_proper_lockfile2.lock(metadataPath, {
      retries: { retries: 5, minTimeout: 100, maxTimeout: 1000 },
      stale: 60000
    });
    logger.debug(`Acquired lock on ${metadataPath}`);
    const migrationResult = await migrateToMultiKit(claudeDir);
    if (!migrationResult.success) {
      logger.warning(`Metadata migration warning: ${migrationResult.error}`);
    }
    let existingMetadata = { kits: {} };
    if (await import_fs_extra12.pathExists(metadataPath)) {
      try {
        const content = await import_fs_extra12.readFile(metadataPath, "utf-8");
        const parsed = JSON.parse(content);
        if (parsed && typeof parsed === "object" && Object.keys(parsed).length > 0) {
          existingMetadata = parsed;
        }
      } catch (error) {
        logger.debug(`Could not read existing metadata: ${error}`);
      }
    }
    const installedAt = new Date().toISOString();
    const kitMetadata = {
      version,
      installedAt,
      files: trackedFiles.length > 0 ? trackedFiles : undefined
    };
    const existingKits = existingMetadata.kits || {};
    const otherKitsExist = Object.keys(existingKits).some((k2) => k2 !== kit);
    const metadata = {
      kits: {
        ...existingKits,
        [kit]: kitMetadata
      },
      scope,
      name: otherKitsExist ? existingMetadata.name ?? kitName : kitName,
      version: otherKitsExist ? existingMetadata.version ?? version : version,
      installedAt: otherKitsExist ? existingMetadata.installedAt ?? installedAt : installedAt,
      userConfigFiles: [...USER_CONFIG_PATTERNS, ...userConfigFiles]
    };
    const validated = MetadataSchema.parse(metadata);
    await import_fs_extra12.writeFile(metadataPath, JSON.stringify(validated, null, 2), "utf-8");
    logger.debug(`Wrote manifest for kit "${kit}" with ${trackedFiles.length} tracked files`);
  } finally {
    if (release) {
      await release();
      logger.debug(`Released lock on ${metadataPath}`);
    }
  }
}
async function removeKitFromManifest(claudeDir, kit) {
  const metadataPath = join45(claudeDir, "metadata.json");
  if (!await import_fs_extra12.pathExists(metadataPath))
    return false;
  let release = null;
  try {
    release = await import_proper_lockfile2.lock(metadataPath, {
      retries: { retries: 5, minTimeout: 100, maxTimeout: 1000 },
      stale: 60000
    });
    logger.debug(`Acquired lock on ${metadataPath} for kit removal`);
    const metadata = await readManifest(claudeDir);
    if (!metadata?.kits?.[kit])
      return false;
    const { [kit]: _removed, ...remainingKits } = metadata.kits;
    if (Object.keys(remainingKits).length === 0) {
      logger.debug("No kits remaining, metadata.json will be cleaned up");
      return true;
    }
    const updated = {
      ...metadata,
      kits: remainingKits
    };
    await import_fs_extra12.writeFile(metadataPath, JSON.stringify(updated, null, 2), "utf-8");
    logger.debug(`Removed kit "${kit}" from metadata, ${Object.keys(remainingKits).length} kit(s) remaining`);
    return true;
  } finally {
    if (release) {
      await release();
      logger.debug(`Released lock on ${metadataPath}`);
    }
  }
}

// src/services/file-operations/manifest/manifest-tracker.ts
class ManifestTracker {
  installedFiles = new Set;
  userConfigFiles = new Set;
  trackedFiles = new Map;
  addInstalledFile(relativePath) {
    const normalized = relativePath.replace(/\\/g, "/");
    this.installedFiles.add(normalized);
  }
  addInstalledFiles(relativePaths) {
    for (const path11 of relativePaths) {
      this.addInstalledFile(path11);
    }
  }
  addUserConfigFile(relativePath) {
    const normalized = relativePath.replace(/\\/g, "/");
    this.userConfigFiles.add(normalized);
  }
  getInstalledFiles() {
    return Array.from(this.installedFiles).sort();
  }
  getUserConfigFiles() {
    return Array.from(this.userConfigFiles).sort();
  }
  async addTrackedFile(filePath, relativePath, ownership, installedVersion, sourceTimestamp) {
    const checksum = await OwnershipChecker.calculateChecksum(filePath);
    const normalized = relativePath.replace(/\\/g, "/");
    this.trackedFiles.set(normalized, {
      path: normalized,
      checksum,
      ownership,
      installedVersion,
      sourceTimestamp,
      installedAt: new Date().toISOString()
    });
    this.installedFiles.add(normalized);
  }
  async addTrackedFilesBatch(files, options = {}) {
    const { concurrency = 20, onProgress } = options;
    const limit = pLimit(concurrency);
    const total = files.length;
    const tasks = files.map((file) => limit(async () => {
      try {
        const checksum = await OwnershipChecker.calculateChecksum(file.filePath);
        const normalized = file.relativePath.replace(/\\/g, "/");
        this.trackedFiles.set(normalized, {
          path: normalized,
          checksum,
          ownership: file.ownership,
          installedVersion: file.installedVersion,
          sourceTimestamp: file.sourceTimestamp,
          installedAt: new Date().toISOString()
        });
        this.installedFiles.add(normalized);
        return true;
      } catch (error) {
        logger.debug(`Failed to track file ${file.relativePath}: ${error}`);
        return false;
      }
    }));
    const progressInterval = Math.max(1, Math.floor(total / 20));
    let reportedProgress = 0;
    const results = await Promise.all(tasks.map(async (task, index) => {
      const result = await task;
      const completed = index + 1;
      if (completed % progressInterval === 0 || completed === total) {
        if (completed > reportedProgress) {
          reportedProgress = completed;
          onProgress?.(completed, total);
        }
      }
      return result;
    }));
    const success = results.filter(Boolean).length;
    const failed = total - success;
    if (failed > 0) {
      logger.warning(`Failed to track ${failed} of ${total} files (check debug logs for details)`);
    }
    return { success, failed, total };
  }
  getTrackedFiles() {
    return Array.from(this.trackedFiles.values()).sort((a3, b3) => a3.path.localeCompare(b3.path));
  }
}
function buildFileTrackingList(options) {
  const {
    installedFiles,
    claudeDir,
    releaseManifest,
    installedVersion,
    isGlobal = false
  } = options;
  const filesToTrack = [];
  for (const installedPath of installedFiles) {
    if (!isGlobal && !installedPath.startsWith(".claude/"))
      continue;
    const relativePath = isGlobal ? installedPath : installedPath.replace(/^\.claude\//, "");
    const filePath = join46(claudeDir, relativePath);
    const manifestEntry = releaseManifest ? ReleaseManifestLoader.findFile(releaseManifest, installedPath) : null;
    const ownership = manifestEntry ? "ck" : "user";
    filesToTrack.push({
      filePath,
      relativePath,
      ownership,
      installedVersion,
      sourceTimestamp: manifestEntry?.lastModified
    });
  }
  return filesToTrack;
}
async function trackFilesWithProgress(filesToTrack, manifestOptions) {
  const tracker = new ManifestTracker;
  const trackingSpinner = createSpinner(`Tracking ${filesToTrack.length} installed files...`);
  trackingSpinner.start();
  const trackResult = await tracker.addTrackedFilesBatch(filesToTrack, {
    concurrency: getOptimalConcurrency(),
    onProgress: (processed, total) => {
      trackingSpinner.text = `Tracking files... (${processed}/${total})`;
    }
  });
  trackingSpinner.succeed(`Tracked ${trackResult.success} files`);
  await writeManifest(manifestOptions.claudeDir, manifestOptions.kitName, manifestOptions.releaseTag, manifestOptions.mode, manifestOptions.kitType, tracker.getTrackedFiles(), tracker.getUserConfigFiles());
  return trackResult;
}
// src/services/file-operations/manifest-writer.ts
class ManifestWriter {
  tracker = new ManifestTracker;
  addInstalledFile(relativePath) {
    this.tracker.addInstalledFile(relativePath);
  }
  addInstalledFiles(relativePaths) {
    this.tracker.addInstalledFiles(relativePaths);
  }
  addUserConfigFile(relativePath) {
    this.tracker.addUserConfigFile(relativePath);
  }
  getInstalledFiles() {
    return this.tracker.getInstalledFiles();
  }
  getUserConfigFiles() {
    return this.tracker.getUserConfigFiles();
  }
  async addTrackedFile(filePath, relativePath, ownership, installedVersion) {
    return this.tracker.addTrackedFile(filePath, relativePath, ownership, installedVersion);
  }
  async addTrackedFilesBatch(files, options = {}) {
    return this.tracker.addTrackedFilesBatch(files, options);
  }
  getTrackedFiles() {
    return this.tracker.getTrackedFiles();
  }
  async writeManifest(claudeDir, kitName, version, scope, kitType) {
    return writeManifest(claudeDir, kitName, version, scope, kitType, this.getTrackedFiles(), this.getUserConfigFiles());
  }
  static async readManifest(claudeDir) {
    return readManifest(claudeDir);
  }
  static async readKitManifest(claudeDir, kit) {
    return readKitManifest(claudeDir, kit);
  }
  static async getUninstallManifest(claudeDir, kit) {
    return getUninstallManifest(claudeDir, kit);
  }
  static async removeKitFromManifest(claudeDir, kit) {
    return removeKitFromManifest(claudeDir, kit);
  }
}

// src/domains/migration/legacy-migration.ts
init_logger();
var import_fs_extra13 = __toESM(require_lib(), 1);
class LegacyMigration {
  static async detectLegacy(claudeDir) {
    const metadata = await ManifestWriter.readManifest(claudeDir);
    if (!metadata) {
      return { isLegacy: true, reason: "no-metadata", confidence: "high" };
    }
    if (!metadata.files || metadata.files.length === 0) {
      return { isLegacy: true, reason: "old-format", confidence: "high" };
    }
    return { isLegacy: false, reason: "current", confidence: "high" };
  }
  static async scanFiles(dir) {
    const files = [];
    let entries;
    try {
      entries = await readdir9(dir);
    } catch (err) {
      const error = err;
      if (error.code === "ENOENT") {
        logger.debug(`Directory does not exist: ${dir}`);
      } else if (error.code === "EACCES") {
        logger.debug(`Permission denied reading directory: ${dir}`);
      } else {
        logger.debug(`Failed to read directory "${dir}": ${error.message}`);
      }
      return files;
    }
    for (const entry of entries) {
      if (entry === "metadata.json")
        continue;
      if (SKIP_DIRS_ALL.includes(entry))
        continue;
      const fullPath = join47(dir, entry);
      let stats;
      try {
        stats = await stat7(fullPath);
      } catch (err) {
        const error = err;
        if (error.code === "ENOENT") {
          logger.debug(`File removed during scan: ${fullPath}`);
        } else if (error.code === "EACCES") {
          logger.debug(`Permission denied accessing: ${fullPath}`);
        } else {
          logger.debug(`Failed to stat "${fullPath}": ${error.message}`);
        }
        continue;
      }
      if (stats.isDirectory()) {
        files.push(...await LegacyMigration.scanFiles(fullPath));
      } else if (stats.isFile()) {
        files.push(fullPath);
      }
    }
    return files;
  }
  static async classifyFiles(claudeDir, manifest) {
    const files = await LegacyMigration.scanFiles(claudeDir);
    const preview = {
      ckPristine: [],
      ckModified: [],
      userCreated: [],
      totalFiles: files.length
    };
    const filesInManifest = [];
    for (const file of files) {
      const relativePath = relative7(claudeDir, file).replace(/\\/g, "/");
      const manifestEntry = ReleaseManifestLoader.findFile(manifest, relativePath);
      if (!manifestEntry) {
        preview.userCreated.push(relativePath);
      } else {
        filesInManifest.push({
          file,
          relativePath,
          manifestChecksum: manifestEntry.checksum
        });
      }
    }
    if (filesInManifest.length > 0) {
      const checksumResults = await mapWithLimit(filesInManifest, async ({ file, relativePath, manifestChecksum }) => {
        const actualChecksum = await OwnershipChecker.calculateChecksum(file);
        return { relativePath, actualChecksum, manifestChecksum };
      });
      for (const { relativePath, actualChecksum, manifestChecksum } of checksumResults) {
        if (actualChecksum === manifestChecksum) {
          preview.ckPristine.push(relativePath);
        } else {
          preview.ckModified.push(relativePath);
        }
      }
    }
    return preview;
  }
  static async migrate(claudeDir, manifest, kitName, kitVersion, _interactive = true) {
    logger.info("Migrating legacy installation to ownership tracking...");
    const preview = await LegacyMigration.classifyFiles(claudeDir, manifest);
    logger.info("Migration preview:");
    logger.info(`  CK files (pristine): ${preview.ckPristine.length}`);
    logger.info(`  CK files (modified): ${preview.ckModified.length}`);
    logger.info(`  User files: ${preview.userCreated.length}`);
    logger.info(`  Total: ${preview.totalFiles}`);
    if (preview.ckModified.length > 0) {
      logger.info(`
Modified CK files (sample):`);
      preview.ckModified.slice(0, 3).forEach((f3) => logger.info(`  - ${f3}`));
      if (preview.ckModified.length > 3) {
        logger.info(`  ... and ${preview.ckModified.length - 3} more`);
      }
    }
    if (preview.userCreated.length > 0) {
      logger.info(`
User-created files (sample):`);
      preview.userCreated.slice(0, 3).forEach((f3) => logger.info(`  - ${f3}`));
      if (preview.userCreated.length > 3) {
        logger.info(`  ... and ${preview.userCreated.length - 3} more`);
      }
    }
    const trackedFiles = [];
    for (const relativePath of preview.ckPristine) {
      const manifestEntry = ReleaseManifestLoader.findFile(manifest, relativePath);
      if (manifestEntry) {
        trackedFiles.push({
          path: relativePath,
          checksum: manifestEntry.checksum,
          ownership: "ck",
          installedVersion: kitVersion
        });
      }
    }
    const filesToChecksum = [
      ...preview.ckModified.map((p) => ({ relativePath: p, ownership: "ck-modified" })),
      ...preview.userCreated.map((p) => ({ relativePath: p, ownership: "user" }))
    ];
    if (filesToChecksum.length > 0) {
      const checksumResults = await mapWithLimit(filesToChecksum, async ({ relativePath, ownership }) => {
        const fullPath = join47(claudeDir, relativePath);
        const checksum = await OwnershipChecker.calculateChecksum(fullPath);
        return { relativePath, checksum, ownership };
      });
      for (const { relativePath, checksum, ownership } of checksumResults) {
        trackedFiles.push({
          path: relativePath,
          checksum,
          ownership,
          installedVersion: kitVersion
        });
      }
    }
    const existingMetadata = await ManifestWriter.readManifest(claudeDir);
    const updatedMetadata = {
      ...existingMetadata,
      name: kitName,
      version: kitVersion,
      installedAt: new Date().toISOString(),
      files: trackedFiles
    };
    const metadataPath = join47(claudeDir, "metadata.json");
    await import_fs_extra13.writeFile(metadataPath, JSON.stringify(updatedMetadata, null, 2));
    logger.success(`Migration complete: tracked ${trackedFiles.length} files`);
    return true;
  }
}

// src/domains/ui/conflict-summary.ts
init_logger();
var import_picocolors17 = __toESM(require_picocolors(), 1);
function displayConflictSummary(summary) {
  const totalUpdated = summary.files.updated.length + summary.hooks.updated.length + summary.mcp.updated.length;
  const totalKept = summary.files.kept.length + summary.hooks.kept.length + summary.mcp.kept.length;
  if (totalUpdated === 0 && totalKept === 0) {
    logger.verbose("No conflicts detected during installation");
    return;
  }
  console.log();
  console.log(import_picocolors17.default.bold("Dual-Kit Conflict Resolution"));
  console.log(import_picocolors17.default.dim("".repeat(40)));
  if (summary.files.updated.length > 0 || summary.files.kept.length > 0) {
    const updated = summary.files.updated.length;
    const kept = summary.files.kept.length;
    const winners = formatWinners(summary.files.updated);
    console.log(`  Files:   ${import_picocolors17.default.green(`${updated} updated`)}${winners}, ${import_picocolors17.default.dim(`${kept} kept`)}`);
  }
  if (summary.hooks.updated.length > 0 || summary.hooks.kept.length > 0) {
    const updated = summary.hooks.updated.length;
    const kept = summary.hooks.kept.length;
    const winners = formatHookWinners(summary.hooks.updated);
    console.log(`  Hooks:   ${import_picocolors17.default.green(`${updated} updated`)}${winners}, ${import_picocolors17.default.dim(`${kept} kept`)}`);
  }
  if (summary.mcp.updated.length > 0 || summary.mcp.kept.length > 0) {
    const updated = summary.mcp.updated.length;
    const kept = summary.mcp.kept.length;
    const winners = formatMcpWinners(summary.mcp.updated);
    console.log(`  MCP:     ${import_picocolors17.default.green(`${updated} updated`)}${winners}, ${import_picocolors17.default.dim(`${kept} kept`)}`);
  }
  if (logger.isVerbose() && totalUpdated > 0) {
    console.log();
    console.log(import_picocolors17.default.dim("Details:"));
    for (const file of summary.files.updated) {
      console.log(`  ${import_picocolors17.default.dim("-")} ${file.relativePath}: ${import_picocolors17.default.green(file.winner)} won`);
    }
    for (const hook of summary.hooks.updated) {
      const shortCmd = hook.command.length > 40 ? `${hook.command.slice(0, 40)}...` : hook.command;
      console.log(`  ${import_picocolors17.default.dim("-")} hook: ${shortCmd}  ${import_picocolors17.default.green(hook.winner)}`);
    }
    for (const mcp of summary.mcp.updated) {
      console.log(`  ${import_picocolors17.default.dim("-")} mcp: ${mcp.serverName}  ${import_picocolors17.default.green(mcp.winner)}`);
    }
  }
  console.log();
}
function formatWinners(items) {
  const counts = new Map;
  for (const item of items) {
    const kit = item.winner === "incoming" ? item.incomingKit : item.existingKit;
    counts.set(kit, (counts.get(kit) ?? 0) + 1);
  }
  if (counts.size === 0)
    return "";
  const parts = Array.from(counts.entries()).map(([kit, count]) => `${kit}: ${count}`);
  return import_picocolors17.default.dim(` (${parts.join(", ")})`);
}
function formatHookWinners(items) {
  const counts = new Map;
  for (const item of items) {
    counts.set(item.winner, (counts.get(item.winner) ?? 0) + 1);
  }
  if (counts.size === 0)
    return "";
  const parts = Array.from(counts.entries()).map(([kit, count]) => `${kit}: ${count}`);
  return import_picocolors17.default.dim(` (${parts.join(", ")})`);
}
function formatMcpWinners(items) {
  const counts = new Map;
  for (const item of items) {
    counts.set(item.winner, (counts.get(item.winner) ?? 0) + 1);
  }
  if (counts.size === 0)
    return "";
  const parts = Array.from(counts.entries()).map(([kit, count]) => `${kit}: ${count}`);
  return import_picocolors17.default.dim(` (${parts.join(", ")})`);
}
function buildConflictSummary(fileConflicts, hookConflicts, mcpConflicts) {
  return {
    files: {
      updated: fileConflicts.filter((c2) => c2.winner === "incoming"),
      kept: fileConflicts.filter((c2) => c2.winner === "existing")
    },
    hooks: {
      updated: hookConflicts.filter((c2) => c2.winner !== "existing"),
      kept: hookConflicts.filter((c2) => c2.winner === "existing")
    },
    mcp: {
      updated: mcpConflicts.filter((c2) => c2.winner !== "existing"),
      kept: mcpConflicts.filter((c2) => c2.winner === "existing")
    }
  };
}

// src/services/file-operations/file-scanner.ts
import { join as join48, relative as relative8, resolve as resolve6 } from "node:path";
init_logger();
var import_fs_extra14 = __toESM(require_lib(), 1);

class FileScanner2 {
  static async getFiles(dirPath, relativeTo) {
    const basePath = relativeTo || dirPath;
    const files = [];
    if (!await import_fs_extra14.pathExists(dirPath)) {
      return files;
    }
    try {
      const entries = await import_fs_extra14.readdir(dirPath, { encoding: "utf8" });
      for (const entry of entries) {
        if (SKIP_DIRS_ALL.includes(entry)) {
          logger.debug(`Skipping directory: ${entry}`);
          continue;
        }
        const fullPath = join48(dirPath, entry);
        if (!FileScanner2.isSafePath(basePath, fullPath)) {
          logger.warning(`Skipping potentially unsafe path: ${entry}`);
          continue;
        }
        let stats;
        try {
          stats = await import_fs_extra14.lstat(fullPath);
        } catch (error) {
          if (error instanceof Error && "code" in error && (error.code === "EACCES" || error.code === "EPERM")) {
            logger.warning(`Skipping inaccessible path: ${entry}`);
            continue;
          }
          throw error;
        }
        if (stats.isSymbolicLink()) {
          logger.debug(`Skipping symlink: ${entry}`);
          continue;
        }
        if (stats.isDirectory()) {
          const subFiles = await FileScanner2.getFiles(fullPath, basePath);
          files.push(...subFiles);
        } else if (stats.isFile()) {
          const relativePath = relative8(basePath, fullPath);
          files.push(FileScanner2.toPosixPath(relativePath));
        }
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? operationError("Directory scan", dirPath, error.message) : operationError("Directory scan", dirPath, "unknown error");
      logger.error(errorMessage);
      throw error;
    }
    return files;
  }
  static async findCustomFiles(destDir, sourceDir, subPath) {
    const destSubDir = join48(destDir, subPath);
    const sourceSubDir = join48(sourceDir, subPath);
    logger.debug(`findCustomFiles - destDir: ${destDir}`);
    logger.debug(`findCustomFiles - sourceDir: ${sourceDir}`);
    logger.debug(`findCustomFiles - subPath: "${subPath}"`);
    logger.debug(`findCustomFiles - destSubDir: ${destSubDir}`);
    logger.debug(`findCustomFiles - sourceSubDir: ${sourceSubDir}`);
    const destFiles = await FileScanner2.getFiles(destSubDir, destDir);
    const sourceFiles = await FileScanner2.getFiles(sourceSubDir, sourceDir);
    logger.debug(`findCustomFiles - destFiles count: ${destFiles.length}`);
    logger.debug(`findCustomFiles - sourceFiles count: ${sourceFiles.length}`);
    const sourceExists = await import_fs_extra14.pathExists(sourceSubDir);
    if (sourceExists && sourceFiles.length === 0 && destFiles.length > 100) {
      logger.warning(`Source directory exists but is empty while destination has ${destFiles.length} files. This may indicate an extraction issue. Skipping custom file detection.`);
      return [];
    }
    const sourceFileSet = new Set(sourceFiles);
    const customFiles = destFiles.filter((file) => !sourceFileSet.has(file));
    if (customFiles.length > 0) {
      const displayPath = subPath || destSubDir;
      logger.info(`Found ${customFiles.length} custom file(s) in ${displayPath}`);
      customFiles.slice(0, 5).forEach((file) => logger.debug(`  - ${file}`));
      if (customFiles.length > 5) {
        logger.debug(`  ... and ${customFiles.length - 5} more`);
      }
    }
    return customFiles;
  }
  static isSafePath(basePath, targetPath) {
    const resolvedBase = resolve6(basePath);
    const resolvedTarget = resolve6(targetPath);
    return resolvedTarget.startsWith(resolvedBase);
  }
  static toPosixPath(path11) {
    return path11.replace(/\\/g, "/");
  }
}

// src/services/transformers/commands-prefix/prefix-applier.ts
init_logger();
var import_fs_extra15 = __toESM(require_lib(), 1);
import { lstat as lstat5, mkdir as mkdir16, readdir as readdir12, stat as stat8 } from "node:fs/promises";
import { join as join50 } from "node:path";

// src/services/transformers/commands-prefix/content-transformer.ts
init_logger();
import { readFile as readFile18, readdir as readdir11, writeFile as writeFile15 } from "node:fs/promises";
import { join as join49 } from "node:path";
var TRANSFORMABLE_EXTENSIONS = new Set([
  ".md",
  ".txt",
  ".json",
  ".yaml",
  ".yml",
  ".ts",
  ".js",
  ".mjs",
  ".cjs",
  ".py"
]);
var COMMAND_ROOTS = [
  "plan",
  "fix",
  "code",
  "review",
  "cook",
  "brainstorm",
  "integrate",
  "bootstrap",
  "worktree",
  "scout",
  "test",
  "debug",
  "preview",
  "kanban",
  "journal",
  "watzup"
];
function buildCommandPatterns() {
  const patterns = [];
  for (const cmd of COMMAND_ROOTS) {
    patterns.push({
      regex: new RegExp(`(?:^|(?<=[\\s\`]))(/)(${cmd})(:)(?!/)`, "gm"),
      replacement: "$1ck:$2$3"
    });
    patterns.push({
      regex: new RegExp(`(?:^|(?<=[\\s\`]))(/)(${cmd})(?![?/=&:\\w])(?=[\\s\`\\]\\)]|$)`, "gm"),
      replacement: "$1ck:$2"
    });
  }
  return patterns;
}
function transformCommandContent(content) {
  let changes = 0;
  let transformed = content;
  const patterns = buildCommandPatterns();
  for (const { regex: regex2, replacement } of patterns) {
    const matches = transformed.match(regex2);
    if (matches) {
      changes += matches.length;
      transformed = transformed.replace(regex2, replacement);
    }
  }
  return { transformed, changes };
}
function shouldTransformFile(filename) {
  const ext2 = filename.toLowerCase().slice(filename.lastIndexOf("."));
  return TRANSFORMABLE_EXTENSIONS.has(ext2);
}
async function transformCommandReferences(directory, options = {}) {
  let filesTransformed = 0;
  let totalReplacements = 0;
  async function processDirectory(dir) {
    const entries = await readdir11(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = join49(dir, entry.name);
      if (entry.isDirectory()) {
        if (entry.name === "node_modules" || entry.name.startsWith(".") && entry.name !== ".claude") {
          continue;
        }
        await processDirectory(fullPath);
      } else if (entry.isFile() && shouldTransformFile(entry.name)) {
        try {
          const content = await readFile18(fullPath, "utf-8");
          const { transformed, changes } = transformCommandContent(content);
          if (changes > 0) {
            if (options.dryRun) {
              logger.debug(`[dry-run] Would transform ${changes} command ref(s) in ${fullPath}`);
            } else {
              await writeFile15(fullPath, transformed, "utf-8");
              if (options.verbose) {
                logger.verbose(`Transformed ${changes} command ref(s) in ${fullPath}`);
              }
            }
            filesTransformed++;
            totalReplacements += changes;
          }
        } catch (error) {
          logger.debug(`Skipped ${fullPath}: ${error instanceof Error ? error.message : "unknown"}`);
        }
      }
    }
  }
  await processDirectory(directory);
  return { filesTransformed, totalReplacements };
}

// src/services/transformers/commands-prefix/prefix-utils.ts
init_logger();
function stripWindowsDrivePrefix(path11) {
  if (path11.length >= 2 && /[a-zA-Z]/.test(path11[0]) && path11[1] === ":") {
    return path11.slice(2);
  }
  if (path11.startsWith("\\\\?\\")) {
    const remainder = path11.slice(4);
    if (remainder.length >= 2 && /[a-zA-Z]/.test(remainder[0]) && remainder[1] === ":") {
      return remainder.slice(2);
    }
  }
  return path11;
}
function validatePath(path11, paramName) {
  if (!path11 || typeof path11 !== "string") {
    throw new Error(`${paramName} must be a non-empty string`);
  }
  if (path11.length > 1000) {
    throw new Error(`${paramName} path too long (max 1000 chars)`);
  }
  if (/(?:^|[\\/])\.\.(?:[\\/]|$)/.test(path11) || path11.startsWith("~")) {
    throw new Error(`${paramName} contains path traversal: ${path11}`);
  }
  const sanitizedPath = stripWindowsDrivePrefix(path11);
  if (/[<>:"|?*]/.test(sanitizedPath)) {
    logger.debug(`Path validation failed (invalid character) for ${paramName}: ${path11}`);
    throw new Error(`${paramName} contains invalid characters: ${path11}`);
  }
  for (let i = 0;i < path11.length; i++) {
    const code2 = path11.charCodeAt(i);
    if (code2 < 32 || code2 === 127) {
      throw new Error(`${paramName} contains control characters`);
    }
  }
}
function shouldApplyPrefix(options) {
  return options.prefix === true;
}

// src/services/transformers/commands-prefix/prefix-applier.ts
async function applyPrefix(extractDir) {
  validatePath(extractDir, "extractDir");
  const commandsDir = join50(extractDir, ".claude", "commands");
  if (!await import_fs_extra15.pathExists(commandsDir)) {
    logger.verbose("No commands directory found, skipping prefix application");
    return;
  }
  logger.info("Applying /ck: prefix to slash commands...");
  const backupDir = join50(extractDir, ".commands-backup");
  const tempDir = join50(extractDir, ".commands-prefix-temp");
  try {
    const entries = await readdir12(commandsDir);
    if (entries.length === 0) {
      logger.verbose("Commands directory is empty, skipping prefix application");
      return;
    }
    if (entries.length === 1 && entries[0] === "ck") {
      const ckDir2 = join50(commandsDir, "ck");
      const ckStat = await stat8(ckDir2);
      if (ckStat.isDirectory()) {
        logger.verbose("Commands already have /ck: prefix, skipping");
        return;
      }
    }
    await import_fs_extra15.copy(commandsDir, backupDir);
    logger.verbose("Created backup of commands directory");
    await mkdir16(tempDir, { recursive: true });
    const ckDir = join50(tempDir, "ck");
    await mkdir16(ckDir, { recursive: true });
    let processedCount = 0;
    for (const entry of entries) {
      const sourcePath = join50(commandsDir, entry);
      const stats = await lstat5(sourcePath);
      if (stats.isSymbolicLink()) {
        logger.warning(`Skipping symlink for security: ${entry}`);
        continue;
      }
      const destPath = join50(ckDir, entry);
      await import_fs_extra15.copy(sourcePath, destPath, {
        overwrite: false,
        errorOnExist: true
      });
      processedCount++;
      logger.verbose(`Moved ${entry} to ck/${entry}`);
    }
    if (processedCount === 0) {
      logger.warning("No files to move (all were symlinks or invalid)");
      await import_fs_extra15.remove(backupDir);
      await import_fs_extra15.remove(tempDir);
      return;
    }
    await import_fs_extra15.remove(commandsDir);
    await import_fs_extra15.move(tempDir, commandsDir);
    await import_fs_extra15.remove(backupDir);
    logger.success("Successfully reorganized commands to /ck: prefix");
    const claudeDir = join50(extractDir, ".claude");
    logger.info("Transforming command references in file contents...");
    const transformResult = await transformCommandReferences(claudeDir, {
      verbose: logger.isVerbose()
    });
    if (transformResult.totalReplacements > 0) {
      logger.success(`Transformed ${transformResult.totalReplacements} command ref(s) in ${transformResult.filesTransformed} file(s)`);
    } else {
      logger.verbose("No command references needed transformation");
    }
  } catch (error) {
    if (await import_fs_extra15.pathExists(backupDir)) {
      try {
        await import_fs_extra15.remove(commandsDir).catch(() => {});
        await import_fs_extra15.move(backupDir, commandsDir);
        logger.info("Restored original commands directory from backup");
      } catch (rollbackError) {
        logger.error(`Rollback failed: ${rollbackError}`);
      }
    }
    if (await import_fs_extra15.pathExists(tempDir)) {
      await import_fs_extra15.remove(tempDir).catch(() => {});
    }
    logger.error("Failed to apply /ck: prefix to commands");
    throw error;
  } finally {
    if (await import_fs_extra15.pathExists(backupDir)) {
      await import_fs_extra15.remove(backupDir).catch(() => {});
    }
    if (await import_fs_extra15.pathExists(tempDir)) {
      await import_fs_extra15.remove(tempDir).catch(() => {});
    }
  }
}

// src/services/transformers/commands-prefix/prefix-cleaner.ts
import { lstat as lstat7, readdir as readdir14 } from "node:fs/promises";
import { join as join52 } from "node:path";
init_logger();
var import_fs_extra17 = __toESM(require_lib(), 1);

// src/services/transformers/commands-prefix/file-processor.ts
import { lstat as lstat6, readdir as readdir13 } from "node:fs/promises";
import { join as join51 } from "node:path";
init_logger();
var import_fs_extra16 = __toESM(require_lib(), 1);
async function scanDirectoryFiles(dir) {
  const files = [];
  const entries = await readdir13(dir);
  for (const entry of entries) {
    const fullPath = join51(dir, entry);
    const stats = await lstat6(fullPath);
    if (stats.isSymbolicLink()) {
      continue;
    }
    if (stats.isDirectory()) {
      files.push(...await scanDirectoryFiles(fullPath));
    } else if (stats.isFile()) {
      files.push(fullPath);
    }
  }
  return files;
}
async function processFileOwnership(file, relativePath, metadata, claudeDir, options, accumulator) {
  const { dryRun = false, forceOverwrite = false } = options;
  const ownershipResult = await OwnershipChecker.checkOwnership(file, metadata, claudeDir);
  if (ownershipResult.ownership === "ck" && ownershipResult.exists) {
    accumulator.results.push({
      path: relativePath,
      ownership: "ck",
      action: "delete"
    });
    if (!dryRun) {
      await import_fs_extra16.remove(file);
      logger.verbose(`Deleted CK file: ${relativePath}`);
    }
    accumulator.deletedCount++;
    return true;
  }
  if (ownershipResult.ownership === "ck-modified") {
    if (forceOverwrite) {
      accumulator.results.push({
        path: relativePath,
        ownership: "ck-modified",
        action: "delete",
        reason: "force overwrite"
      });
      if (!dryRun) {
        await import_fs_extra16.remove(file);
        logger.verbose(`Force-deleted modified file: ${relativePath}`);
      }
      accumulator.deletedCount++;
      return true;
    }
    accumulator.results.push({
      path: relativePath,
      ownership: "ck-modified",
      action: "preserve",
      reason: "modified by user"
    });
    accumulator.preservedCount++;
    logger.verbose(`Preserved modified file: ${relativePath}`);
    return false;
  }
  if (forceOverwrite) {
    accumulator.results.push({
      path: relativePath,
      ownership: "user",
      action: "delete",
      reason: "force overwrite"
    });
    if (!dryRun) {
      await import_fs_extra16.remove(file);
      logger.verbose(`Force-deleted user file: ${relativePath}`);
    }
    accumulator.deletedCount++;
    return true;
  }
  accumulator.results.push({
    path: relativePath,
    ownership: "user",
    action: "preserve",
    reason: "user-created"
  });
  accumulator.preservedCount++;
  logger.verbose(`Preserved user file: ${relativePath}`);
  return false;
}
function addSymlinkSkip(entry, accumulator) {
  logger.warning(`Skipping symlink: ${entry}`);
  accumulator.results.push({
    path: entry,
    ownership: "user",
    action: "skip",
    reason: "symlink (security)"
  });
  accumulator.preservedCount++;
}
function logCleanupSummary(deletedCount, preservedCount, dryRun, results) {
  if (dryRun) {
    logger.info(`DRY RUN complete: would delete ${deletedCount}, preserve ${preservedCount}`);
  } else {
    logger.success(`Cleanup complete: deleted ${deletedCount}, preserved ${preservedCount}`);
  }
  if (preservedCount > 0 && !dryRun) {
    const preserved = results.filter((r2) => r2.action === "preserve");
    logger.info("Preserved files:");
    preserved.slice(0, 5).forEach((r2) => logger.info(`  - ${r2.path} (${r2.reason})`));
    if (preserved.length > 5) {
      logger.info(`  ... and ${preserved.length - 5} more`);
    }
  }
}

// src/services/transformers/commands-prefix/prefix-cleaner.ts
async function cleanupCommandsDirectory(targetDir, isGlobal, options = {}) {
  const { dryRun = false } = options;
  validatePath(targetDir, "targetDir");
  const claudeDir = isGlobal ? targetDir : join52(targetDir, ".claude");
  const commandsDir = join52(claudeDir, "commands");
  const accumulator = {
    results: [],
    deletedCount: 0,
    preservedCount: 0
  };
  const result = {
    results: accumulator.results,
    deletedCount: 0,
    preservedCount: 0,
    wasDryRun: dryRun
  };
  if (!await import_fs_extra17.pathExists(commandsDir)) {
    logger.verbose(`Commands directory does not exist: ${commandsDir}`);
    return result;
  }
  if (dryRun) {
    logger.info("DRY RUN: Analyzing ownership (no changes will be made)...");
  } else {
    logger.info("Checking ownership before cleanup...");
  }
  const metadata = await ManifestWriter.readManifest(claudeDir);
  const allTrackedFiles = metadata ? getAllTrackedFiles(metadata) : [];
  if (!metadata || allTrackedFiles.length === 0) {
    logger.verbose("No ownership metadata found - skipping cleanup (legacy/fresh install)");
    logger.verbose("All existing files will be preserved as user-owned");
    return result;
  }
  const entries = await readdir14(commandsDir);
  if (entries.length === 0) {
    logger.verbose("Commands directory is empty");
    return result;
  }
  for (const entry of entries) {
    const entryPath = join52(commandsDir, entry);
    const stats = await lstat7(entryPath);
    if (stats.isSymbolicLink()) {
      addSymlinkSkip(entry, accumulator);
      continue;
    }
    if (stats.isDirectory()) {
      await processDirectory(entryPath, entry, claudeDir, metadata, options, accumulator, dryRun);
    } else {
      const relativePath = `commands/${entry}`;
      await processFileOwnership(entryPath, relativePath, metadata, claudeDir, options, accumulator);
    }
  }
  result.deletedCount = accumulator.deletedCount;
  result.preservedCount = accumulator.preservedCount;
  logCleanupSummary(result.deletedCount, result.preservedCount, dryRun, result.results);
  return result;
}
async function processDirectory(entryPath, entry, claudeDir, metadata, options, accumulator, dryRun) {
  const dirFiles = await scanDirectoryFiles(entryPath);
  let canDeleteDir = true;
  for (const file of dirFiles) {
    const relativePath = file.replace(`${claudeDir}/`, "").replace(/\\/g, "/");
    const canDelete = await processFileOwnership(file, relativePath, metadata, claudeDir, options, accumulator);
    if (!canDelete) {
      canDeleteDir = false;
    }
  }
  if (canDeleteDir && !dryRun) {
    await import_fs_extra17.remove(entryPath);
    logger.verbose(`Removed directory: ${entry}`);
  }
}

// src/services/transformers/commands-prefix.ts
class CommandsPrefix {
  static applyPrefix = applyPrefix;
  static shouldApplyPrefix = shouldApplyPrefix;
  static cleanupCommandsDirectory = cleanupCommandsDirectory;
}

// src/commands/init/phases/merge-handler.ts
init_logger();
init_output_manager();
var import_fs_extra18 = __toESM(require_lib(), 1);
async function handleMerge(ctx) {
  if (ctx.cancelled || !ctx.extractDir || !ctx.resolvedDir || !ctx.claudeDir || !ctx.kit || !ctx.kitType) {
    return ctx;
  }
  const installedVersion = ctx.release?.tag_name ?? "local";
  let customClaudeFiles = [];
  if (!ctx.options.fresh) {
    logger.info("Scanning for custom .claude files...");
    const scanSourceDir = ctx.options.global ? join53(ctx.extractDir, ".claude") : ctx.extractDir;
    const scanTargetSubdir = ctx.options.global ? "" : ".claude";
    customClaudeFiles = await FileScanner2.findCustomFiles(ctx.resolvedDir, scanSourceDir, scanTargetSubdir);
  } else {
    logger.debug("Skipping custom file scan (fresh installation)");
  }
  let includePatterns = [];
  if (ctx.options.only && ctx.options.only.length > 0) {
    includePatterns = ctx.options.only;
    logger.info(`Including only: ${includePatterns.join(", ")}`);
  } else if (!ctx.isNonInteractive) {
    const updateEverything = await ctx.prompts.promptUpdateMode();
    if (!updateEverything) {
      includePatterns = await ctx.prompts.promptDirectorySelection(ctx.options.global);
      logger.info(`Selected directories: ${includePatterns.join(", ")}`);
    }
  }
  output.section("Installing");
  logger.verbose("Installation target", {
    directory: ctx.resolvedDir,
    mode: ctx.options.global ? "global" : "local"
  });
  const merger = new FileMerger;
  if (includePatterns.length > 0) {
    merger.setIncludePatterns(includePatterns);
  }
  if (customClaudeFiles.length > 0) {
    merger.addIgnorePatterns(customClaudeFiles);
    logger.success(`Protected ${customClaudeFiles.length} custom .claude file(s)`);
  }
  if (ctx.options.exclude && ctx.options.exclude.length > 0) {
    merger.addIgnorePatterns(ctx.options.exclude);
  }
  merger.setGlobalFlag(ctx.options.global);
  merger.setForceOverwriteSettings(ctx.options.forceOverwriteSettings);
  merger.setProjectDir(ctx.resolvedDir);
  merger.setKitName(ctx.kit.name);
  if (ctx.kitType) {
    merger.setMultiKitContext(ctx.claudeDir, ctx.kitType);
  }
  const releaseManifest = await ReleaseManifestLoader.load(ctx.extractDir);
  if (releaseManifest) {
    merger.setManifest(releaseManifest);
  }
  if (!ctx.options.fresh && await import_fs_extra18.pathExists(ctx.claudeDir)) {
    const legacyDetection = await LegacyMigration.detectLegacy(ctx.claudeDir);
    if (legacyDetection.isLegacy && releaseManifest) {
      logger.info("Legacy installation detected - migrating to ownership tracking...");
      await LegacyMigration.migrate(ctx.claudeDir, releaseManifest, ctx.kit.name, installedVersion, !ctx.isNonInteractive);
      logger.success("Migration complete");
    }
  }
  if (CommandsPrefix.shouldApplyPrefix(ctx.options)) {
    const cleanupResult = await CommandsPrefix.cleanupCommandsDirectory(ctx.resolvedDir, ctx.options.global, {
      dryRun: ctx.options.dryRun,
      forceOverwrite: ctx.options.forceOverwrite
    });
    if (ctx.options.dryRun) {
      const { OwnershipDisplay: OwnershipDisplay2 } = await Promise.resolve().then(() => (init_ownership_display(), exports_ownership_display));
      OwnershipDisplay2.displayOperationPreview(cleanupResult.results);
      ctx.prompts.outro("Dry-run complete. No changes were made.");
      return { ...ctx, cancelled: true };
    }
  }
  const sourceDir = ctx.options.global ? join53(ctx.extractDir, ".claude") : ctx.extractDir;
  await merger.merge(sourceDir, ctx.resolvedDir, ctx.isNonInteractive);
  const fileConflicts = merger.getFileConflicts();
  if (fileConflicts.length > 0 && !ctx.isNonInteractive) {
    const summary = buildConflictSummary(fileConflicts, [], []);
    displayConflictSummary(summary);
  }
  const installedFiles = merger.getAllInstalledFiles();
  const filesToTrack = buildFileTrackingList({
    installedFiles,
    claudeDir: ctx.claudeDir,
    releaseManifest,
    installedVersion,
    isGlobal: ctx.options.global
  });
  await trackFilesWithProgress(filesToTrack, {
    claudeDir: ctx.claudeDir,
    kitName: ctx.kit.name,
    releaseTag: installedVersion,
    mode: ctx.options.global ? "global" : "local",
    kitType: ctx.kitType
  });
  return {
    ...ctx,
    customClaudeFiles,
    includePatterns
  };
}
// src/commands/init/phases/migration-handler.ts
import { join as join61 } from "node:path";

// src/domains/skills/skills-detector.ts
init_logger();
var import_fs_extra21 = __toESM(require_lib(), 1);

// src/domains/skills/detection/config-detector.ts
init_logger();

// src/domains/skills/skills-manifest.ts
init_logger();
import { createHash as createHash2 } from "node:crypto";
import { readFile as readFile19, readdir as readdir15, writeFile as writeFile16 } from "node:fs/promises";
import { join as join54, relative as relative9 } from "node:path";
init_types2();
var import_fs_extra19 = __toESM(require_lib(), 1);

class SkillsManifestManager {
  static MANIFEST_FILENAME = ".skills-manifest.json";
  static MANIFEST_VERSION = "1.0.0";
  static async generateManifest(skillsDir) {
    logger.debug(`Generating manifest for: ${skillsDir}`);
    if (!await import_fs_extra19.pathExists(skillsDir)) {
      throw new SkillsMigrationError(`Skills directory does not exist: ${skillsDir}`);
    }
    const structure = await SkillsManifestManager.detectStructure(skillsDir);
    const skills = await SkillsManifestManager.scanSkills(skillsDir, structure);
    const manifest = {
      version: SkillsManifestManager.MANIFEST_VERSION,
      structure,
      timestamp: new Date().toISOString(),
      skills
    };
    logger.debug(`Generated manifest with ${skills.length} skills (${structure} structure)`);
    return manifest;
  }
  static async writeManifest(skillsDir, manifest) {
    const manifestPath = join54(skillsDir, SkillsManifestManager.MANIFEST_FILENAME);
    await writeFile16(manifestPath, JSON.stringify(manifest, null, 2), "utf-8");
    logger.debug(`Wrote manifest to: ${manifestPath}`);
  }
  static async readManifest(skillsDir) {
    const manifestPath = join54(skillsDir, SkillsManifestManager.MANIFEST_FILENAME);
    if (!await import_fs_extra19.pathExists(manifestPath)) {
      logger.debug(`No manifest found at: ${manifestPath}`);
      return null;
    }
    try {
      const content = await readFile19(manifestPath, "utf-8");
      const data = JSON.parse(content);
      const manifest = SkillsManifestSchema.parse(data);
      logger.debug(`Read manifest from: ${manifestPath}`);
      return manifest;
    } catch (error) {
      logger.warning(`Failed to parse manifest at ${manifestPath}: ${error instanceof Error ? error.message : "Unknown error"}`);
      return null;
    }
  }
  static async detectStructure(skillsDir) {
    const entries = await readdir15(skillsDir, { withFileTypes: true });
    const dirs = entries.filter((entry) => entry.isDirectory() && !BUILD_ARTIFACT_DIRS.includes(entry.name) && !entry.name.startsWith("."));
    if (dirs.length === 0) {
      return "flat";
    }
    for (const dir of dirs.slice(0, 3)) {
      const dirPath = join54(skillsDir, dir.name);
      const subEntries = await readdir15(dirPath, { withFileTypes: true });
      const hasSubdirs = subEntries.some((entry) => entry.isDirectory());
      if (hasSubdirs) {
        return "categorized";
      }
      const hasSkillFile = subEntries.some((entry) => entry.isFile() && entry.name.toLowerCase().endsWith(".md"));
      if (hasSkillFile) {
        return "flat";
      }
    }
    return "flat";
  }
  static async scanSkills(skillsDir, structure) {
    const skills = [];
    if (structure === "flat") {
      const entries = await readdir15(skillsDir, { withFileTypes: true });
      for (const entry of entries) {
        if (entry.isDirectory() && !BUILD_ARTIFACT_DIRS.includes(entry.name) && !entry.name.startsWith(".")) {
          const skillPath = join54(skillsDir, entry.name);
          const hash = await SkillsManifestManager.hashDirectory(skillPath);
          skills.push({
            name: entry.name,
            hash
          });
        }
      }
    } else {
      const categories = await readdir15(skillsDir, { withFileTypes: true });
      for (const category of categories) {
        if (category.isDirectory() && !BUILD_ARTIFACT_DIRS.includes(category.name) && !category.name.startsWith(".")) {
          const categoryPath = join54(skillsDir, category.name);
          const skillEntries = await readdir15(categoryPath, { withFileTypes: true });
          for (const skillEntry of skillEntries) {
            if (skillEntry.isDirectory() && !skillEntry.name.startsWith(".")) {
              const skillPath = join54(categoryPath, skillEntry.name);
              const hash = await SkillsManifestManager.hashDirectory(skillPath);
              skills.push({
                name: skillEntry.name,
                category: category.name,
                hash
              });
            }
          }
        }
      }
    }
    return skills.sort((a3, b3) => a3.name.localeCompare(b3.name));
  }
  static async hashDirectory(dirPath) {
    const hash = createHash2("sha256");
    const files = await SkillsManifestManager.getAllFiles(dirPath);
    files.sort();
    for (const file of files) {
      const relativePath = relative9(dirPath, file);
      const content = await readFile19(file);
      hash.update(relativePath);
      hash.update(content);
    }
    return hash.digest("hex");
  }
  static async getAllFiles(dirPath) {
    const files = [];
    const entries = await readdir15(dirPath, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = join54(dirPath, entry.name);
      if (entry.name.startsWith(".") || BUILD_ARTIFACT_DIRS.includes(entry.name)) {
        continue;
      }
      if (entry.isDirectory()) {
        const subFiles = await SkillsManifestManager.getAllFiles(fullPath);
        files.push(...subFiles);
      } else if (entry.isFile()) {
        files.push(fullPath);
      }
    }
    return files;
  }
  static validateManifest(manifest) {
    try {
      SkillsManifestSchema.parse(manifest);
      return true;
    } catch {
      return false;
    }
  }
  static compareManifests(oldManifest, newManifest) {
    const changedSkills = [];
    const oldSkillsMap = new Map(oldManifest.skills.map((s) => [s.name, s.hash]));
    for (const newSkill of newManifest.skills) {
      const oldHash = oldSkillsMap.get(newSkill.name);
      if (oldHash && oldHash !== newSkill.hash) {
        changedSkills.push(newSkill.name);
      }
    }
    return changedSkills;
  }
}

// src/domains/skills/detection/dependency-detector.ts
init_logger();

// src/domains/skills/skills-mappings.ts
var SKILL_CATEGORY_MAPPINGS = [
  {
    oldSkills: [
      "gemini-vision",
      "gemini-image-gen",
      "gemini-video",
      "gemini-thinking",
      "gemini-files"
    ],
    newCategory: "ai-multimodal"
  },
  {
    oldSkills: ["postgresql-psql", "mongodb"],
    newCategory: "databases"
  },
  {
    oldSkills: [
      "cloudflare-dns",
      "cloudflare-pages",
      "cloudflare-workers",
      "cloudflare-d1",
      "docker",
      "gcloud"
    ],
    newCategory: "devops"
  },
  {
    oldSkills: ["ffmpeg", "imagemagick"],
    newCategory: "media-processing"
  },
  {
    oldSkills: ["nextjs", "remix-icon", "turborepo"],
    newCategory: "web-frameworks"
  },
  {
    oldSkills: ["tailwindcss", "shadcn-ui", "canvas-design"],
    newCategory: "ui-styling"
  }
];
var PRESERVED_SKILLS = [
  "common",
  "debugging",
  "document-skills",
  "problem-solving",
  "sequential-thinking",
  "claude-code",
  "better-auth",
  "chrome-devtools",
  "shopify",
  "mcp-builder",
  "docs-seeker",
  "repomix",
  "skill-creator",
  "template-skill",
  "google-adk-python"
];
function getCategoryForSkill(skillName) {
  if (PRESERVED_SKILLS.includes(skillName)) {
    return null;
  }
  for (const mapping of SKILL_CATEGORY_MAPPINGS) {
    if (mapping.oldSkills.includes(skillName)) {
      return mapping.newCategory;
    }
  }
  return null;
}
function getAllMigratableSkills() {
  return SKILL_CATEGORY_MAPPINGS.flatMap((mapping) => mapping.oldSkills);
}
function getPathMapping(skillName, oldBasePath, newBasePath) {
  const category = getCategoryForSkill(skillName);
  if (category === null) {
    return null;
  }
  return {
    oldPath: `${oldBasePath}/${skillName}`,
    newPath: `${newBasePath}/${category}/${skillName}`
  };
}

// src/domains/skills/detection/script-detector.ts
var import_fs_extra20 = __toESM(require_lib(), 1);
import { readdir as readdir16 } from "node:fs/promises";
import { join as join55 } from "node:path";
async function scanDirectory(skillsDir) {
  if (!await import_fs_extra20.pathExists(skillsDir)) {
    return ["flat", []];
  }
  const entries = await readdir16(skillsDir, { withFileTypes: true });
  const dirs = entries.filter((entry) => entry.isDirectory() && entry.name !== "node_modules" && !entry.name.startsWith("."));
  if (dirs.length === 0) {
    return ["flat", []];
  }
  let totalSkillLikeCount = 0;
  const allSkills = [];
  for (const dir of dirs) {
    const dirPath = join55(skillsDir, dir.name);
    const subEntries = await readdir16(dirPath, { withFileTypes: true });
    const subdirs = subEntries.filter((entry) => entry.isDirectory() && !entry.name.startsWith("."));
    if (subdirs.length > 0) {
      for (const subdir of subdirs.slice(0, 3)) {
        const subdirPath = join55(dirPath, subdir.name);
        const subdirFiles = await readdir16(subdirPath, { withFileTypes: true });
        const hasSkillMarker = subdirFiles.some((file) => file.isFile() && (file.name === "skill.md" || file.name === "README.md" || file.name === "readme.md" || file.name === "config.json" || file.name === "package.json"));
        if (hasSkillMarker) {
          totalSkillLikeCount++;
          allSkills.push(subdir.name);
        }
      }
    }
  }
  if (totalSkillLikeCount > 0) {
    return ["categorized", allSkills];
  }
  return ["flat", dirs.map((dir) => dir.name)];
}

// src/domains/skills/detection/dependency-detector.ts
async function generateSkillMappings(currentSkillsDir, newSkillsDir) {
  const mappings = [];
  const [, currentSkills] = await scanDirectory(currentSkillsDir);
  for (const skillName of currentSkills) {
    const mapping = getPathMapping(skillName, currentSkillsDir, newSkillsDir);
    if (mapping) {
      const category = getCategoryForSkill(skillName);
      mappings.push({
        oldPath: mapping.oldPath,
        newPath: mapping.newPath,
        skillName,
        category: category || undefined
      });
    }
  }
  return mappings;
}
async function detectViaHeuristics(oldSkillsDir, currentSkillsDir) {
  const [oldStructure] = await scanDirectory(oldSkillsDir);
  const [currentStructure, currentSkills] = await scanDirectory(currentSkillsDir);
  if (oldStructure === currentStructure) {
    return {
      status: "not_needed",
      oldStructure,
      newStructure: oldStructure,
      customizations: [],
      skillMappings: []
    };
  }
  if (currentStructure === "flat" && oldStructure === "categorized") {
    logger.info("Migration detected: flat  categorized structure (via heuristics)");
    const migratableSkillsInCurrent = currentSkills.filter((skill) => getAllMigratableSkills().includes(skill));
    if (migratableSkillsInCurrent.length > 0) {
      const mappings = await generateSkillMappings(currentSkillsDir, oldSkillsDir);
      return {
        status: "recommended",
        oldStructure: currentStructure,
        newStructure: oldStructure,
        customizations: [],
        skillMappings: mappings
      };
    }
  }
  return {
    status: "not_needed",
    oldStructure,
    newStructure: oldStructure,
    customizations: [],
    skillMappings: []
  };
}

// src/domains/skills/detection/config-detector.ts
async function detectViaManifest(oldSkillsDir, currentSkillsDir) {
  const newManifest = await SkillsManifestManager.readManifest(oldSkillsDir);
  const currentManifest = await SkillsManifestManager.readManifest(currentSkillsDir);
  if (!newManifest) {
    return null;
  }
  if (!currentManifest) {
    try {
      const generatedManifest = await SkillsManifestManager.generateManifest(currentSkillsDir);
      if (generatedManifest.structure === "flat" && newManifest.structure === "categorized") {
        logger.info("Migration detected: flat  categorized structure");
        const mappings = await generateSkillMappings(currentSkillsDir, oldSkillsDir);
        return {
          status: "recommended",
          oldStructure: generatedManifest.structure,
          newStructure: newManifest.structure,
          customizations: [],
          skillMappings: mappings
        };
      }
    } catch (error) {
      logger.warning(`Failed to generate current manifest: ${error instanceof Error ? error.message : "Unknown error"}`);
      return null;
    }
  }
  if (currentManifest && newManifest) {
    if (currentManifest.structure === "flat" && newManifest.structure === "categorized") {
      logger.info("Migration detected: flat  categorized structure (via manifest)");
      const mappings = await generateSkillMappings(currentSkillsDir, oldSkillsDir);
      return {
        status: "recommended",
        oldStructure: currentManifest.structure,
        newStructure: newManifest.structure,
        customizations: [],
        skillMappings: mappings
      };
    }
    return {
      status: "not_needed",
      oldStructure: currentManifest.structure,
      newStructure: newManifest.structure,
      customizations: [],
      skillMappings: []
    };
  }
  return null;
}

// src/domains/skills/skills-detector.ts
class SkillsMigrationDetector {
  static async detectMigration(oldSkillsDir, currentSkillsDir) {
    logger.debug("Detecting skills migration need...");
    const oldExists = await import_fs_extra21.pathExists(oldSkillsDir);
    const currentExists = await import_fs_extra21.pathExists(currentSkillsDir);
    if (!oldExists && !currentExists) {
      logger.debug("No skills directories found, migration not needed");
      return {
        status: "not_needed",
        oldStructure: null,
        newStructure: null,
        customizations: [],
        skillMappings: []
      };
    }
    if (!currentExists) {
      logger.debug("No current skills directory, migration not needed");
      return {
        status: "not_needed",
        oldStructure: null,
        newStructure: null,
        customizations: [],
        skillMappings: []
      };
    }
    const manifestResult = await detectViaManifest(oldSkillsDir, currentSkillsDir);
    if (manifestResult !== null) {
      logger.debug("Detected migration via manifest");
      return manifestResult;
    }
    logger.debug("Manifest not found, using heuristic detection");
    return await detectViaHeuristics(oldSkillsDir, currentSkillsDir);
  }
}

// src/domains/skills/skills-migrator.ts
init_logger();
init_types2();
import { join as join60 } from "node:path";

// src/domains/skills/migrator/migration-executor.ts
init_logger();
import { copyFile as copyFile4, mkdir as mkdir17, readdir as readdir17, rm as rm3 } from "node:fs/promises";
import { join as join56 } from "node:path";
var import_fs_extra22 = __toESM(require_lib(), 1);

// src/domains/skills/skills-migration-prompts.ts
init_environment();
init_logger();
init_dist2();

class SkillsMigrationPrompts {
  static async promptMigrationDecision(detection) {
    if (isNonInteractive()) {
      logger.info("Non-interactive mode: proceeding with skills migration");
      return true;
    }
    const customizedCount = detection.customizations.filter((c2) => c2.isCustomized).length;
    const totalSkills = detection.skillMappings.length;
    let message = `Skills directory structure migration available.

`;
    message += `Found ${totalSkills} skill(s) that can be migrated to new categorized structure.
`;
    if (customizedCount > 0) {
      message += `
  ${customizedCount} skill(s) have customizations that will be preserved.
`;
    }
    message += `
Would you like to migrate now?`;
    const result = await se({
      message,
      initialValue: true
    });
    return result === true;
  }
  static async showMigrationPreview(mappings, customizations) {
    f2.info("Migration Preview:");
    f2.message("");
    const byCategory = new Map;
    for (const mapping of mappings) {
      const category = mapping.category || "other";
      if (!byCategory.has(category)) {
        byCategory.set(category, []);
      }
      byCategory.get(category)?.push(mapping);
    }
    for (const [category, skills] of byCategory.entries()) {
      f2.step(`${category}/ (${skills.length} skills)`);
      for (const skill of skills) {
        const customization = customizations.find((c2) => c2.skillName === skill.skillName);
        const badge = customization?.isCustomized ? " [CUSTOMIZED]" : "";
        f2.message(`   ${skill.skillName}${badge}`);
      }
      f2.message("");
    }
  }
  static async promptCustomizationHandling(customizations) {
    if (customizations.length === 0) {
      return "preserve";
    }
    if (isNonInteractive()) {
      logger.info("Non-interactive mode: preserving all customizations");
      return "preserve";
    }
    const result = await ie({
      message: "How should customized skills be handled?",
      options: [
        {
          value: "preserve",
          label: "Preserve all customizations (recommended)",
          hint: "Keep your changes and migrate structure"
        },
        {
          value: "review",
          label: "Review each customization",
          hint: "Decide for each customized skill individually"
        },
        {
          value: "skip",
          label: "Skip customized skills",
          hint: "Only migrate unmodified skills"
        }
      ],
      initialValue: "preserve"
    });
    return result;
  }
  static async promptSkillMigration(skillName, customization) {
    if (isNonInteractive()) {
      logger.info(`Non-interactive mode: migrating skill ${skillName}`);
      return true;
    }
    let message = `Migrate skill: ${skillName}?`;
    if (customization.isCustomized && customization.changes) {
      const changes = customization.changes;
      const added = changes.filter((c2) => c2.type === "added").length;
      const modified = changes.filter((c2) => c2.type === "modified").length;
      const deleted = changes.filter((c2) => c2.type === "deleted").length;
      message += `

Detected changes:`;
      if (added > 0)
        message += `
  + ${added} file(s) added`;
      if (modified > 0)
        message += `
  ~ ${modified} file(s) modified`;
      if (deleted > 0)
        message += `
  - ${deleted} file(s) deleted`;
    }
    const result = await se({
      message,
      initialValue: true
    });
    return result === true;
  }
  static showProgress() {
    return de();
  }
  static showSummary(migrated, preserved, skipped, errors2) {
    f2.message("");
    f2.info("Migration Summary:");
    f2.message("");
    f2.success(` ${migrated} skill(s) migrated`);
    if (preserved > 0) {
      f2.info(` ${preserved} customization(s) preserved`);
    }
    if (skipped > 0) {
      f2.warning(` ${skipped} skill(s) skipped`);
    }
    if (errors2 > 0) {
      f2.error(` ${errors2} error(s) occurred`);
    }
    f2.message("");
  }
  static async promptBackup() {
    if (isNonInteractive()) {
      logger.info("Non-interactive mode: creating backup before migration");
      return true;
    }
    const result = await se({
      message: "Create backup of current skills directory before migration?",
      initialValue: true
    });
    return result === true;
  }
  static showError(message) {
    f2.error(message);
  }
  static showWarning(message) {
    f2.warning(message);
  }
  static showInfo(message) {
    f2.info(message);
  }
  static showSuccess(message) {
    f2.success(message);
  }
}

// src/domains/skills/migrator/migration-executor.ts
async function copySkillDirectory(sourceDir, destDir) {
  await mkdir17(destDir, { recursive: true });
  const entries = await readdir17(sourceDir, { withFileTypes: true });
  for (const entry of entries) {
    const sourcePath = join56(sourceDir, entry.name);
    const destPath = join56(destDir, entry.name);
    if (entry.name.startsWith(".") || entry.name === "node_modules" || entry.isSymbolicLink()) {
      continue;
    }
    if (entry.isDirectory()) {
      await copySkillDirectory(sourcePath, destPath);
    } else if (entry.isFile()) {
      await copyFile4(sourcePath, destPath);
    }
  }
}
async function executeInternal(mappings, customizations, currentSkillsDir, interactive) {
  const migrated = [];
  const preserved = [];
  const errors2 = [];
  const tempDir = join56(currentSkillsDir, "..", ".skills-migration-temp");
  await mkdir17(tempDir, { recursive: true });
  try {
    for (const mapping of mappings) {
      try {
        const skillName = mapping.skillName;
        const currentSkillPath = mapping.oldPath;
        if (!await import_fs_extra22.pathExists(currentSkillPath)) {
          logger.warning(`Skill not found, skipping: ${skillName}`);
          continue;
        }
        const customization = customizations.find((c2) => c2.skillName === skillName);
        const isCustomized = customization?.isCustomized || false;
        if (interactive && isCustomized && customization) {
          const shouldMigrate = await SkillsMigrationPrompts.promptSkillMigration(skillName, customization);
          if (!shouldMigrate) {
            logger.info(`Skipped: ${skillName}`);
            continue;
          }
        }
        const category = mapping.category;
        const targetPath = category ? join56(tempDir, category, skillName) : join56(tempDir, skillName);
        if (category) {
          await mkdir17(join56(tempDir, category), { recursive: true });
        }
        await copySkillDirectory(currentSkillPath, targetPath);
        migrated.push(skillName);
        if (isCustomized) {
          preserved.push(skillName);
        }
        logger.debug(`Migrated: ${skillName}  ${category || "root"}`);
      } catch (error) {
        errors2.push({
          skill: mapping.skillName,
          path: mapping.oldPath,
          error: error instanceof Error ? error.message : "Unknown error",
          fatal: false
        });
        logger.error(`Failed to migrate ${mapping.skillName}: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    await rm3(currentSkillsDir, { recursive: true, force: true });
    await mkdir17(currentSkillsDir, { recursive: true });
    await copySkillDirectory(tempDir, currentSkillsDir);
    await rm3(tempDir, { recursive: true, force: true });
    return { migrated, preserved, errors: errors2 };
  } catch (error) {
    try {
      await rm3(tempDir, { recursive: true, force: true });
    } catch {}
    throw error;
  }
}
async function executeMigration(mappings, customizations, currentSkillsDir, interactive) {
  return withProcessLock("migration", async () => {
    return executeInternal(mappings, customizations, currentSkillsDir, interactive);
  });
}

// src/domains/skills/migrator/migration-validator.ts
init_types2();
function validateMigrationPath(path11, paramName) {
  if (!path11 || typeof path11 !== "string") {
    throw new SkillsMigrationError(`${paramName} must be a non-empty string`);
  }
  if (path11.length > 1000) {
    throw new SkillsMigrationError(`${paramName} path too long (max 1000 characters)`);
  }
  const isWindowsAbsolutePath = /^[A-Za-z]:[/\\]/.test(path11);
  const hasDangerousTilde = path11.includes("~") && !isWindowsAbsolutePath;
  if (/(?:^|[\\/])\.\.(?:[\\/]|$)/.test(path11) || hasDangerousTilde) {
    throw new SkillsMigrationError(`${paramName} contains potentially dangerous path traversal: ${path11}`);
  }
  const pathWithoutDrive = path11.replace(/^[A-Za-z]:/, "");
  if (/[<>:"|?*]/.test(pathWithoutDrive)) {
    throw new SkillsMigrationError(`${paramName} contains invalid characters: ${path11}`);
  }
  for (let i = 0;i < path11.length; i++) {
    const charCode = path11.charCodeAt(i);
    if (charCode < 32 || charCode === 127) {
      throw new SkillsMigrationError(`${paramName} contains control characters: ${path11}`);
    }
  }
}

// src/domains/skills/skills-backup-manager.ts
init_logger();
init_types2();
var import_fs_extra23 = __toESM(require_lib(), 1);
import { copyFile as copyFile5, mkdir as mkdir18, readdir as readdir18, rm as rm4, stat as stat9 } from "node:fs/promises";
import { basename as basename2, join as join57, normalize as normalize6 } from "node:path";
function validatePath2(path11, paramName) {
  if (!path11 || typeof path11 !== "string") {
    throw new SkillsMigrationError(`${paramName} must be a non-empty string`);
  }
  if (path11.includes("..")) {
    const normalized = normalize6(path11);
    if (normalized.startsWith("..")) {
      throw new SkillsMigrationError(`${paramName} contains invalid path traversal: ${path11}`);
    }
  }
}

class SkillsBackupManager {
  static BACKUP_PREFIX = ".skills-backup-";
  static async createBackup(skillsDir, parentDir) {
    validatePath2(skillsDir, "skillsDir");
    if (parentDir) {
      validatePath2(parentDir, "parentDir");
    }
    if (!await import_fs_extra23.pathExists(skillsDir)) {
      throw new SkillsMigrationError(`Cannot create backup: Skills directory does not exist: ${skillsDir}`);
    }
    const timestamp = Date.now();
    const randomSuffix = Math.random().toString(36).substring(2, 8);
    const backupDirName = `${SkillsBackupManager.BACKUP_PREFIX}${timestamp}-${randomSuffix}`;
    const backupDir = parentDir ? join57(parentDir, backupDirName) : join57(skillsDir, "..", backupDirName);
    logger.info(`Creating backup at: ${backupDir}`);
    try {
      await mkdir18(backupDir, { recursive: true });
      await SkillsBackupManager.copyDirectory(skillsDir, backupDir);
      logger.success("Backup created successfully");
      return backupDir;
    } catch (error) {
      try {
        await rm4(backupDir, { recursive: true, force: true });
      } catch {}
      throw new SkillsMigrationError(`Failed to create backup: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  static async restoreBackup(backupDir, targetDir) {
    validatePath2(backupDir, "backupDir");
    validatePath2(targetDir, "targetDir");
    if (!await import_fs_extra23.pathExists(backupDir)) {
      throw new SkillsMigrationError(`Cannot restore: Backup directory does not exist: ${backupDir}`);
    }
    logger.info(`Restoring from backup: ${backupDir}`);
    try {
      if (await import_fs_extra23.pathExists(targetDir)) {
        await rm4(targetDir, { recursive: true, force: true });
      }
      await mkdir18(targetDir, { recursive: true });
      await SkillsBackupManager.copyDirectory(backupDir, targetDir);
      logger.success("Backup restored successfully");
    } catch (error) {
      throw new SkillsMigrationError(`Failed to restore backup: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  static async deleteBackup(backupDir) {
    if (!await import_fs_extra23.pathExists(backupDir)) {
      logger.warning(`Backup directory does not exist: ${backupDir}`);
      return;
    }
    logger.debug(`Deleting backup: ${backupDir}`);
    try {
      await rm4(backupDir, { recursive: true, force: true });
      logger.debug("Backup deleted successfully");
    } catch (error) {
      logger.warning(`Failed to delete backup: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  static async listBackups(parentDir) {
    if (!await import_fs_extra23.pathExists(parentDir)) {
      return [];
    }
    try {
      const entries = await readdir18(parentDir, { withFileTypes: true });
      const backups = entries.filter((entry) => entry.isDirectory() && entry.name.startsWith(SkillsBackupManager.BACKUP_PREFIX)).map((entry) => join57(parentDir, entry.name));
      backups.sort().reverse();
      return backups;
    } catch (error) {
      logger.warning(`Failed to list backups: ${error instanceof Error ? error.message : "Unknown error"}`);
      return [];
    }
  }
  static async cleanupOldBackups(parentDir, keepCount = 3) {
    const backups = await SkillsBackupManager.listBackups(parentDir);
    if (backups.length <= keepCount) {
      return;
    }
    const toDelete = backups.slice(keepCount);
    logger.debug(`Cleaning up ${toDelete.length} old backup(s)`);
    for (const backup of toDelete) {
      await SkillsBackupManager.deleteBackup(backup);
    }
  }
  static async getBackupSize(backupDir) {
    if (!await import_fs_extra23.pathExists(backupDir)) {
      return 0;
    }
    return await SkillsBackupManager.getDirectorySize(backupDir);
  }
  static async copyDirectory(sourceDir, destDir) {
    const entries = await readdir18(sourceDir, { withFileTypes: true });
    for (const entry of entries) {
      const sourcePath = join57(sourceDir, entry.name);
      const destPath = join57(destDir, entry.name);
      if (entry.name.startsWith(".") || entry.name === "node_modules" || entry.isSymbolicLink()) {
        continue;
      }
      if (entry.isDirectory()) {
        await mkdir18(destPath, { recursive: true });
        await SkillsBackupManager.copyDirectory(sourcePath, destPath);
      } else if (entry.isFile()) {
        await copyFile5(sourcePath, destPath);
      }
    }
  }
  static async getDirectorySize(dirPath) {
    let size = 0;
    const entries = await readdir18(dirPath, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = join57(dirPath, entry.name);
      if (entry.isSymbolicLink()) {
        continue;
      }
      if (entry.isDirectory()) {
        size += await SkillsBackupManager.getDirectorySize(fullPath);
      } else if (entry.isFile()) {
        const stats = await stat9(fullPath);
        size += stats.size;
      }
    }
    return size;
  }
  static extractBackupTimestamp(backupPath) {
    const dirName = basename2(backupPath);
    if (!dirName.startsWith(SkillsBackupManager.BACKUP_PREFIX)) {
      return null;
    }
    const timestampPart = dirName.replace(SkillsBackupManager.BACKUP_PREFIX, "").split("-")[0];
    const timestamp = Number.parseInt(timestampPart, 10);
    return Number.isNaN(timestamp) ? null : timestamp;
  }
}

// src/domains/skills/skills-customization-scanner.ts
init_logger();

// src/domains/skills/customization/comparison-engine.ts
var import_fs_extra24 = __toESM(require_lib(), 1);
import { relative as relative11 } from "node:path";

// src/domains/skills/customization/hash-calculator.ts
import { createHash as createHash3 } from "node:crypto";
import { createReadStream as createReadStream2 } from "node:fs";
import { readFile as readFile20, readdir as readdir19 } from "node:fs/promises";
import { join as join58, relative as relative10 } from "node:path";
async function getAllFiles(dirPath) {
  const files = [];
  const entries = await readdir19(dirPath, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = join58(dirPath, entry.name);
    if (entry.name.startsWith(".") || BUILD_ARTIFACT_DIRS.includes(entry.name) || entry.isSymbolicLink()) {
      continue;
    }
    if (entry.isDirectory()) {
      const subFiles = await getAllFiles(fullPath);
      files.push(...subFiles);
    } else if (entry.isFile()) {
      files.push(fullPath);
    }
  }
  return files;
}
async function hashFile(filePath) {
  return new Promise((resolve7, reject) => {
    const hash = createHash3("sha256");
    const stream = createReadStream2(filePath);
    stream.on("data", (chunk) => hash.update(chunk));
    stream.on("end", () => {
      resolve7(hash.digest("hex"));
    });
    stream.on("error", (error) => {
      stream.destroy();
      reject(error);
    });
  });
}
async function hashDirectory(dirPath) {
  const hash = createHash3("sha256");
  const files = await getAllFiles(dirPath);
  files.sort();
  for (const file of files) {
    const relativePath = relative10(dirPath, file);
    const content = await readFile20(file);
    hash.update(relativePath);
    hash.update(content);
  }
  return hash.digest("hex");
}

// src/domains/skills/customization/comparison-engine.ts
async function isSkillCustomized(skillPath, skillName, baselineSkillPath, hasBaseline, manifest) {
  if (manifest) {
    const currentHash = await hashDirectory(skillPath);
    const baselineHash = manifest.skills.find((s) => s.name === skillName)?.hash;
    if (baselineHash && currentHash !== baselineHash) {
      return true;
    }
    if (baselineHash && currentHash === baselineHash) {
      return false;
    }
  }
  if (hasBaseline && !baselineSkillPath) {
    return true;
  }
  if (baselineSkillPath) {
    return await compareDirectories(skillPath, baselineSkillPath);
  }
  return false;
}
async function compareDirectories(dir1, dir2) {
  const files1 = await getAllFiles(dir1);
  const files2 = await getAllFiles(dir2);
  if (files1.length !== files2.length) {
    return true;
  }
  const relFiles1 = files1.map((f3) => relative11(dir1, f3)).sort();
  const relFiles2 = files2.map((f3) => relative11(dir2, f3)).sort();
  if (JSON.stringify(relFiles1) !== JSON.stringify(relFiles2)) {
    return true;
  }
  for (let i = 0;i < files1.length; i++) {
    const hash1 = await hashFile(files1[i]);
    const hash2 = await hashFile(files2[i]);
    if (hash1 !== hash2) {
      return true;
    }
  }
  return false;
}
async function detectFileChanges(currentSkillPath, baselineSkillPath) {
  const changes = [];
  const currentFiles = await getAllFiles(currentSkillPath);
  const baselineFiles = await import_fs_extra24.pathExists(baselineSkillPath) ? await getAllFiles(baselineSkillPath) : [];
  const currentFileMap = new Map(await Promise.all(currentFiles.map(async (f3) => {
    const relPath = relative11(currentSkillPath, f3);
    const hash = await hashFile(f3);
    return [relPath, hash];
  })));
  const baselineFileMap = new Map(await Promise.all(baselineFiles.map(async (f3) => {
    const relPath = relative11(baselineSkillPath, f3);
    const hash = await hashFile(f3);
    return [relPath, hash];
  })));
  for (const [file, currentHash] of currentFileMap.entries()) {
    const baselineHash = baselineFileMap.get(file);
    if (!baselineHash) {
      changes.push({
        file,
        type: "added",
        newHash: currentHash
      });
    } else if (baselineHash !== currentHash) {
      changes.push({
        file,
        type: "modified",
        oldHash: baselineHash,
        newHash: currentHash
      });
    }
  }
  for (const [file, baselineHash] of baselineFileMap.entries()) {
    if (!currentFileMap.has(file)) {
      changes.push({
        file,
        type: "deleted",
        oldHash: baselineHash
      });
    }
  }
  return changes;
}

// src/domains/skills/customization/scan-reporter.ts
init_types2();
var import_fs_extra25 = __toESM(require_lib(), 1);
import { readdir as readdir20 } from "node:fs/promises";
import { join as join59, normalize as normalize7 } from "node:path";
function validatePath3(path11, paramName) {
  if (!path11 || typeof path11 !== "string") {
    throw new SkillsMigrationError(`${paramName} must be a non-empty string`);
  }
  if (path11.includes("..")) {
    const normalized = normalize7(path11);
    if (normalized.startsWith("..")) {
      throw new SkillsMigrationError(`${paramName} contains invalid path traversal: ${path11}`);
    }
  }
}
async function scanSkillsDirectory(skillsDir) {
  if (!await import_fs_extra25.pathExists(skillsDir)) {
    return ["flat", []];
  }
  const entries = await readdir20(skillsDir, { withFileTypes: true });
  const dirs = entries.filter((entry) => entry.isDirectory() && entry.name !== "node_modules" && !entry.name.startsWith("."));
  if (dirs.length === 0) {
    return ["flat", []];
  }
  const firstDirPath = join59(skillsDir, dirs[0].name);
  const subEntries = await readdir20(firstDirPath, { withFileTypes: true });
  const subdirs = subEntries.filter((entry) => entry.isDirectory() && !entry.name.startsWith("."));
  if (subdirs.length > 0) {
    let skillLikeCount = 0;
    for (const subdir of subdirs.slice(0, 3)) {
      const subdirPath = join59(firstDirPath, subdir.name);
      const subdirFiles = await readdir20(subdirPath, { withFileTypes: true });
      const hasSkillMarker = subdirFiles.some((file) => file.isFile() && (file.name === "skill.md" || file.name === "README.md" || file.name === "readme.md" || file.name === "config.json" || file.name === "package.json"));
      if (hasSkillMarker) {
        skillLikeCount++;
      }
    }
    if (skillLikeCount > 0) {
      const skills = [];
      for (const dir of dirs) {
        const categoryPath = join59(skillsDir, dir.name);
        const skillDirs = await readdir20(categoryPath, { withFileTypes: true });
        skills.push(...skillDirs.filter((entry) => entry.isDirectory() && !entry.name.startsWith(".")).map((entry) => entry.name));
      }
      return ["categorized", skills];
    }
  }
  return ["flat", dirs.map((dir) => dir.name)];
}
async function findSkillPath(skillsDir, skillName) {
  const flatPath = join59(skillsDir, skillName);
  if (await import_fs_extra25.pathExists(flatPath)) {
    return { path: flatPath, category: undefined };
  }
  const entries = await readdir20(skillsDir, { withFileTypes: true });
  for (const entry of entries) {
    if (!entry.isDirectory() || entry.name.startsWith(".") || entry.name === "node_modules") {
      continue;
    }
    const categoryPath = join59(skillsDir, entry.name);
    const skillPath = join59(categoryPath, skillName);
    if (await import_fs_extra25.pathExists(skillPath)) {
      return { path: skillPath, category: entry.name };
    }
  }
  return null;
}

// src/domains/skills/skills-customization-scanner.ts
class SkillsCustomizationScanner {
  static async scanCustomizations(currentSkillsDir, baselineSkillsDir, manifest) {
    validatePath3(currentSkillsDir, "currentSkillsDir");
    if (baselineSkillsDir) {
      validatePath3(baselineSkillsDir, "baselineSkillsDir");
    }
    logger.debug("Scanning skills for customizations...");
    const customizations = [];
    const [, skillNames] = await scanSkillsDirectory(currentSkillsDir);
    for (const skillName of skillNames) {
      const skillInfo = await findSkillPath(currentSkillsDir, skillName);
      if (!skillInfo) {
        logger.warning(`Skill directory not found: ${skillName}`);
        continue;
      }
      const { path: skillPath, category: _category } = skillInfo;
      let baselineSkillPath;
      let hasBaseline = false;
      if (baselineSkillsDir) {
        hasBaseline = true;
        const baselineInfo = await findSkillPath(baselineSkillsDir, skillName);
        baselineSkillPath = baselineInfo?.path;
      }
      const isCustom = await isSkillCustomized(skillPath, skillName, baselineSkillPath, hasBaseline, manifest);
      if (isCustom) {
        const changes = baselineSkillPath ? await detectFileChanges(skillPath, baselineSkillPath) : undefined;
        customizations.push({
          skillName,
          path: skillPath,
          isCustomized: true,
          changes
        });
        logger.debug(`Detected customizations in skill: ${skillName}`);
      } else {
        customizations.push({
          skillName,
          path: skillPath,
          isCustomized: false
        });
      }
    }
    logger.info(`Found ${customizations.filter((c2) => c2.isCustomized).length} customized skills out of ${skillNames.length}`);
    return customizations;
  }
}

// src/domains/skills/skills-migrator.ts
class SkillsMigrator {
  static async migrate(newSkillsDir, currentSkillsDir, options) {
    validateMigrationPath(newSkillsDir, "newSkillsDir");
    validateMigrationPath(currentSkillsDir, "currentSkillsDir");
    logger.info("Starting skills migration process...");
    const result = {
      success: false,
      migratedSkills: [],
      preservedCustomizations: [],
      errors: []
    };
    try {
      const detection = await SkillsMigrationDetector.detectMigration(newSkillsDir, currentSkillsDir);
      if (detection.status === "not_needed") {
        logger.info("No migration needed");
        result.success = true;
        return result;
      }
      const customizations = await SkillsCustomizationScanner.scanCustomizations(currentSkillsDir, newSkillsDir);
      if (options.interactive) {
        const shouldMigrate = await SkillsMigrationPrompts.promptMigrationDecision(detection);
        if (!shouldMigrate) {
          logger.info("Migration cancelled by user");
          result.success = true;
          return result;
        }
        await SkillsMigrationPrompts.showMigrationPreview(detection.skillMappings, customizations);
        const shouldBackup = await SkillsMigrationPrompts.promptBackup();
        options.backup = shouldBackup;
        const customizationStrategy = await SkillsMigrationPrompts.promptCustomizationHandling(customizations.filter((c2) => c2.isCustomized));
        if (customizationStrategy === "skip") {
          detection.skillMappings = detection.skillMappings.filter((mapping) => {
            const customization = customizations.find((c2) => c2.skillName === mapping.skillName);
            return !customization?.isCustomized;
          });
        }
      }
      if (options.backup && !options.dryRun) {
        const claudeDir = join60(currentSkillsDir, "..");
        result.backupPath = await SkillsBackupManager.createBackup(currentSkillsDir, claudeDir);
        logger.success(`Backup created at: ${result.backupPath}`);
      }
      if (!options.dryRun) {
        const migrateResult = await executeMigration(detection.skillMappings, customizations, currentSkillsDir, options.interactive);
        result.migratedSkills = migrateResult.migrated;
        result.preservedCustomizations = migrateResult.preserved;
        result.errors = migrateResult.errors;
        try {
          const newManifest = await SkillsManifestManager.generateManifest(currentSkillsDir);
          await SkillsManifestManager.writeManifest(currentSkillsDir, newManifest);
          logger.success("Migration manifest generated");
        } catch (manifestError) {
          logger.error(`Failed to generate manifest: ${manifestError instanceof Error ? manifestError.message : "Unknown error"}`);
          result.errors.push({
            skill: "manifest",
            path: currentSkillsDir,
            error: manifestError instanceof Error ? manifestError.message : "Unknown error",
            fatal: false
          });
        }
      } else {
        logger.info("Dry run mode: No changes made");
      }
      if (options.interactive) {
        SkillsMigrationPrompts.showSummary(result.migratedSkills.length, result.preservedCustomizations.length, 0, result.errors.filter((e2) => e2.fatal).length);
      }
      result.success = result.errors.filter((e2) => e2.fatal).length === 0;
      if (result.success) {
        logger.success("Skills migration completed successfully");
      } else {
        logger.error("Skills migration completed with errors");
      }
      return result;
    } catch (error) {
      if (result.backupPath && !options.dryRun) {
        logger.error("Migration failed, attempting rollback...");
        try {
          await SkillsBackupManager.restoreBackup(result.backupPath, currentSkillsDir);
          logger.success("Rollback successful");
        } catch (rollbackError) {
          logger.error(`Rollback failed: ${rollbackError instanceof Error ? rollbackError.message : "Unknown error"}`);
        }
      }
      throw new SkillsMigrationError(`Migration failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
}

// src/commands/init/phases/migration-handler.ts
init_logger();
init_path_resolver();
var import_fs_extra26 = __toESM(require_lib(), 1);
async function handleMigration(ctx) {
  if (ctx.cancelled || !ctx.extractDir || !ctx.resolvedDir)
    return ctx;
  if (ctx.options.fresh) {
    logger.debug("Skipping skills migration (fresh installation)");
    return ctx;
  }
  const newSkillsDir = join61(ctx.extractDir, ".claude", "skills");
  const currentSkillsDir = PathResolver.buildSkillsPath(ctx.resolvedDir, ctx.options.global);
  if (!await import_fs_extra26.pathExists(newSkillsDir) || !await import_fs_extra26.pathExists(currentSkillsDir)) {
    return ctx;
  }
  logger.info("Checking for skills directory migration...");
  const migrationDetection = await SkillsMigrationDetector.detectMigration(newSkillsDir, currentSkillsDir);
  if (migrationDetection.status === "recommended" || migrationDetection.status === "required") {
    logger.info("Skills migration detected");
    const migrationResult = await SkillsMigrator.migrate(newSkillsDir, currentSkillsDir, {
      interactive: !ctx.isNonInteractive,
      backup: true,
      dryRun: false
    });
    if (!migrationResult.success) {
      logger.warning("Skills migration encountered errors but continuing with update");
    }
  } else {
    logger.debug("No skills migration needed");
  }
  return ctx;
}
// src/commands/init/phases/opencode-handler.ts
import { cp, readdir as readdir22, rm as rm5 } from "node:fs/promises";
import { join as join63 } from "node:path";

// src/services/transformers/opencode-path-transformer.ts
init_logger();
import { readFile as readFile21, readdir as readdir21, writeFile as writeFile17 } from "node:fs/promises";
import { platform as platform10 } from "node:os";
import { extname as extname2, join as join62 } from "node:path";
var IS_WINDOWS3 = platform10() === "win32";
function getOpenCodeGlobalPath() {
  return "$HOME/.config/opencode/";
}
var TRANSFORMABLE_EXTENSIONS2 = new Set([
  ".md",
  ".js",
  ".ts",
  ".json",
  ".sh",
  ".ps1",
  ".yaml",
  ".yml",
  ".toml"
]);
function transformOpenCodeContent(content) {
  let changes = 0;
  let transformed = content;
  const globalPath = getOpenCodeGlobalPath();
  transformed = transformed.replace(/\.\/\.opencode\//g, () => {
    changes++;
    return globalPath;
  });
  transformed = transformed.replace(/(["'`])\.opencode\//g, (_match, quote) => {
    changes++;
    return `${quote}${globalPath}`;
  });
  transformed = transformed.replace(/\(\.opencode\//g, () => {
    changes++;
    return `(${globalPath}`;
  });
  transformed = transformed.replace(/ \.opencode\//g, () => {
    changes++;
    return ` ${globalPath}`;
  });
  transformed = transformed.replace(/^\.opencode\//gm, () => {
    changes++;
    return globalPath;
  });
  transformed = transformed.replace(/: \.opencode\//g, () => {
    changes++;
    return `: ${globalPath}`;
  });
  transformed = transformed.replace(/:\.opencode\//g, () => {
    changes++;
    return `:${globalPath}`;
  });
  return { transformed, changes };
}
function shouldTransformFile2(filename) {
  const ext2 = extname2(filename).toLowerCase();
  return TRANSFORMABLE_EXTENSIONS2.has(ext2);
}
async function transformPathsForGlobalOpenCode(directory, options = {}) {
  let filesTransformed = 0;
  let totalChanges = 0;
  let filesSkipped = 0;
  async function processDirectory2(dir) {
    const entries = await readdir21(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = join62(dir, entry.name);
      if (entry.isDirectory()) {
        if (entry.name === "node_modules" || entry.name.startsWith(".")) {
          continue;
        }
        await processDirectory2(fullPath);
      } else if (entry.isFile() && shouldTransformFile2(entry.name)) {
        try {
          const content = await readFile21(fullPath, "utf-8");
          const { transformed, changes } = transformOpenCodeContent(content);
          if (changes > 0) {
            await writeFile17(fullPath, transformed, "utf-8");
            filesTransformed++;
            totalChanges += changes;
            if (options.verbose) {
              logger.verbose(`Transformed ${changes} OpenCode path(s) in ${fullPath}`);
            }
          }
        } catch (error) {
          filesSkipped++;
          if (options.verbose) {
            logger.verbose(`Skipping ${fullPath}: ${error instanceof Error ? error.message : "unknown error"}`);
          }
        }
      }
    }
  }
  await processDirectory2(directory);
  return { filesTransformed, totalChanges, filesSkipped };
}

// src/commands/init/phases/opencode-handler.ts
init_logger();
init_path_resolver();
var import_fs_extra27 = __toESM(require_lib(), 1);
async function handleOpenCode(ctx) {
  if (ctx.cancelled || !ctx.extractDir || !ctx.resolvedDir) {
    return ctx;
  }
  const openCodeSource = join63(ctx.extractDir, ".opencode");
  if (!await import_fs_extra27.pathExists(openCodeSource)) {
    logger.debug("No .opencode directory in archive, skipping");
    return ctx;
  }
  logger.info("Processing .opencode configuration...");
  if (ctx.options.global) {
    const targetDir = PathResolver.getOpenCodeDir(true);
    logger.verbose(`Relocating .opencode to ${targetDir}`);
    const transformResult = await transformPathsForGlobalOpenCode(openCodeSource, {
      verbose: logger.isVerbose()
    });
    if (transformResult.totalChanges > 0) {
      logger.success(`Transformed ${transformResult.totalChanges} OpenCode path(s) in ${transformResult.filesTransformed} file(s)`);
    }
    await import_fs_extra27.ensureDir(targetDir);
    const entries = await readdir22(openCodeSource, { withFileTypes: true });
    for (const entry of entries) {
      const sourcePath = join63(openCodeSource, entry.name);
      const targetPath = join63(targetDir, entry.name);
      if (await import_fs_extra27.pathExists(targetPath)) {
        if (!ctx.options.forceOverwrite) {
          logger.verbose(`Skipping existing: ${entry.name}`);
          continue;
        }
      }
      await cp(sourcePath, targetPath, { recursive: true });
      logger.verbose(`Copied: ${entry.name}`);
    }
    await rm5(openCodeSource, { recursive: true, force: true });
    logger.success(`OpenCode config installed to ${targetDir}`);
  } else {
    logger.debug("Local mode: .opencode will be placed at project root");
  }
  return ctx;
}
// src/domains/config/config-manager.ts
init_logger();
init_path_resolver();
init_types2();
import { existsSync as existsSync18 } from "node:fs";
import { mkdir as mkdir19, readFile as readFile22, rename as rename2, rm as rm6, writeFile as writeFile18 } from "node:fs/promises";
import { chmod as chmod2 } from "node:fs/promises";
import { platform as platform11 } from "node:os";
import { join as join64 } from "node:path";
var PROJECT_CONFIG_FILE = ".ck.json";

class ConfigManager {
  static config = null;
  static globalFlag = false;
  static getProjectConfigDir(projectDir, global3) {
    return global3 ? projectDir : join64(projectDir, ".claude");
  }
  static setGlobalFlag(global3) {
    ConfigManager.globalFlag = global3;
    ConfigManager.config = null;
  }
  static getGlobalFlag() {
    return ConfigManager.globalFlag;
  }
  static async load() {
    if (ConfigManager.config) {
      return ConfigManager.config;
    }
    const configFile = PathResolver.getConfigFile(ConfigManager.globalFlag);
    try {
      if (existsSync18(configFile)) {
        const content = await readFile22(configFile, "utf-8");
        const data = JSON.parse(content);
        ConfigManager.config = ConfigSchema.parse(data);
        logger.debug(`Config loaded from ${configFile}`);
        return ConfigManager.config;
      }
    } catch (error) {
      logger.warning(`Failed to load config: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
    ConfigManager.config = { defaults: {} };
    return ConfigManager.config;
  }
  static async save(config) {
    try {
      const validConfig = ConfigSchema.parse(config);
      const configDir = PathResolver.getConfigDir(ConfigManager.globalFlag);
      const configFile = PathResolver.getConfigFile(ConfigManager.globalFlag);
      if (!existsSync18(configDir)) {
        await mkdir19(configDir, { recursive: true });
        if (platform11() !== "win32") {
          await chmod2(configDir, 448);
        }
      }
      await writeFile18(configFile, JSON.stringify(validConfig, null, 2), "utf-8");
      if (platform11() !== "win32") {
        await chmod2(configFile, 384);
      }
      ConfigManager.config = validConfig;
      logger.debug(`Config saved to ${configFile}`);
    } catch (error) {
      throw new Error(`Failed to save config: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  static async get() {
    return ConfigManager.load();
  }
  static async set(key, value) {
    const config = await ConfigManager.load();
    const keys = key.split(".");
    let current = config;
    for (let i = 0;i < keys.length - 1; i++) {
      if (!(keys[i] in current)) {
        current[keys[i]] = {};
      }
      current = current[keys[i]];
    }
    current[keys[keys.length - 1]] = value;
    await ConfigManager.save(config);
  }
  static async loadProjectConfig(projectDir, global3 = false) {
    const configDir = ConfigManager.getProjectConfigDir(projectDir, global3);
    const configPath = join64(configDir, PROJECT_CONFIG_FILE);
    try {
      if (existsSync18(configPath)) {
        const content = await readFile22(configPath, "utf-8");
        const data = JSON.parse(content);
        const folders = FoldersConfigSchema.parse(data.paths || data);
        logger.debug(`Project config loaded from ${configPath}`);
        return folders;
      }
    } catch (error) {
      logger.warning(`Failed to load project config from ${configPath}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
    return null;
  }
  static async saveProjectConfig(projectDir, folders, global3 = false) {
    const configDir = ConfigManager.getProjectConfigDir(projectDir, global3);
    const configPath = join64(configDir, PROJECT_CONFIG_FILE);
    try {
      if (!existsSync18(configDir)) {
        await mkdir19(configDir, { recursive: true });
      }
      let existingConfig = {};
      if (existsSync18(configPath)) {
        try {
          const content = await readFile22(configPath, "utf-8");
          existingConfig = JSON.parse(content);
        } catch (error) {
          logger.debug(`Could not parse existing config, starting fresh: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      const validFolders = FoldersConfigSchema.parse(folders);
      const existingPaths = existingConfig.paths && typeof existingConfig.paths === "object" ? existingConfig.paths : {};
      const mergedConfig = {
        ...existingConfig,
        paths: {
          ...existingPaths,
          ...validFolders
        }
      };
      await writeFile18(configPath, JSON.stringify(mergedConfig, null, 2), "utf-8");
      logger.debug(`Project config saved to ${configPath}`);
    } catch (error) {
      throw new Error(`Failed to save project config: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  static async resolveFoldersConfig(projectDir, cliOptions, global3 = false) {
    const result = { ...DEFAULT_FOLDERS };
    const globalConfig = await ConfigManager.load();
    if (globalConfig.folders?.docs)
      result.docs = globalConfig.folders.docs;
    if (globalConfig.folders?.plans)
      result.plans = globalConfig.folders.plans;
    const projectConfig = await ConfigManager.loadProjectConfig(projectDir, global3);
    if (projectConfig?.docs)
      result.docs = projectConfig.docs;
    if (projectConfig?.plans)
      result.plans = projectConfig.plans;
    if (cliOptions?.docsDir)
      result.docs = cliOptions.docsDir;
    if (cliOptions?.plansDir)
      result.plans = cliOptions.plansDir;
    return result;
  }
  static projectConfigExists(projectDir, global3 = false) {
    const configDir = ConfigManager.getProjectConfigDir(projectDir, global3);
    return existsSync18(join64(configDir, PROJECT_CONFIG_FILE));
  }
  static async migrateNestedConfig(globalDir) {
    const correctPath = join64(globalDir, PROJECT_CONFIG_FILE);
    const incorrectPath = join64(globalDir, ".claude", PROJECT_CONFIG_FILE);
    if (existsSync18(correctPath)) {
      logger.debug("Config already exists at correct location, skipping migration");
      return false;
    }
    if (existsSync18(incorrectPath)) {
      try {
        logger.info("Migrating .ck.json from nested location to correct location...");
        await rename2(incorrectPath, correctPath);
        logger.success(`Migrated ${PROJECT_CONFIG_FILE} to ${correctPath}`);
        const nestedClaudeDir = join64(globalDir, ".claude");
        try {
          await rm6(nestedClaudeDir, { recursive: false });
          logger.debug("Removed empty nested .claude directory");
        } catch (rmError) {
          logger.debug(`Could not remove nested .claude dir (may contain other files): ${rmError instanceof Error ? rmError.message : "Unknown"}`);
        }
        return true;
      } catch (error) {
        logger.warning(`Failed to migrate config: ${error instanceof Error ? error.message : "Unknown error"}`);
        return false;
      }
    }
    return false;
  }
}

// src/commands/init/phases/options-resolver.ts
init_logger();
init_types2();
async function resolveOptions(ctx) {
  const explicitDir = ctx.rawOptions.dir !== undefined;
  const parsed = UpdateCommandOptionsSchema.parse(ctx.rawOptions);
  const validOptions = {
    kit: parsed.kit,
    dir: parsed.dir,
    release: parsed.release,
    beta: parsed.beta ?? false,
    global: parsed.global ?? false,
    yes: parsed.yes ?? false,
    fresh: parsed.fresh ?? false,
    refresh: parsed.refresh ?? false,
    exclude: parsed.exclude ?? [],
    only: parsed.only ?? [],
    docsDir: parsed.docsDir,
    plansDir: parsed.plansDir,
    installSkills: parsed.installSkills ?? false,
    withSudo: parsed.withSudo ?? false,
    skipSetup: parsed.skipSetup ?? false,
    forceOverwrite: parsed.forceOverwrite ?? false,
    forceOverwriteSettings: parsed.forceOverwriteSettings ?? false,
    dryRun: parsed.dryRun ?? false,
    prefix: parsed.prefix ?? false,
    sync: parsed.sync ?? false,
    useGit: parsed.useGit ?? false,
    archive: parsed.archive,
    kitPath: parsed.kitPath
  };
  ConfigManager.setGlobalFlag(validOptions.global);
  if (validOptions.global) {
    logger.info("Global mode enabled - using platform-specific user configuration");
  }
  const downloadMethods = [
    validOptions.useGit && "--use-git",
    validOptions.archive && "--archive",
    validOptions.kitPath && "--kit-path"
  ].filter(Boolean);
  if (downloadMethods.length > 1) {
    throw new Error(`Options ${downloadMethods.join(", ")} are mutually exclusive.

Please use only one download method.`);
  }
  if (validOptions.useGit && !validOptions.release) {
    throw new Error(`--use-git requires --release <tag> to specify the version.

` + `Git clone mode cannot list versions without GitHub API access.
` + "Example: ck init --use-git --release v2.1.0");
  }
  if (validOptions.useGit && validOptions.beta) {
    logger.warning("--beta flag is ignored when using --use-git (version already specified via --release)");
  }
  if (validOptions.fresh && validOptions.sync) {
    throw new Error(`--fresh and --sync are mutually exclusive.

` + `--fresh: Removes all ClaudeKit files and reinstalls from scratch
` + `--sync: Updates to match the version in metadata.json

` + "Choose one approach.");
  }
  const isNonInteractive2 = validOptions.yes || !process.stdin.isTTY || process.env.CI === "true" || process.env.NON_INTERACTIVE === "true";
  if (validOptions.yes) {
    logger.info("Running in non-interactive mode (--yes flag)");
  }
  return {
    ...ctx,
    options: validOptions,
    explicitDir,
    isNonInteractive: isNonInteractive2
  };
}
// src/commands/init/phases/post-install-handler.ts
import { join as join65 } from "node:path";
init_logger();
init_path_resolver();
var import_fs_extra28 = __toESM(require_lib(), 1);
async function handlePostInstall(ctx) {
  if (ctx.cancelled || !ctx.extractDir || !ctx.resolvedDir || !ctx.claudeDir) {
    return ctx;
  }
  if (ctx.options.global) {
    const claudeMdSource = join65(ctx.extractDir, "CLAUDE.md");
    const claudeMdDest = join65(ctx.resolvedDir, "CLAUDE.md");
    if (await import_fs_extra28.pathExists(claudeMdSource)) {
      if (!await import_fs_extra28.pathExists(claudeMdDest)) {
        await import_fs_extra28.copy(claudeMdSource, claudeMdDest);
        logger.success("Copied CLAUDE.md to global directory");
      } else {
        logger.debug("CLAUDE.md already exists in global directory (preserved)");
      }
    }
  }
  let installSkills = ctx.options.installSkills;
  if (!ctx.isNonInteractive && !installSkills) {
    installSkills = await ctx.prompts.promptSkillsInstallation();
  }
  if (installSkills) {
    const { handleSkillsInstallation: handleSkillsInstallation2 } = await Promise.resolve().then(() => (init_package_installer(), exports_package_installer));
    const skillsDir = PathResolver.buildSkillsPath(ctx.resolvedDir, ctx.options.global);
    await handleSkillsInstallation2(skillsDir, {
      skipConfirm: ctx.isNonInteractive,
      withSudo: ctx.options.withSudo
    });
  }
  if (!ctx.isNonInteractive) {
    const { isGeminiInstalled: isGeminiInstalled2 } = await Promise.resolve().then(() => (init_package_installer(), exports_package_installer));
    const { checkExistingGeminiConfig: checkExistingGeminiConfig2, findMcpConfigPath: findMcpConfigPath2, processGeminiMcpLinking: processGeminiMcpLinking2 } = await Promise.resolve().then(() => (init_gemini_mcp_linker(), exports_gemini_mcp_linker));
    const geminiInstalled = await isGeminiInstalled2();
    const existingConfig = checkExistingGeminiConfig2(ctx.resolvedDir, ctx.options.global);
    const mcpConfigPath = findMcpConfigPath2(ctx.resolvedDir);
    const mcpConfigExists = mcpConfigPath !== null;
    if (geminiInstalled && !existingConfig.exists && mcpConfigExists) {
      const geminiPath = ctx.options.global ? "~/.gemini/settings.json" : ".gemini/settings.json";
      const mcpPath = ctx.options.global ? "~/.claude/.mcp.json" : ".mcp.json";
      const promptMessage = [
        "Gemini CLI detected. Set up MCP integration?",
        `   Creates ${geminiPath} symlink to ${mcpPath}`,
        "   Gemini CLI will share MCP servers with Claude Code"
      ].join(`
`);
      const shouldSetupGemini = await ctx.prompts.confirm(promptMessage);
      if (shouldSetupGemini) {
        await processGeminiMcpLinking2(ctx.resolvedDir, {
          isGlobal: ctx.options.global
        });
      }
    }
  }
  if (!ctx.options.skipSetup) {
    await promptSetupWizardIfNeeded({
      envPath: join65(ctx.claudeDir, ".env"),
      claudeDir: ctx.claudeDir,
      isGlobal: ctx.options.global,
      isNonInteractive: ctx.isNonInteractive,
      prompts: ctx.prompts
    });
  }
  return {
    ...ctx,
    installSkills
  };
}
// src/commands/init/phases/selection-handler.ts
import { mkdir as mkdir20 } from "node:fs/promises";
import { join as join67, resolve as resolve8 } from "node:path";
init_github_client();

// src/domains/github/kit-access-checker.ts
init_logger();
init_types2();
init_github_client();
async function detectAccessibleKits() {
  const spinner = createSpinner("Checking kit access...").start();
  const github = new GitHubClient;
  const results = await Promise.all(Object.entries(AVAILABLE_KITS).map(async ([type, config]) => {
    try {
      await github.checkAccess(config);
      logger.debug(`Access confirmed: ${type}`);
      return type;
    } catch {
      logger.debug(`No access to ${type}`);
      return null;
    }
  }));
  const accessible = results.filter((kit) => kit !== null);
  if (accessible.length === 0) {
    spinner.fail("No kit access found");
  } else {
    spinner.succeed(`Access verified: ${accessible.join(", ")}`);
  }
  return accessible;
}

// src/domains/github/preflight-checker.ts
init_logger();
import { exec as exec7 } from "node:child_process";
import { promisify as promisify7 } from "node:util";
var execAsync7 = promisify7(exec7);
function createSuccessfulPreflightResult() {
  return {
    success: true,
    ghInstalled: true,
    ghVersion: MIN_GH_CLI_VERSION,
    ghVersionOk: true,
    ghAuthenticated: true,
    errorLines: []
  };
}
function isTimeoutError(error) {
  if (error instanceof Error) {
    const msg = error.message.toLowerCase();
    return msg.includes("timeout") || msg.includes("timed out") || msg.includes("etimedout");
  }
  return false;
}
async function runPreflightChecks() {
  logger.debug("Running GitHub CLI pre-flight checks");
  if (shouldSkipExpensiveOperations()) {
    logger.debug("Skipping preflight checks in test/CI environment");
    return createSuccessfulPreflightResult();
  }
  const result = {
    success: false,
    ghInstalled: false,
    ghVersion: null,
    ghVersionOk: false,
    ghAuthenticated: false,
    errorLines: []
  };
  try {
    const { stdout: stdout2 } = await execAsync7("gh --version", { timeout: GH_COMMAND_TIMEOUT_MS });
    const match2 = stdout2.match(/(\d+\.\d+\.\d+)/);
    if (!match2) {
      logger.debug(`GitHub CLI version not detected from output: ${stdout2.trim()}`);
      result.ghInstalled = true;
      result.errorLines.push(" GitHub CLI installed but version could not be detected");
      result.errorLines.push(`  Output: ${stdout2.trim().slice(0, 100)}`);
      result.errorLines.push("  Try running: gh --version");
      return result;
    }
    result.ghVersion = match2[1];
    result.ghInstalled = true;
    logger.debug(`GitHub CLI detected: v${result.ghVersion}`);
  } catch (error) {
    if (isTimeoutError(error)) {
      logger.debug("GitHub CLI check timed out");
      result.errorLines.push(" GitHub CLI check timed out");
      result.errorLines.push("  This may indicate a slow system or network issue");
      result.errorLines.push("  Try running: gh --version");
    } else {
      logger.debug(`GitHub CLI not found: ${error instanceof Error ? error.message : "unknown error"}`);
      result.errorLines.push(" GitHub CLI not installed");
      result.errorLines.push("  Install from: https://cli.github.com");
      result.errorLines.push("");
      result.errorLines.push("After install: gh auth login -h github.com");
    }
    return result;
  }
  if (result.ghVersion) {
    const comparison = compareVersions(result.ghVersion, MIN_GH_CLI_VERSION);
    result.ghVersionOk = comparison >= 0;
    if (!result.ghVersionOk) {
      logger.debug(`GitHub CLI version ${result.ghVersion} is below minimum ${MIN_GH_CLI_VERSION}`);
      result.errorLines.push(...getGhUpgradeInstructions(result.ghVersion));
      return result;
    }
  }
  try {
    await execAsync7("gh auth status -h github.com", {
      timeout: GH_COMMAND_TIMEOUT_MS,
      env: { ...process.env, GH_NO_UPDATE_NOTIFIER: "1" }
    });
    result.ghAuthenticated = true;
    logger.debug("GitHub CLI authenticated for github.com");
  } catch (error) {
    if (isTimeoutError(error)) {
      logger.debug("GitHub CLI auth check timed out");
      result.errorLines.push(" GitHub CLI auth check timed out");
      result.errorLines.push("  This may indicate a network issue");
      result.errorLines.push("  Try running: gh auth status -h github.com");
    } else {
      logger.debug(`GitHub CLI not authenticated: ${error instanceof Error ? error.message : "unknown error"}`);
      result.errorLines.push(" GitHub CLI not authenticated");
      result.errorLines.push("  Run: gh auth login -h github.com");
    }
    return result;
  }
  result.success = true;
  logger.debug("All GitHub CLI pre-flight checks passed");
  return result;
}

// src/domains/installation/fresh-installer.ts
import { existsSync as existsSync19, readdirSync, rmSync as rmSync2, rmdirSync, unlinkSync as unlinkSync3 } from "node:fs";
import { dirname as dirname9, join as join66, resolve as resolve7 } from "node:path";
init_logger();
var import_fs_extra29 = __toESM(require_lib(), 1);
var CLAUDEKIT_SUBDIRECTORIES = ["commands", "agents", "skills", "rules", "hooks"];
async function analyzeFreshInstallation(claudeDir) {
  const metadata = await readManifest(claudeDir);
  if (!metadata) {
    return {
      ckFiles: [],
      ckModifiedFiles: [],
      userFiles: [],
      hasMetadata: false
    };
  }
  const allFiles = getAllTrackedFiles(metadata);
  if (allFiles.length === 0) {
    return {
      ckFiles: [],
      ckModifiedFiles: [],
      userFiles: [],
      hasMetadata: false
    };
  }
  const ckFiles = [];
  const ckModifiedFiles = [];
  const userFiles = [];
  for (const file of allFiles) {
    switch (file.ownership) {
      case "ck":
        ckFiles.push(file);
        break;
      case "ck-modified":
        ckModifiedFiles.push(file);
        break;
      case "user":
        userFiles.push(file);
        break;
    }
  }
  return {
    ckFiles,
    ckModifiedFiles,
    userFiles,
    hasMetadata: true
  };
}
function cleanupEmptyDirectories(filePath, claudeDir) {
  const normalizedClaudeDir = resolve7(claudeDir);
  let currentDir = resolve7(dirname9(filePath));
  while (currentDir !== normalizedClaudeDir && currentDir.startsWith(normalizedClaudeDir)) {
    try {
      const entries = readdirSync(currentDir);
      if (entries.length === 0) {
        rmdirSync(currentDir);
        logger.debug(`Removed empty directory: ${currentDir}`);
        currentDir = resolve7(dirname9(currentDir));
      } else {
        break;
      }
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      logger.debug(`Could not remove directory ${currentDir}: ${errorMsg}`);
      break;
    }
  }
}
async function removeFilesByOwnership(claudeDir, analysis, includeModified) {
  const removedFiles = [];
  const preservedFiles = [];
  const filesToRemove = includeModified ? [...analysis.ckFiles, ...analysis.ckModifiedFiles] : analysis.ckFiles;
  const filesToPreserve = includeModified ? analysis.userFiles : [...analysis.ckModifiedFiles, ...analysis.userFiles];
  for (const file of filesToRemove) {
    const fullPath = join66(claudeDir, file.path);
    try {
      if (existsSync19(fullPath)) {
        unlinkSync3(fullPath);
        removedFiles.push(file.path);
        logger.debug(`Removed: ${file.path}`);
        cleanupEmptyDirectories(fullPath, claudeDir);
      }
    } catch (error) {
      logger.debug(`Failed to remove ${file.path}: ${error}`);
    }
  }
  for (const file of filesToPreserve) {
    preservedFiles.push(file.path);
  }
  await updateMetadataAfterFresh(claudeDir, removedFiles);
  return {
    success: true,
    removedCount: removedFiles.length,
    preservedCount: preservedFiles.length,
    removedFiles,
    preservedFiles
  };
}
async function updateMetadataAfterFresh(claudeDir, removedFiles) {
  const metadataPath = join66(claudeDir, "metadata.json");
  if (!await import_fs_extra29.pathExists(metadataPath)) {
    return;
  }
  let content;
  try {
    content = await import_fs_extra29.readFile(metadataPath, "utf-8");
  } catch (readError) {
    logger.warning(`Failed to read metadata.json: ${readError instanceof Error ? readError.message : String(readError)}`);
    return;
  }
  let metadata;
  try {
    metadata = JSON.parse(content);
  } catch (parseError) {
    logger.warning(`Failed to parse metadata.json: ${parseError instanceof Error ? parseError.message : String(parseError)}`);
    logger.info("Recommendation: Run 'ck init' to rebuild metadata");
    return;
  }
  const removedSet = new Set(removedFiles);
  if (metadata.kits) {
    for (const kitName of Object.keys(metadata.kits)) {
      const kit = metadata.kits[kitName];
      if (kit?.files) {
        kit.files = kit.files.filter((f3) => !removedSet.has(f3.path));
      }
    }
  }
  if (metadata.files) {
    metadata.files = metadata.files.filter((f3) => !removedSet.has(f3.path));
  }
  try {
    await import_fs_extra29.writeFile(metadataPath, JSON.stringify(metadata, null, 2));
    logger.debug(`Updated metadata.json, removed ${removedFiles.length} file entries`);
  } catch (writeError) {
    logger.warning(`Failed to write metadata.json: ${writeError instanceof Error ? writeError.message : String(writeError)}`);
    logger.info("Recommendation: Check file permissions and run 'ck init' to rebuild metadata");
  }
}
async function removeSubdirectoriesFallback(claudeDir) {
  const removedFiles = [];
  let removedDirCount = 0;
  for (const subdir of CLAUDEKIT_SUBDIRECTORIES) {
    const subdirPath = join66(claudeDir, subdir);
    if (await import_fs_extra29.pathExists(subdirPath)) {
      rmSync2(subdirPath, { recursive: true, force: true });
      removedDirCount++;
      removedFiles.push(`${subdir}/ (entire directory)`);
      logger.debug(`Removed subdirectory: ${subdir}/`);
    }
  }
  const metadataPath = join66(claudeDir, "metadata.json");
  if (await import_fs_extra29.pathExists(metadataPath)) {
    unlinkSync3(metadataPath);
    removedFiles.push("metadata.json");
  }
  return {
    success: true,
    removedCount: removedDirCount,
    preservedCount: 0,
    removedFiles,
    preservedFiles: []
  };
}
async function handleFreshInstallation(claudeDir, prompts) {
  if (!await import_fs_extra29.pathExists(claudeDir)) {
    logger.info(".claude directory does not exist, proceeding with fresh installation");
    return true;
  }
  const analysis = await analyzeFreshInstallation(claudeDir);
  const confirmed = await prompts.promptFreshConfirmation(claudeDir, analysis);
  if (!confirmed) {
    logger.info("Fresh installation cancelled");
    return false;
  }
  const spinner = createSpinner("Removing ClaudeKit files...").start();
  try {
    let result;
    if (analysis.hasMetadata && (analysis.ckFiles.length > 0 || analysis.ckModifiedFiles.length > 0)) {
      result = await removeFilesByOwnership(claudeDir, analysis, true);
      spinner.succeed(`Removed ${result.removedCount} CK files, preserved ${result.preservedCount} user files`);
    } else {
      result = await removeSubdirectoriesFallback(claudeDir);
      spinner.succeed(`Removed ${result.removedCount} ClaudeKit directories`);
    }
    if (result.preservedCount > 0) {
      logger.verbose(`Preserved user files: ${result.preservedFiles.slice(0, 5).join(", ")}${result.preservedFiles.length > 5 ? ` and ${result.preservedFiles.length - 5} more` : ""}`);
    }
    return true;
  } catch (error) {
    spinner.fail("Failed to remove ClaudeKit files");
    throw new Error(`Failed to remove files: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}

// src/commands/init/phases/selection-handler.ts
init_logger();
init_path_resolver();
init_types2();
var import_fs_extra30 = __toESM(require_lib(), 1);

// src/commands/init/types.ts
function isSyncContext(ctx) {
  return "syncInProgress" in ctx && ctx.syncInProgress === true && "syncTrackedFiles" in ctx && Array.isArray(ctx.syncTrackedFiles);
}

// src/commands/init/phases/selection-handler.ts
async function handleSelection(ctx) {
  if (ctx.cancelled)
    return ctx;
  if (isSyncContext(ctx) && ctx.kitType && ctx.resolvedDir && ctx.selectedVersion) {
    const kit2 = AVAILABLE_KITS[ctx.kitType];
    const github2 = new GitHubClient;
    logger.info(`Sync mode: using ${kit2.name} version ${ctx.selectedVersion}`);
    const release2 = await github2.getReleaseByTag(kit2, ctx.selectedVersion);
    return {
      ...ctx,
      kit: kit2,
      release: release2
    };
  }
  const downloadMethods = [];
  if (ctx.options.useGit)
    downloadMethods.push("--use-git");
  if (ctx.options.archive)
    downloadMethods.push("--archive");
  if (ctx.options.kitPath)
    downloadMethods.push("--kit-path");
  if (downloadMethods.length > 1) {
    logger.error(`Mutually exclusive download methods: ${downloadMethods.join(", ")}`);
    logger.info("Use only one of: --use-git, --archive, or --kit-path");
    return { ...ctx, cancelled: true };
  }
  const config = await ConfigManager.get();
  let accessibleKits;
  if (!ctx.options.useGit && !ctx.options.kitPath && !ctx.options.archive) {
    const preflight = await runPreflightChecks();
    if (!preflight.success) {
      for (const line of preflight.errorLines) {
        if (line.startsWith("")) {
          logger.error(line);
        } else {
          logger.info(line);
        }
      }
      logger.info("");
      logger.info("Full diagnostics: ck doctor");
      return { ...ctx, cancelled: true };
    }
    accessibleKits = await detectAccessibleKits();
    if (accessibleKits.length === 0) {
      logger.error("No ClaudeKit repository access found.");
      logger.info("Check email for GitHub invitation, or purchase at https://claudekit.cc");
      logger.info("");
      logger.info("Full diagnostics: ck doctor");
      return { ...ctx, cancelled: true };
    }
  }
  let kitType;
  let pendingKits;
  const kitOption = ctx.options.kit || config.defaults?.kit;
  if (kitOption) {
    const allKitTypes = Object.keys(AVAILABLE_KITS);
    if (kitOption === "all") {
      const kitsToInstall = accessibleKits ?? allKitTypes;
      if (kitsToInstall.length === 0) {
        logger.error("No kits accessible for installation");
        return { ...ctx, cancelled: true };
      }
      kitType = kitsToInstall[0];
      if (kitsToInstall.length > 1) {
        pendingKits = kitsToInstall.slice(1);
      }
      logger.info(`Installing all accessible kits: ${kitsToInstall.map((k2) => AVAILABLE_KITS[k2].name).join(", ")}`);
    } else if (kitOption.includes(",")) {
      const rawKits = kitOption.split(",").map((k2) => k2.trim());
      const seen = new Set;
      const requestedKits = [];
      const invalidKits = [];
      for (const kit2 of rawKits) {
        if (seen.has(kit2))
          continue;
        seen.add(kit2);
        if (isValidKitType(kit2)) {
          requestedKits.push(kit2);
        } else {
          invalidKits.push(kit2);
        }
      }
      if (invalidKits.length > 0) {
        logger.error(`Invalid kit(s): ${invalidKits.join(", ")}`);
        logger.info(`Valid kits: ${allKitTypes.join(", ")}`);
        return { ...ctx, cancelled: true };
      }
      if (requestedKits.length === 0) {
        logger.error("No valid kits specified");
        return { ...ctx, cancelled: true };
      }
      if (accessibleKits) {
        const noAccessKits = requestedKits.filter((k2) => !accessibleKits.includes(k2));
        if (noAccessKits.length > 0) {
          logger.error(`No access to: ${noAccessKits.map((k2) => AVAILABLE_KITS[k2].name).join(", ")}`);
          logger.info("Purchase at https://claudekit.cc");
          return { ...ctx, cancelled: true };
        }
      }
      kitType = requestedKits[0];
      if (requestedKits.length > 1) {
        pendingKits = requestedKits.slice(1);
      }
      logger.info(`Installing kits: ${requestedKits.map((k2) => AVAILABLE_KITS[k2].name).join(", ")}`);
    } else {
      if (!isValidKitType(kitOption)) {
        logger.error(`Invalid kit: ${kitOption}`);
        logger.info(`Valid kits: ${allKitTypes.join(", ")}`);
        return { ...ctx, cancelled: true };
      }
      kitType = kitOption;
      if (accessibleKits && !accessibleKits.includes(kitType)) {
        logger.error(`No access to ${AVAILABLE_KITS[kitType].name}`);
        logger.info("Purchase at https://claudekit.cc");
        return { ...ctx, cancelled: true };
      }
    }
  }
  if (!kitType) {
    if (ctx.isNonInteractive) {
      if (!accessibleKits || accessibleKits.length === 0) {
        throw new Error("Kit must be specified via --kit flag in non-interactive mode (no accessible kits detected)");
      }
      kitType = accessibleKits[0];
      logger.info(`Auto-selected: ${AVAILABLE_KITS[kitType].name}`);
    } else if (accessibleKits?.length === 1) {
      kitType = accessibleKits[0];
      logger.info(`Using ${AVAILABLE_KITS[kitType].name} (only accessible kit)`);
    } else if (accessibleKits && accessibleKits.length > 1) {
      const selectedKits = await ctx.prompts.selectKits(accessibleKits);
      if (selectedKits.length === 0) {
        throw new Error("At least one kit must be selected");
      }
      kitType = selectedKits[0];
      if (selectedKits.length > 1) {
        pendingKits = selectedKits.slice(1);
        logger.success(`Selected ${selectedKits.length} kits: ${selectedKits.map((k2) => AVAILABLE_KITS[k2].name).join(", ")}`);
      }
    } else {
      kitType = await ctx.prompts.selectKit(undefined, accessibleKits);
    }
  }
  const kit = AVAILABLE_KITS[kitType];
  logger.info(`Selected kit: ${kit.name}`);
  let targetDir;
  if (ctx.explicitDir) {
    targetDir = ctx.options.dir;
    logger.info(`Using explicit directory: ${targetDir}`);
  } else if (ctx.options.global) {
    targetDir = PathResolver.getGlobalKitDir();
    logger.info(`Using global kit directory: ${targetDir}`);
  } else {
    targetDir = config.defaults?.dir || ".";
    if (!config.defaults?.dir) {
      if (ctx.isNonInteractive) {
        logger.info("Using current directory as target");
      } else {
        targetDir = await ctx.prompts.getDirectory(targetDir);
      }
    }
  }
  const resolvedDir = resolve8(targetDir);
  logger.info(`Target directory: ${resolvedDir}`);
  if (!ctx.options.global && PathResolver.isLocalSameAsGlobal(resolvedDir)) {
    logger.warning("You're at HOME directory. Installing here modifies your GLOBAL ClaudeKit.");
    if (!ctx.isNonInteractive) {
      const choice = await ctx.prompts.selectScope();
      if (choice === "cancel") {
        return { ...ctx, cancelled: true };
      }
      if (choice === "global") {
        logger.info("Proceeding with global installation");
      }
      if (choice === "different") {
        logger.info("Please run 'ck init' from a project directory instead.");
        return { ...ctx, cancelled: true };
      }
    } else {
      logger.error("Cannot use local installation at HOME directory.");
      logger.info("Use -g/--global flag or run from a project directory.");
      return { ...ctx, cancelled: true };
    }
  }
  if (!await import_fs_extra30.pathExists(resolvedDir)) {
    if (ctx.options.global) {
      await mkdir20(resolvedDir, { recursive: true });
      logger.info(`Created global directory: ${resolvedDir}`);
    } else {
      logger.error(`Directory does not exist: ${resolvedDir}`);
      logger.info('Use "ck new" to create a new project');
      return { ...ctx, cancelled: true };
    }
  }
  if (!ctx.options.fresh) {
    const prefix = PathResolver.getPathPrefix(ctx.options.global);
    const claudeDir = prefix ? join67(resolvedDir, prefix) : resolvedDir;
    try {
      const existingMetadata = await readManifest(claudeDir);
      if (existingMetadata?.kits) {
        const existingKitTypes = Object.keys(existingMetadata.kits);
        const otherKits = existingKitTypes.filter((k2) => k2 !== kitType);
        if (otherKits.length > 0) {
          const existingKitsDisplay = otherKits.map((k2) => `${k2}@${existingMetadata.kits?.[k2]?.version || "unknown"}`).join(", ");
          if (!ctx.options.yes && !ctx.isNonInteractive) {
            try {
              const confirmAdd = await ctx.prompts.confirm(`${existingKitsDisplay} already installed. Add ${kit.name} alongside?`);
              if (!confirmAdd) {
                logger.warning("Multi-kit installation cancelled by user");
                return { ...ctx, cancelled: true };
              }
              logger.info(`Adding ${kit.name} alongside existing kit(s)`);
            } catch {
              logger.warning("Prompt cancelled or interrupted");
              return { ...ctx, cancelled: true };
            }
          } else {
            const reason = ctx.options.yes ? "(--yes flag)" : "(non-interactive mode)";
            logger.info(`Adding ${kit.name} alongside ${existingKitsDisplay} ${reason}`);
          }
        }
      }
    } catch (error) {
      logger.debug(`Metadata read skipped: ${error instanceof Error ? error.message : "unknown error"}`);
    }
  }
  if (ctx.options.fresh) {
    const prefix = PathResolver.getPathPrefix(ctx.options.global);
    const claudeDir = prefix ? join67(resolvedDir, prefix) : resolvedDir;
    const canProceed = await handleFreshInstallation(claudeDir, ctx.prompts);
    if (!canProceed) {
      return { ...ctx, cancelled: true };
    }
  }
  const isOfflineMode = !!(ctx.options.kitPath || ctx.options.archive);
  const github = isOfflineMode ? null : new GitHubClient;
  let selectedVersion = ctx.options.release;
  if (!selectedVersion && ctx.isNonInteractive && !ctx.options.yes && !isOfflineMode) {
    throw new Error("Non-interactive mode requires either: --release <tag> OR --yes (uses latest)");
  }
  if (!selectedVersion && ctx.options.yes && !isOfflineMode) {
    logger.info("Using latest stable version (--yes flag)");
  }
  if (!selectedVersion && !ctx.isNonInteractive && !isOfflineMode) {
    logger.info("Fetching available versions...");
    let currentVersion = null;
    try {
      const metadataPath = ctx.options.global ? join67(PathResolver.getGlobalKitDir(), "metadata.json") : join67(resolvedDir, ".claude", "metadata.json");
      const metadata = await readClaudeKitMetadata(metadataPath);
      currentVersion = metadata?.version || null;
      if (currentVersion) {
        logger.debug(`Current installed version: ${currentVersion}`);
      }
    } catch {}
    try {
      const versionResult = await ctx.prompts.selectVersionEnhanced({
        kit,
        includePrereleases: ctx.options.beta,
        limit: 10,
        allowManualEntry: true,
        forceRefresh: ctx.options.refresh,
        currentVersion
      });
      if (!versionResult) {
        logger.warning("Version selection cancelled by user");
        return { ...ctx, cancelled: true };
      }
      selectedVersion = versionResult;
      logger.success(`Selected version: ${selectedVersion}`);
    } catch (error) {
      logger.error("Failed to fetch versions, using latest release");
      logger.debug(`Version selection error: ${error.message}`);
      selectedVersion = undefined;
    }
  }
  let release;
  if (isOfflineMode) {
    release = undefined;
    logger.verbose("Offline mode - skipping release fetch", {
      kitPath: ctx.options.kitPath,
      archive: ctx.options.archive
    });
  } else if (ctx.options.useGit && selectedVersion) {
    release = {
      id: 0,
      tag_name: selectedVersion,
      name: selectedVersion,
      draft: false,
      prerelease: selectedVersion.includes("-"),
      tarball_url: `https://github.com/${kit.owner}/${kit.repo}/archive/refs/tags/${selectedVersion}.tar.gz`,
      zipball_url: `https://github.com/${kit.owner}/${kit.repo}/archive/refs/tags/${selectedVersion}.zip`,
      assets: []
    };
    logger.verbose("Using git clone mode with tag", { tag: selectedVersion });
  } else if (selectedVersion && github) {
    release = await github.getReleaseByTag(kit, selectedVersion);
  } else if (github) {
    if (ctx.options.beta) {
      logger.info("Fetching latest beta release...");
    } else {
      logger.info("Fetching latest release...");
    }
    release = await github.getLatestRelease(kit, ctx.options.beta);
    if (release.prerelease) {
      logger.success(`Found beta: ${release.tag_name}`);
    } else {
      logger.success(`Found: ${release.tag_name}`);
    }
  }
  return {
    ...ctx,
    kit,
    kitType,
    resolvedDir,
    release,
    selectedVersion,
    pendingKits,
    accessibleKits
  };
}
// src/commands/init/phases/sync-handler.ts
import { copyFile as copyFile6, mkdir as mkdir21, open, rename as rename3, stat as stat10, unlink as unlink7, writeFile as writeFile20 } from "node:fs/promises";
import { dirname as dirname10, join as join68, resolve as resolve9 } from "node:path";
init_logger();
init_path_resolver();
var import_fs_extra31 = __toESM(require_lib(), 1);
var import_picocolors19 = __toESM(require_picocolors(), 1);
async function handleSync(ctx) {
  if (!ctx.options.sync) {
    return ctx;
  }
  const resolvedDir = ctx.options.global ? PathResolver.getGlobalKitDir() : resolve9(ctx.options.dir || ".");
  const claudeDir = ctx.options.global ? resolvedDir : join68(resolvedDir, ".claude");
  if (!await import_fs_extra31.pathExists(claudeDir)) {
    logger.error("Cannot sync: no .claude directory found");
    ctx.prompts.note("Run 'ck init' without --sync to install first.", "No Installation Found");
    return { ...ctx, cancelled: true };
  }
  const metadataPath = join68(claudeDir, "metadata.json");
  if (!await import_fs_extra31.pathExists(metadataPath)) {
    logger.error("Cannot sync: no metadata.json found");
    ctx.prompts.note(`Your installation may be from an older version.
Run 'ck init' to update.`, "Legacy Installation");
    return { ...ctx, cancelled: true };
  }
  let kitType = ctx.options.kit;
  if (!kitType) {
    const engineerMeta = await readKitManifest(claudeDir, "engineer");
    const marketingMeta = await readKitManifest(claudeDir, "marketing");
    if (engineerMeta && marketingMeta) {
      if (!ctx.isNonInteractive) {
        kitType = await ctx.prompts.selectKit();
      } else {
        logger.error("Multiple kits installed. Please specify --kit engineer or --kit marketing");
        return { ...ctx, cancelled: true };
      }
    } else if (engineerMeta) {
      kitType = "engineer";
    } else if (marketingMeta) {
      kitType = "marketing";
    } else {
      logger.error("Cannot sync: no kit installation found in metadata");
      return { ...ctx, cancelled: true };
    }
  }
  const kitMetadata = await readKitManifest(claudeDir, kitType);
  if (!kitMetadata) {
    logger.error(`Cannot sync: ${kitType} kit not installed`);
    return { ...ctx, cancelled: true };
  }
  if (typeof kitMetadata.version !== "string" || !kitMetadata.version) {
    logger.error("Cannot sync: invalid metadata (missing version)");
    return { ...ctx, cancelled: true };
  }
  if (!Array.isArray(kitMetadata.files)) {
    logger.error("Cannot sync: invalid metadata (missing files array)");
    return { ...ctx, cancelled: true };
  }
  const currentVersion = kitMetadata.version;
  const trackedFiles = kitMetadata.files || [];
  if (trackedFiles.length === 0) {
    logger.warning("No tracked files found in metadata");
    ctx.prompts.note(`Your installation may be from an older version without file tracking.
Run 'ck init' to update.`, "Legacy Installation");
    return { ...ctx, cancelled: true };
  }
  logger.info("Checking for config updates...");
  const updateResult = await ConfigVersionChecker.checkForUpdates(kitType, currentVersion, ctx.options.global);
  if (!updateResult.hasUpdates) {
    ctx.prompts.note(`You're on the latest version (${updateResult.currentVersion})`, "Already Up to Date");
    return { ...ctx, cancelled: true };
  }
  displayConfigUpdateNotification(updateResult.currentVersion, updateResult.latestVersion, ctx.options.global);
  if (!ctx.isNonInteractive) {
    const proceed = await ctx.prompts.confirm("Proceed with config sync?");
    if (!proceed) {
      return { ...ctx, cancelled: true };
    }
  }
  const syncCtx = {
    ...ctx,
    resolvedDir,
    claudeDir,
    kitType,
    selectedVersion: `v${updateResult.latestVersion}`,
    syncInProgress: true,
    syncTrackedFiles: trackedFiles,
    syncCurrentVersion: currentVersion,
    syncLatestVersion: updateResult.latestVersion
  };
  return syncCtx;
}
var DEFAULT_LOCK_TIMEOUT_MS = 30000;
var MIN_LOCK_TIMEOUT_MS = 5000;
var MAX_LOCK_TIMEOUT_MS = 5 * 60 * 1000;
function getLockTimeout() {
  const envValue = process.env.CK_SYNC_LOCK_TIMEOUT;
  if (!envValue)
    return DEFAULT_LOCK_TIMEOUT_MS;
  const parsed = Number.parseInt(envValue, 10);
  if (Number.isNaN(parsed) || parsed < 0) {
    logger.warning(`Invalid CK_SYNC_LOCK_TIMEOUT "${envValue}", using default (30s)`);
    return DEFAULT_LOCK_TIMEOUT_MS;
  }
  const timeoutMs = parsed * 1000;
  if (timeoutMs < MIN_LOCK_TIMEOUT_MS) {
    logger.warning(`CK_SYNC_LOCK_TIMEOUT too low (${parsed}s), using minimum (5s)`);
    return MIN_LOCK_TIMEOUT_MS;
  }
  if (timeoutMs > MAX_LOCK_TIMEOUT_MS) {
    logger.warning(`CK_SYNC_LOCK_TIMEOUT too high (${parsed}s), using maximum (300s)`);
    return MAX_LOCK_TIMEOUT_MS;
  }
  return timeoutMs;
}
var STALE_LOCK_THRESHOLD_MS = 5 * 60 * 1000;
async function acquireSyncLock(global3) {
  const cacheDir = PathResolver.getCacheDir(global3);
  const lockPath = join68(cacheDir, ".sync-lock");
  const startTime = Date.now();
  const lockTimeout = getLockTimeout();
  await mkdir21(dirname10(lockPath), { recursive: true });
  while (Date.now() - startTime < lockTimeout) {
    try {
      const handle = await open(lockPath, "wx");
      return async () => {
        await handle.close();
        await unlink7(lockPath).catch(() => {});
      };
    } catch (err) {
      if (err.code === "EEXIST") {
        try {
          const lockStat = await stat10(lockPath);
          const lockAge = Math.abs(Date.now() - lockStat.mtimeMs);
          if (lockAge > STALE_LOCK_THRESHOLD_MS) {
            logger.warning(`Removing stale sync lock (age: ${Math.round(lockAge / 1000)}s)`);
            await unlink7(lockPath).catch(() => {});
            continue;
          }
        } catch (statError) {
          if (statError.code === "ENOENT") {
            continue;
          }
          logger.debug(`Lock stat failed: ${statError}`);
        }
        await new Promise((resolve10) => setTimeout(resolve10, 100));
        continue;
      }
      throw err;
    }
  }
  throw new Error("Failed to acquire sync lock: another sync operation may be in progress");
}
async function executeSyncMerge(ctx) {
  if (!isSyncContext(ctx)) {
    return ctx;
  }
  if (!ctx.extractDir || !ctx.claudeDir) {
    logger.error("Sync merge failed: missing paths");
    return { ...ctx, cancelled: true };
  }
  const releaseLock = await acquireSyncLock(ctx.options.global);
  try {
    const trackedFiles = ctx.syncTrackedFiles;
    const upstreamDir = ctx.options.global ? join68(ctx.extractDir, ".claude") : ctx.extractDir;
    logger.info("Analyzing file changes...");
    const plan = await SyncEngine.createSyncPlan(trackedFiles, ctx.claudeDir, upstreamDir);
    displaySyncPlan(plan);
    if (plan.autoUpdate.length === 0 && plan.needsReview.length === 0) {
      ctx.prompts.note("All files are up to date or user-owned.", "No Changes Needed");
      return { ...ctx, cancelled: true };
    }
    const backupDir = PathResolver.getBackupDir();
    await createBackup(ctx.claudeDir, trackedFiles, backupDir);
    logger.success(`Backup created at ${import_picocolors19.default.dim(backupDir)}`);
    if (plan.autoUpdate.length > 0) {
      logger.info(`Auto-updating ${plan.autoUpdate.length} file(s)...`);
      let updateSuccess = 0;
      let updateFailed = 0;
      for (const file of plan.autoUpdate) {
        try {
          const sourcePath = await validateSyncPath(upstreamDir, file.path);
          const targetPath = await validateSyncPath(ctx.claudeDir, file.path);
          const targetDir = join68(targetPath, "..");
          try {
            await mkdir21(targetDir, { recursive: true });
          } catch (mkdirError) {
            const errCode = mkdirError.code;
            if (errCode === "ENOSPC") {
              logger.error("Disk full: cannot complete sync operation");
              ctx.prompts.note("Your disk is full. Free up space and try again.", "Sync Failed");
              return { ...ctx, cancelled: true };
            }
            if (errCode === "EROFS" || errCode === "EACCES") {
              logger.warning(`Cannot create directory ${file.path}: ${errCode}`);
              updateFailed++;
              continue;
            }
            throw mkdirError;
          }
          await copyFile6(sourcePath, targetPath);
          logger.debug(`Updated: ${file.path}`);
          updateSuccess++;
        } catch (error) {
          const errCode = error.code;
          const errMsg = error instanceof Error ? error.message : "Unknown error";
          if (errCode === "ENOSPC") {
            logger.error("Disk full: cannot complete sync operation");
            ctx.prompts.note("Your disk is full. Free up space and try again.", "Sync Failed");
            return { ...ctx, cancelled: true };
          }
          if (errCode === "EACCES" || errCode === "EPERM") {
            logger.warning(`Permission denied: ${file.path} - check file permissions`);
            updateFailed++;
          } else if (errMsg.includes("Symlink") || errMsg.includes("Path")) {
            logger.warning(`Skipping invalid path: ${file.path}`);
            updateFailed++;
          } else {
            logger.warning(`Failed to update ${file.path}: ${errMsg}`);
            updateFailed++;
          }
        }
      }
      if (updateSuccess > 0) {
        logger.success(`Auto-updated ${updateSuccess} file(s)${updateFailed > 0 ? ` (${updateFailed} failed)` : ""}`);
      }
    }
    if (plan.needsReview.length > 0 && !ctx.isNonInteractive) {
      logger.info(`${plan.needsReview.length} file(s) need interactive review...`);
      let totalApplied = 0;
      let totalRejected = 0;
      let skippedFiles = 0;
      for (const file of plan.needsReview) {
        let currentPath;
        let upstreamPath;
        try {
          currentPath = await validateSyncPath(ctx.claudeDir, file.path);
          upstreamPath = await validateSyncPath(upstreamDir, file.path);
        } catch (error) {
          logger.warning(`Skipping invalid path during review: ${file.path}`);
          skippedFiles++;
          continue;
        }
        const { content: currentContent, isBinary: currentBinary } = await SyncEngine.loadFileContent(currentPath);
        const { content: newContent, isBinary: newBinary } = await SyncEngine.loadFileContent(upstreamPath);
        if (currentBinary || newBinary) {
          logger.warning(`Skipping binary file: ${file.path}`);
          skippedFiles++;
          continue;
        }
        const hunks = SyncEngine.generateHunks(currentContent, newContent, file.path);
        if (hunks.length === 0) {
          logger.debug(`No changes in: ${file.path}`);
          continue;
        }
        const result = await MergeUI.mergeFile(file.path, currentContent, newContent, hunks);
        if (result === "skipped") {
          MergeUI.displaySkipped(file.path);
          skippedFiles++;
          continue;
        }
        try {
          const tempPath = `${currentPath}.tmp.${Date.now()}`;
          try {
            await writeFile20(tempPath, result.result, "utf-8");
            await rename3(tempPath, currentPath);
          } catch (atomicError) {
            await unlink7(tempPath).catch(() => {});
            throw atomicError;
          }
        } catch (writeError) {
          const errCode = writeError.code;
          if (errCode === "ENOSPC") {
            logger.error("Disk full: cannot complete sync operation");
            ctx.prompts.note("Your disk is full. Free up space and try again.", "Sync Failed");
            return { ...ctx, cancelled: true };
          }
          throw writeError;
        }
        MergeUI.displayMergeSummary(file.path, result.applied, result.rejected);
        totalApplied += result.applied;
        totalRejected += result.rejected;
      }
      console.log("");
      console.log(import_picocolors19.default.bold("Sync Summary:"));
      console.log(import_picocolors19.default.dim("".repeat(40)));
      if (plan.autoUpdate.length > 0) {
        console.log(import_picocolors19.default.green(`   ${plan.autoUpdate.length} file(s) auto-updated`));
      }
      if (totalApplied > 0) {
        console.log(import_picocolors19.default.green(`   ${totalApplied} hunk(s) applied`));
      }
      if (totalRejected > 0) {
        console.log(import_picocolors19.default.yellow(`   ${totalRejected} hunk(s) rejected`));
      }
      if (skippedFiles > 0) {
        console.log(import_picocolors19.default.yellow(`   ${skippedFiles} file(s) skipped`));
      }
      if (plan.skipped.length > 0) {
        console.log(import_picocolors19.default.dim(`   ${plan.skipped.length} user-owned file(s) unchanged`));
      }
    } else if (plan.needsReview.length > 0 && ctx.isNonInteractive) {
      logger.error(`Cannot complete sync: ${plan.needsReview.length} file(s) require interactive review`);
      ctx.prompts.note(`The following files have local modifications:
${plan.needsReview.slice(0, 5).map((f3) => `   ${f3.path}`).join(`
`)}${plan.needsReview.length > 5 ? `
  ... and ${plan.needsReview.length - 5} more` : ""}

Options:
  1. Run 'ck init --sync' without --yes for interactive merge
  2. Use --force-overwrite to accept all upstream changes
  3. Manually resolve conflicts before syncing`, "Sync Blocked");
      return { ...ctx, cancelled: true };
    }
    ctx.prompts.outro("Config sync completed successfully");
    return { ...ctx, cancelled: true };
  } finally {
    await releaseLock();
  }
}
function displaySyncPlan(plan) {
  console.log("");
  console.log(import_picocolors19.default.bold("Sync Plan:"));
  console.log(import_picocolors19.default.dim("".repeat(40)));
  if (plan.autoUpdate.length > 0) {
    console.log(import_picocolors19.default.green(`  ${plan.autoUpdate.length} file(s) will be auto-updated`));
    for (const file of plan.autoUpdate.slice(0, 5)) {
      console.log(import_picocolors19.default.dim(`     ${file.path}`));
    }
    if (plan.autoUpdate.length > 5) {
      console.log(import_picocolors19.default.dim(`    ... and ${plan.autoUpdate.length - 5} more`));
    }
  }
  if (plan.needsReview.length > 0) {
    console.log(import_picocolors19.default.yellow(`  ${plan.needsReview.length} file(s) need interactive review`));
    for (const file of plan.needsReview.slice(0, 5)) {
      console.log(import_picocolors19.default.dim(`     ${file.path}`));
    }
    if (plan.needsReview.length > 5) {
      console.log(import_picocolors19.default.dim(`    ... and ${plan.needsReview.length - 5} more`));
    }
  }
  if (plan.skipped.length > 0) {
    console.log(import_picocolors19.default.dim(`  ${plan.skipped.length} user-owned file(s) will be skipped`));
  }
  console.log(import_picocolors19.default.dim("".repeat(40)));
}
async function createBackup(claudeDir, files, backupDir) {
  await mkdir21(backupDir, { recursive: true });
  for (const file of files) {
    try {
      const sourcePath = await validateSyncPath(claudeDir, file.path);
      if (await import_fs_extra31.pathExists(sourcePath)) {
        const targetPath = await validateSyncPath(backupDir, file.path);
        const targetDir = join68(targetPath, "..");
        await mkdir21(targetDir, { recursive: true });
        await copyFile6(sourcePath, targetPath);
      }
    } catch (error) {
      const errCode = error.code;
      if (errCode === "ENOSPC") {
        throw new Error("Disk full: cannot create backup");
      }
      logger.warning(`Skipping invalid path during backup: ${file.path}`);
    }
  }
}
// src/commands/init/phases/transform-handler.ts
import { join as join72 } from "node:path";

// src/services/transformers/folder-path-transformer.ts
init_logger();
init_types2();

// src/services/transformers/folder-transform/folder-renamer.ts
init_logger();
init_types2();
var import_fs_extra32 = __toESM(require_lib(), 1);
import { rename as rename4, rm as rm7 } from "node:fs/promises";
import { join as join69, relative as relative12 } from "node:path";
async function collectDirsToRename(extractDir, folders) {
  const dirsToRename = [];
  if (folders.docs !== DEFAULT_FOLDERS.docs) {
    const docsPath = join69(extractDir, DEFAULT_FOLDERS.docs);
    if (await import_fs_extra32.pathExists(docsPath)) {
      dirsToRename.push({
        from: docsPath,
        to: join69(extractDir, folders.docs)
      });
    }
    const claudeDocsPath = join69(extractDir, ".claude", DEFAULT_FOLDERS.docs);
    if (await import_fs_extra32.pathExists(claudeDocsPath)) {
      dirsToRename.push({
        from: claudeDocsPath,
        to: join69(extractDir, ".claude", folders.docs)
      });
    }
  }
  if (folders.plans !== DEFAULT_FOLDERS.plans) {
    const plansPath = join69(extractDir, DEFAULT_FOLDERS.plans);
    if (await import_fs_extra32.pathExists(plansPath)) {
      dirsToRename.push({
        from: plansPath,
        to: join69(extractDir, folders.plans)
      });
    }
    const claudePlansPath = join69(extractDir, ".claude", DEFAULT_FOLDERS.plans);
    if (await import_fs_extra32.pathExists(claudePlansPath)) {
      dirsToRename.push({
        from: claudePlansPath,
        to: join69(extractDir, ".claude", folders.plans)
      });
    }
  }
  return dirsToRename;
}
async function moveAcrossDevices(src, dest) {
  try {
    await rename4(src, dest);
  } catch (e2) {
    if (e2.code === "EXDEV") {
      logger.debug(`Cross-device move detected, using copy+delete: ${src} -> ${dest}`);
      await import_fs_extra32.copy(src, dest, { overwrite: true });
      await rm7(src, { recursive: true, force: true });
    } else {
      throw e2;
    }
  }
}
async function renameFolders(dirsToRename, extractDir, options) {
  let foldersRenamed = 0;
  for (const { from, to } of dirsToRename) {
    if (options.dryRun) {
      logger.info(`[dry-run] Would rename: ${relative12(extractDir, from)} -> ${relative12(extractDir, to)}`);
    } else {
      try {
        await moveAcrossDevices(from, to);
        logger.debug(`Renamed: ${relative12(extractDir, from)} -> ${relative12(extractDir, to)}`);
        foldersRenamed++;
      } catch (error) {
        logger.warning(`Failed to rename ${from}: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
  }
  return foldersRenamed;
}

// src/services/transformers/folder-transform/path-replacer.ts
init_logger();
init_types2();
import { readFile as readFile24, readdir as readdir23, writeFile as writeFile21 } from "node:fs/promises";
import { join as join70, relative as relative13 } from "node:path";
var TRANSFORMABLE_FILE_PATTERNS = [
  ".md",
  ".txt",
  ".json",
  ".yaml",
  ".yml",
  ".toml",
  ".sh",
  ".bash",
  ".zsh",
  ".ps1",
  ".ts",
  ".js",
  ".mjs",
  ".cjs"
];
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function buildReplacementMap(folders) {
  const replacements = new Map;
  if (folders.docs !== DEFAULT_FOLDERS.docs) {
    replacements.set(`${DEFAULT_FOLDERS.docs}/`, `${folders.docs}/`);
    replacements.set(`"${DEFAULT_FOLDERS.docs}"`, `"${folders.docs}"`);
    replacements.set(`'${DEFAULT_FOLDERS.docs}'`, `'${folders.docs}'`);
    replacements.set(`/${DEFAULT_FOLDERS.docs}`, `/${folders.docs}`);
    replacements.set(`./${DEFAULT_FOLDERS.docs}`, `./${folders.docs}`);
  }
  if (folders.plans !== DEFAULT_FOLDERS.plans) {
    replacements.set(`${DEFAULT_FOLDERS.plans}/`, `${folders.plans}/`);
    replacements.set(`"${DEFAULT_FOLDERS.plans}"`, `"${folders.plans}"`);
    replacements.set(`'${DEFAULT_FOLDERS.plans}'`, `'${folders.plans}'`);
    replacements.set(`/${DEFAULT_FOLDERS.plans}`, `/${folders.plans}`);
    replacements.set(`./${DEFAULT_FOLDERS.plans}`, `./${folders.plans}`);
  }
  return replacements;
}
function compileReplacements(replacements) {
  const compiled = [];
  for (const [search, replace3] of replacements) {
    compiled.push({
      regex: new RegExp(escapeRegExp(search), "g"),
      replacement: replace3
    });
  }
  return compiled;
}
async function transformFileContents(dir, compiledReplacements, options) {
  let filesChanged = 0;
  let replacementsCount = 0;
  const entries = await readdir23(dir, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = join70(dir, entry.name);
    if (entry.isDirectory()) {
      if (entry.name === "node_modules" || entry.name === ".git") {
        continue;
      }
      const subResult = await transformFileContents(fullPath, compiledReplacements, options);
      filesChanged += subResult.filesChanged;
      replacementsCount += subResult.replacementsCount;
    } else if (entry.isFile()) {
      const shouldTransform = TRANSFORMABLE_FILE_PATTERNS.some((ext2) => entry.name.toLowerCase().endsWith(ext2));
      if (!shouldTransform)
        continue;
      try {
        const content = await readFile24(fullPath, "utf-8");
        let newContent = content;
        let changeCount = 0;
        for (const { regex: regex2, replacement } of compiledReplacements) {
          regex2.lastIndex = 0;
          const matches = newContent.match(regex2);
          if (matches) {
            changeCount += matches.length;
            regex2.lastIndex = 0;
            newContent = newContent.replace(regex2, replacement);
          }
        }
        if (changeCount > 0) {
          if (options.dryRun) {
            logger.debug(`[dry-run] Would update ${relative13(dir, fullPath)}: ${changeCount} replacement(s)`);
          } else {
            await writeFile21(fullPath, newContent, "utf-8");
            logger.debug(`Updated ${relative13(dir, fullPath)}: ${changeCount} replacement(s)`);
          }
          filesChanged++;
          replacementsCount += changeCount;
        }
      } catch (error) {
        if (error.code !== "ENOENT") {
          logger.debug(`Skipped ${entry.name}: ${error instanceof Error ? error.message : "Unknown"}`);
        }
      }
    }
  }
  return { filesChanged, replacementsCount };
}

// src/services/transformers/folder-transform/transform-validator.ts
init_logger();
function validateFolderOptions(options) {
  if (options.docsDir) {
    const docsError = validateFolderName(options.docsDir);
    if (docsError) {
      logger.error(`Invalid --docs-dir value: ${docsError}`);
      process.exit(1);
    }
  }
  if (options.plansDir) {
    const plansError = validateFolderName(options.plansDir);
    if (plansError) {
      logger.error(`Invalid --plans-dir value: ${plansError}`);
      process.exit(1);
    }
  }
}
function validateFolderName(name2) {
  if (!name2 || name2.trim().length === 0) {
    return "Folder name cannot be empty";
  }
  if (name2.includes("..") || name2.includes("/") || name2.includes("\\")) {
    return "Folder name cannot contain path separators or parent references";
  }
  const invalidChars = /[<>:"|?*\x00-\x1f]/;
  if (invalidChars.test(name2)) {
    return "Folder name contains invalid characters";
  }
  const reservedNames = [
    "CON",
    "PRN",
    "AUX",
    "NUL",
    "COM1",
    "COM2",
    "COM3",
    "COM4",
    "COM5",
    "COM6",
    "COM7",
    "COM8",
    "COM9",
    "LPT1",
    "LPT2",
    "LPT3",
    "LPT4",
    "LPT5",
    "LPT6",
    "LPT7",
    "LPT8",
    "LPT9"
  ];
  if (reservedNames.includes(name2.toUpperCase())) {
    return "Folder name is a reserved system name";
  }
  if (name2.length > 255) {
    return "Folder name is too long (max 255 characters)";
  }
  return null;
}

// src/services/transformers/folder-path-transformer.ts
async function transformFolderPaths(extractDir, folders, options = {}) {
  const result = {
    foldersRenamed: 0,
    filesTransformed: 0,
    totalReferences: 0
  };
  const needsTransform = folders.docs !== DEFAULT_FOLDERS.docs || folders.plans !== DEFAULT_FOLDERS.plans;
  if (!needsTransform) {
    logger.debug("No folder transformation needed (using defaults)");
    return result;
  }
  logger.info("Transforming folder paths...");
  const replacements = buildReplacementMap(folders);
  const dirsToRename = await collectDirsToRename(extractDir, folders);
  result.foldersRenamed = await renameFolders(dirsToRename, extractDir, options);
  const compiledReplacements = compileReplacements(replacements);
  const transformedFiles = await transformFileContents(extractDir, compiledReplacements, options);
  result.filesTransformed = transformedFiles.filesChanged;
  result.totalReferences = transformedFiles.replacementsCount;
  if (options.verbose) {
    logger.info(`Folder transformation complete: ${result.foldersRenamed} folders renamed, ` + `${result.filesTransformed} files updated, ${result.totalReferences} references changed`);
  }
  return result;
}

// src/services/transformers/global-path-transformer.ts
init_logger();
import { readFile as readFile25, readdir as readdir24, writeFile as writeFile22 } from "node:fs/promises";
import { platform as platform12 } from "node:os";
import { extname as extname3, join as join71 } from "node:path";
var IS_WINDOWS4 = platform12() === "win32";
var HOME_PREFIX = IS_WINDOWS4 ? "%USERPROFILE%" : "$HOME";
function getHomeDirPrefix() {
  return HOME_PREFIX;
}
var TRANSFORMABLE_EXTENSIONS3 = new Set([
  ".md",
  ".js",
  ".ts",
  ".json",
  ".sh",
  ".ps1",
  ".yaml",
  ".yml",
  ".toml"
]);
var ALWAYS_TRANSFORM_FILES = new Set(["CLAUDE.md", "claude.md"]);
function transformContent(content) {
  let changes = 0;
  let transformed = content;
  const homePrefix = getHomeDirPrefix();
  const claudePath = `${homePrefix}/.claude/`;
  if (IS_WINDOWS4) {
    transformed = transformed.replace(/\$HOME\/\.claude\//g, () => {
      changes++;
      return claudePath;
    });
    transformed = transformed.replace(/\$\{HOME\}\/\.claude\//g, () => {
      changes++;
      return claudePath;
    });
    transformed = transformed.replace(/\$HOME(?=\/|\\)/g, () => {
      changes++;
      return homePrefix;
    });
    transformed = transformed.replace(/\$\{HOME\}(?=\/|\\)/g, () => {
      changes++;
      return homePrefix;
    });
  }
  transformed = transformed.replace(/\$CLAUDE_PROJECT_DIR\/\.claude\//g, () => {
    changes++;
    return claudePath;
  });
  transformed = transformed.replace(/"\$CLAUDE_PROJECT_DIR"\/\.claude\//g, () => {
    changes++;
    return `"${homePrefix}"/.claude/`;
  });
  transformed = transformed.replace(/\$\{CLAUDE_PROJECT_DIR\}\/\.claude\//g, () => {
    changes++;
    return claudePath;
  });
  if (IS_WINDOWS4) {
    transformed = transformed.replace(/%CLAUDE_PROJECT_DIR%\/\.claude\//g, () => {
      changes++;
      return claudePath;
    });
  }
  transformed = transformed.replace(/\.\/\.claude\//g, () => {
    changes++;
    return claudePath;
  });
  transformed = transformed.replace(/@\.\/\.claude\//g, () => {
    changes++;
    return `@${claudePath}`;
  });
  transformed = transformed.replace(/@\.claude\//g, () => {
    changes++;
    return `@${claudePath}`;
  });
  transformed = transformed.replace(/(["'`])\.claude\//g, (_match, quote) => {
    changes++;
    return `${quote}${claudePath}`;
  });
  transformed = transformed.replace(/\(\.claude\//g, () => {
    changes++;
    return `(${claudePath}`;
  });
  transformed = transformed.replace(/ \.claude\//g, () => {
    changes++;
    return ` ${claudePath}`;
  });
  transformed = transformed.replace(/^\.claude\//gm, () => {
    changes++;
    return claudePath;
  });
  transformed = transformed.replace(/: \.claude\//g, () => {
    changes++;
    return `: ${claudePath}`;
  });
  transformed = transformed.replace(/:\.claude\//g, () => {
    changes++;
    return `:${claudePath}`;
  });
  return { transformed, changes };
}
function shouldTransformFile3(filename) {
  const ext2 = extname3(filename).toLowerCase();
  const basename3 = filename.split("/").pop() || filename;
  return TRANSFORMABLE_EXTENSIONS3.has(ext2) || ALWAYS_TRANSFORM_FILES.has(basename3);
}
async function transformPathsForGlobalInstall(directory, options = {}) {
  let filesTransformed = 0;
  let totalChanges = 0;
  let filesSkipped = 0;
  const skippedFiles = [];
  async function processDirectory2(dir) {
    const entries = await readdir24(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = join71(dir, entry.name);
      if (entry.isDirectory()) {
        if (entry.name === "node_modules" || entry.name.startsWith(".") && entry.name !== ".claude") {
          continue;
        }
        await processDirectory2(fullPath);
      } else if (entry.isFile() && shouldTransformFile3(entry.name)) {
        try {
          const content = await readFile25(fullPath, "utf-8");
          const { transformed, changes } = transformContent(content);
          if (changes > 0) {
            await writeFile22(fullPath, transformed, "utf-8");
            filesTransformed++;
            totalChanges += changes;
            if (options.verbose) {
              logger.verbose(`Transformed ${changes} path(s) in ${fullPath}`);
            }
          }
        } catch (error) {
          const reason = error instanceof Error ? error.message : "unknown error";
          filesSkipped++;
          skippedFiles.push({ path: fullPath, reason });
          logger.debug(`Skipping ${fullPath}: ${reason}`);
          if (options.verbose) {
            logger.verbose(`Skipping ${fullPath}: ${reason}`);
          }
        }
      }
    }
  }
  await processDirectory2(directory);
  if (filesSkipped > 0 && options.verbose) {
    logger.verbose(`Skipped ${filesSkipped} file(s) during path transformation`);
  }
  return { filesTransformed, totalChanges, filesSkipped, skippedFiles };
}

// src/commands/init/phases/transform-handler.ts
init_logger();
init_types2();
async function handleTransforms(ctx) {
  if (ctx.cancelled || !ctx.extractDir || !ctx.resolvedDir)
    return ctx;
  if (CommandsPrefix.shouldApplyPrefix(ctx.options)) {
    await CommandsPrefix.applyPrefix(ctx.extractDir);
  }
  if (ctx.options.global) {
    logger.info("Transforming paths for global installation...");
    const transformResult = await transformPathsForGlobalInstall(ctx.extractDir, {
      verbose: logger.isVerbose()
    });
    logger.success(`Transformed ${transformResult.totalChanges} path(s) in ${transformResult.filesTransformed} file(s)`);
  }
  if (ctx.options.global) {
    await ConfigManager.migrateNestedConfig(ctx.resolvedDir);
  }
  const foldersConfig = await ConfigManager.resolveFoldersConfig(ctx.resolvedDir, {
    docsDir: ctx.options.docsDir,
    plansDir: ctx.options.plansDir
  }, ctx.options.global);
  validateFolderOptions(ctx.options);
  const hasCustomFolders = foldersConfig.docs !== DEFAULT_FOLDERS.docs || foldersConfig.plans !== DEFAULT_FOLDERS.plans;
  if (hasCustomFolders) {
    logger.info(`Using custom folder names: docs=${foldersConfig.docs}, plans=${foldersConfig.plans}`);
    const folderTransformResult = await transformFolderPaths(ctx.extractDir, foldersConfig, {
      verbose: logger.isVerbose()
    });
    logger.success(`Transformed ${folderTransformResult.foldersRenamed} folder(s), ` + `${folderTransformResult.totalReferences} reference(s) in ${folderTransformResult.filesTransformed} file(s)`);
    if (ctx.options.docsDir || ctx.options.plansDir) {
      await ConfigManager.saveProjectConfig(ctx.resolvedDir, {
        docs: foldersConfig.docs,
        plans: foldersConfig.plans
      }, ctx.options.global);
      logger.debug(ctx.options.global ? "Saved folder configuration to ~/.claude/.ck.json" : "Saved folder configuration to .claude/.ck.json");
    }
  }
  const claudeDir = ctx.options.global ? ctx.resolvedDir : join72(ctx.resolvedDir, ".claude");
  return {
    ...ctx,
    foldersConfig,
    claudeDir
  };
}
// src/commands/init/init-command.ts
async function installAdditionalKit(baseCtx, kitType) {
  const kit = AVAILABLE_KITS[kitType];
  const github = new GitHubClient;
  logger.info(`
Installing additional kit: ${kit.name}`);
  let release;
  if (baseCtx.selectedVersion && !baseCtx.selectedVersion.includes("latest")) {
    try {
      release = await github.getReleaseByTag(kit, baseCtx.selectedVersion);
      logger.success(`Found matching version: ${release.tag_name}`);
    } catch {
      logger.warning(`Version ${baseCtx.selectedVersion} not available for ${kit.name}, using latest`);
      release = await github.getLatestRelease(kit, baseCtx.options.beta);
      logger.success(`Found: ${release.tag_name}`);
    }
  } else {
    release = await github.getLatestRelease(kit, baseCtx.options.beta);
    logger.success(`Found: ${release.tag_name}`);
  }
  let ctx = {
    ...baseCtx,
    kit,
    kitType,
    release,
    selectedVersion: release.tag_name,
    tempDir: undefined,
    archivePath: undefined,
    extractDir: undefined
  };
  ctx = await handleDownload(ctx);
  if (ctx.cancelled)
    return ctx;
  ctx = await handleOpenCode(ctx);
  if (ctx.cancelled)
    return ctx;
  ctx = await handleTransforms(ctx);
  if (ctx.cancelled)
    return ctx;
  ctx = await handleMigration(ctx);
  if (ctx.cancelled)
    return ctx;
  ctx = await handleMerge(ctx);
  if (ctx.cancelled)
    return ctx;
  ctx = await handlePostInstall(ctx);
  return ctx;
}
function createInitContext(rawOptions, prompts) {
  const placeholderOptions = {
    dir: ".",
    beta: false,
    global: false,
    yes: false,
    fresh: false,
    refresh: false,
    exclude: [],
    only: [],
    installSkills: false,
    withSudo: false,
    skipSetup: false,
    forceOverwrite: false,
    forceOverwriteSettings: false,
    dryRun: false,
    prefix: false,
    sync: false,
    useGit: false
  };
  return {
    rawOptions,
    options: placeholderOptions,
    prompts,
    explicitDir: false,
    isNonInteractive: false,
    customClaudeFiles: [],
    includePatterns: [],
    installSkills: false,
    cancelled: false
  };
}
async function executeInit(options, prompts) {
  let ctx = createInitContext(options, prompts);
  ctx = await resolveOptions(ctx);
  if (ctx.cancelled)
    return;
  ctx = await handleSync(ctx);
  if (ctx.cancelled)
    return;
  const isSyncMode = isSyncContext(ctx);
  if (!isSyncMode) {
    ctx = await handleConflicts(ctx);
    if (ctx.cancelled)
      return;
  }
  ctx = await handleSelection(ctx);
  if (ctx.cancelled)
    return;
  ctx = await handleDownload(ctx);
  if (ctx.cancelled)
    return;
  if (!isSyncMode) {
    ctx = await handleOpenCode(ctx);
    if (ctx.cancelled)
      return;
  }
  if (!isSyncMode) {
    ctx = await handleTransforms(ctx);
    if (ctx.cancelled)
      return;
  }
  if (isSyncMode) {
    ctx = await executeSyncMerge(ctx);
    if (ctx.cancelled)
      return;
  }
  if (!isSyncMode) {
    ctx = await handleMigration(ctx);
    if (ctx.cancelled)
      return;
  }
  if (!isSyncMode) {
    ctx = await handleMerge(ctx);
    if (ctx.cancelled)
      return;
  }
  if (!isSyncMode) {
    ctx = await handlePostInstall(ctx);
    if (ctx.cancelled)
      return;
  }
  if (!isSyncMode && ctx.pendingKits && ctx.pendingKits.length > 0 && ctx.kitType) {
    const installedKits = [ctx.kitType];
    const kitsToInstall = [...ctx.pendingKits];
    for (const pendingKit of kitsToInstall) {
      try {
        ctx = await installAdditionalKit(ctx, pendingKit);
        if (ctx.cancelled) {
          logger.warning(`Installation of ${AVAILABLE_KITS[pendingKit].name} was cancelled`);
          break;
        }
        installedKits.push(pendingKit);
      } catch (error) {
        logger.error(`Failed to install ${AVAILABLE_KITS[pendingKit].name}: ${error instanceof Error ? error.message : "Unknown error"}`);
        if (installedKits.length > 1) {
          logger.info(`Successfully installed: ${installedKits.map((k2) => AVAILABLE_KITS[k2].name).join(", ")}`);
        }
        throw error;
      }
    }
    logger.success(`
Installed ${installedKits.length} kits: ${installedKits.map((k2) => AVAILABLE_KITS[k2].name).join(", ")}`);
  }
  prompts.outro(`Project initialized successfully at ${ctx.resolvedDir}`);
  const protectedNote = ctx.customClaudeFiles.length > 0 ? `Your project has been initialized with the latest version.
Protected files (.env, .claude custom files, etc.) were not modified.` : `Your project has been initialized with the latest version.
Protected files (.env, etc.) were not modified.`;
  prompts.note(protectedNote, "Initialization complete");
  if (ctx.resolvedDir) {
    await maybeShowConfigUpdateNotification(ctx.resolvedDir, ctx.options.global);
  }
}
async function initCommand(options) {
  const prompts = new PromptsManager;
  prompts.intro("Initialize/Update Project");
  try {
    await withProcessLock("kit-install", async () => {
      await executeInit(options, prompts);
    });
  } catch (error) {
    if (error instanceof Error && error.message === "Merge cancelled by user") {
      logger.warning("Update cancelled");
      return;
    }
    logger.error(error instanceof Error ? error.message : "Unknown error occurred");
    process.exit(1);
  }
}
// src/commands/new/new-command.ts
init_logger();
init_types2();
var import_picocolors20 = __toESM(require_picocolors(), 1);

// src/commands/new/phases/directory-setup.ts
import { resolve as resolve10 } from "node:path";
init_logger();
init_path_resolver();
init_types2();
var import_fs_extra33 = __toESM(require_lib(), 1);
async function directorySetup(validOptions, prompts) {
  const isNonInteractive2 = !process.stdin.isTTY || process.env.CI === "true" || process.env.NON_INTERACTIVE === "true";
  const config = await ConfigManager.get();
  let accessibleKits;
  if (!validOptions.useGit && !validOptions.kitPath && !validOptions.archive) {
    accessibleKits = await detectAccessibleKits();
    if (accessibleKits.length === 0) {
      logger.error("No ClaudeKit access found.");
      logger.info("Purchase at https://claudekit.cc");
      return null;
    }
  }
  const allKitTypes = Object.keys(AVAILABLE_KITS);
  let kit;
  const kitOption = validOptions.kit || config.defaults?.kit;
  if (kitOption) {
    if (kitOption === "all") {
      const kitsToUse = accessibleKits ?? allKitTypes;
      if (kitsToUse.length === 0) {
        logger.error("No kits accessible for installation");
        return null;
      }
      kit = kitsToUse[0];
      logger.info(`Using ${AVAILABLE_KITS[kit].name} for new project`);
    } else if (kitOption.includes(",")) {
      const rawKits = kitOption.split(",").map((k2) => k2.trim());
      const validKits = rawKits.filter((k2) => isValidKitType(k2));
      const invalidKits = rawKits.filter((k2) => !isValidKitType(k2));
      if (invalidKits.length > 0) {
        logger.warning(`Ignoring invalid kit(s): ${invalidKits.join(", ")}`);
      }
      if (validKits.length === 0) {
        logger.error("No valid kits specified");
        logger.info(`Valid kits: ${allKitTypes.join(", ")}`);
        return null;
      }
      kit = validKits[0];
      if (accessibleKits && !accessibleKits.includes(kit)) {
        logger.error(`No access to ${AVAILABLE_KITS[kit].name}`);
        logger.info("Purchase at https://claudekit.cc");
        return null;
      }
    } else {
      if (!isValidKitType(kitOption)) {
        logger.error(`Invalid kit: ${kitOption}`);
        logger.info(`Valid kits: ${allKitTypes.join(", ")}`);
        return null;
      }
      kit = kitOption;
      if (accessibleKits && !accessibleKits.includes(kit)) {
        logger.error(`No access to ${AVAILABLE_KITS[kit].name}`);
        logger.info("Purchase at https://claudekit.cc");
        return null;
      }
    }
  }
  if (!kit) {
    if (isNonInteractive2) {
      kit = accessibleKits?.[0];
      if (!kit) {
        throw new Error("Kit must be specified via --kit flag in non-interactive mode");
      }
      logger.info(`Auto-selected: ${AVAILABLE_KITS[kit].name}`);
    } else if (accessibleKits?.length === 1) {
      kit = accessibleKits[0];
      logger.info(`Using ${AVAILABLE_KITS[kit].name} (only accessible kit)`);
    } else {
      kit = await prompts.selectKit(undefined, accessibleKits);
    }
  }
  const kitConfig = AVAILABLE_KITS[kit];
  logger.info(`Selected kit: ${kitConfig.name}`);
  let targetDir = validOptions.dir || config.defaults?.dir || ".";
  if (!validOptions.dir && !config.defaults?.dir) {
    if (isNonInteractive2) {
      targetDir = ".";
    } else {
      targetDir = await prompts.getDirectory(targetDir);
    }
  }
  const resolvedDir = resolve10(targetDir);
  logger.info(`Target directory: ${resolvedDir}`);
  if (PathResolver.isLocalSameAsGlobal(resolvedDir)) {
    logger.warning("You're creating a project at HOME directory.");
    logger.warning("This will install to your GLOBAL ~/.claude/ directory.");
    if (!isNonInteractive2) {
      const choice = await prompts.selectScope();
      if (choice === "cancel" || choice === "different") {
        logger.info("Please run 'ck new' from or specify a different directory.");
        return null;
      }
      logger.info("Proceeding with global installation");
    } else {
      logger.error("Cannot create project at HOME directory in non-interactive mode.");
      logger.info("Specify a different directory with --dir flag.");
      return null;
    }
  }
  if (await import_fs_extra33.pathExists(resolvedDir)) {
    const files = await import_fs_extra33.readdir(resolvedDir);
    const isEmpty = files.length === 0;
    if (!isEmpty) {
      if (isNonInteractive2) {
        if (!validOptions.force) {
          throw new Error("Directory is not empty. Use --force flag to overwrite in non-interactive mode");
        }
        logger.info("Directory is not empty. Proceeding with --force flag");
      } else {
        const continueAnyway = await prompts.confirm("Directory is not empty. Files may be overwritten. Continue?");
        if (!continueAnyway) {
          logger.warning("Operation cancelled");
          return null;
        }
      }
    }
  }
  return {
    kit,
    resolvedDir,
    isNonInteractive: isNonInteractive2
  };
}
async function handleDirectorySetup(ctx) {
  const result = await directorySetup(ctx.options, ctx.prompts);
  if (!result) {
    return { ...ctx, cancelled: true };
  }
  return {
    ...ctx,
    kit: result.kit,
    resolvedDir: result.resolvedDir,
    isNonInteractive: result.isNonInteractive
  };
}
// src/commands/new/phases/project-creation.ts
import { join as join73 } from "node:path";
init_github_client();
init_logger();
init_output_manager();
init_types2();

// src/commands/new/phases/version-selection.ts
init_logger();
async function selectVersion2(kit, options, isNonInteractive2, prompts, github) {
  if (options.kitPath || options.archive) {
    const localVersion = options.release || "local";
    return {
      release: {
        id: 0,
        tag_name: localVersion,
        name: localVersion,
        draft: false,
        prerelease: false,
        tarball_url: "",
        zipball_url: "",
        assets: []
      },
      selectedVersion: localVersion
    };
  }
  let selectedVersion = options.release;
  if (!selectedVersion && isNonInteractive2) {
    throw new Error("Interactive version selection unavailable in non-interactive mode. " + "Either: (1) use --release <tag> flag, or (2) set CI=false to enable interactive mode");
  }
  if (!selectedVersion && !isNonInteractive2) {
    logger.info("Fetching available versions...");
    try {
      const versionResult = await prompts.selectVersionEnhanced({
        kit,
        includePrereleases: options.beta,
        limit: 10,
        allowManualEntry: true,
        forceRefresh: options.refresh
      });
      if (!versionResult) {
        logger.warning("Version selection cancelled by user");
        return null;
      }
      selectedVersion = versionResult;
      logger.success(`Selected version: ${selectedVersion}`);
    } catch (error) {
      logger.error("Failed to fetch versions, using latest release");
      const message = error instanceof Error ? error.message : String(error);
      logger.debug(`Version selection error: ${message}`);
      selectedVersion = undefined;
    }
  }
  let release;
  if (options.useGit && selectedVersion) {
    release = {
      id: 0,
      tag_name: selectedVersion,
      name: selectedVersion,
      draft: false,
      prerelease: selectedVersion.includes("-"),
      tarball_url: `https://github.com/${kit.owner}/${kit.repo}/archive/refs/tags/${selectedVersion}.tar.gz`,
      zipball_url: `https://github.com/${kit.owner}/${kit.repo}/archive/refs/tags/${selectedVersion}.zip`,
      assets: []
    };
    logger.verbose("Using git clone mode with tag", { tag: selectedVersion });
  } else if (selectedVersion) {
    release = await github.getReleaseByTag(kit, selectedVersion);
  } else {
    if (options.beta) {
      logger.info("Fetching latest beta release...");
    } else {
      logger.info("Fetching latest release...");
    }
    release = await github.getLatestRelease(kit, options.beta);
    if (release.prerelease) {
      logger.success(`Found beta: ${release.tag_name}`);
    } else {
      logger.success(`Found: ${release.tag_name}`);
    }
  }
  return {
    release,
    selectedVersion: release.tag_name
  };
}

// src/commands/new/phases/project-creation.ts
async function projectCreation(kit, resolvedDir, validOptions, isNonInteractive2, prompts) {
  const kitConfig = AVAILABLE_KITS[kit];
  const github = new GitHubClient;
  const versionResult = await selectVersion2(kitConfig, validOptions, isNonInteractive2, prompts, github);
  if (!versionResult) {
    return null;
  }
  const { release } = versionResult;
  const { extractDir } = await downloadAndExtract({
    release,
    kit: kitConfig,
    exclude: validOptions.exclude,
    useGit: validOptions.useGit,
    isNonInteractive: isNonInteractive2,
    archive: validOptions.archive,
    kitPath: validOptions.kitPath
  });
  if (CommandsPrefix.shouldApplyPrefix(validOptions)) {
    await CommandsPrefix.applyPrefix(extractDir);
  }
  const foldersConfig = await ConfigManager.resolveFoldersConfig(resolvedDir, {
    docsDir: validOptions.docsDir,
    plansDir: validOptions.plansDir
  });
  validateFolderOptions(validOptions);
  const hasCustomFolders = foldersConfig.docs !== DEFAULT_FOLDERS.docs || foldersConfig.plans !== DEFAULT_FOLDERS.plans;
  if (hasCustomFolders) {
    const transformResult = await transformFolderPaths(extractDir, foldersConfig, {
      verbose: logger.isVerbose()
    });
    logger.success(`Transformed ${transformResult.foldersRenamed} folder(s), ` + `${transformResult.totalReferences} reference(s) in ${transformResult.filesTransformed} file(s)`);
    await ConfigManager.saveProjectConfig(resolvedDir, {
      docs: foldersConfig.docs,
      plans: foldersConfig.plans
    });
    logger.debug("Saved folder configuration to .claude/.ck.json");
  }
  output.section("Installing");
  logger.verbose("Installation target", { directory: resolvedDir });
  const merger = new FileMerger;
  const claudeDir = join73(resolvedDir, ".claude");
  merger.setMultiKitContext(claudeDir, kit);
  if (validOptions.exclude && validOptions.exclude.length > 0) {
    merger.addIgnorePatterns(validOptions.exclude);
  }
  if (CommandsPrefix.shouldApplyPrefix(validOptions)) {
    await CommandsPrefix.cleanupCommandsDirectory(resolvedDir, false);
  }
  await merger.merge(extractDir, resolvedDir, true);
  const releaseManifest = await ReleaseManifestLoader.load(extractDir);
  const installedFiles = merger.getAllInstalledFiles();
  const filesToTrack = buildFileTrackingList({
    installedFiles,
    claudeDir,
    releaseManifest,
    installedVersion: release.tag_name,
    isGlobal: false
  });
  await trackFilesWithProgress(filesToTrack, {
    claudeDir,
    kitName: kitConfig.name,
    releaseTag: release.tag_name,
    mode: "local"
  });
  return {
    releaseTag: release.tag_name,
    installedFiles,
    claudeDir
  };
}
async function handleProjectCreation(ctx) {
  if (!ctx.kit || !ctx.resolvedDir) {
    return { ...ctx, cancelled: true };
  }
  const result = await projectCreation(ctx.kit, ctx.resolvedDir, ctx.options, ctx.isNonInteractive, ctx.prompts);
  if (!result) {
    return { ...ctx, cancelled: true };
  }
  return {
    ...ctx,
    releaseTag: result.releaseTag,
    installedFiles: result.installedFiles,
    claudeDir: result.claudeDir
  };
}
// src/commands/new/phases/post-setup.ts
import { join as join74 } from "node:path";
init_package_installer();
init_logger();
init_path_resolver();
async function postSetup(resolvedDir, validOptions, isNonInteractive2, prompts) {
  let installOpenCode2 = validOptions.opencode;
  let installGemini2 = validOptions.gemini;
  let installSkills = validOptions.installSkills;
  if (!isNonInteractive2 && !installOpenCode2 && !installGemini2 && !installSkills) {
    const packageChoices = await prompts.promptPackageInstallations();
    installOpenCode2 = packageChoices.installOpenCode;
    installGemini2 = packageChoices.installGemini;
    installSkills = await prompts.promptSkillsInstallation();
  }
  if (installOpenCode2 || installGemini2) {
    logger.info("Installing optional packages...");
    try {
      const installationResults = await processPackageInstallations(installOpenCode2, installGemini2, resolvedDir);
      prompts.showPackageInstallationResults(installationResults);
    } catch (error) {
      logger.warning(`Package installation failed: ${error instanceof Error ? error.message : String(error)}`);
      logger.info("You can install these packages manually later using npm install -g <package>");
    }
  }
  if (installSkills) {
    const { handleSkillsInstallation: handleSkillsInstallation2 } = await Promise.resolve().then(() => (init_package_installer(), exports_package_installer));
    const skillsDir = PathResolver.buildSkillsPath(resolvedDir, false);
    await handleSkillsInstallation2(skillsDir, {
      skipConfirm: isNonInteractive2,
      withSudo: validOptions.withSudo
    });
  }
  const claudeDir = join74(resolvedDir, ".claude");
  await promptSetupWizardIfNeeded({
    envPath: join74(claudeDir, ".env"),
    claudeDir,
    isGlobal: false,
    isNonInteractive: isNonInteractive2,
    prompts
  });
}
async function handlePostSetup(ctx) {
  if (!ctx.resolvedDir) {
    return { ...ctx, cancelled: true };
  }
  await postSetup(ctx.resolvedDir, ctx.options, ctx.isNonInteractive, ctx.prompts);
  return ctx;
}
// src/commands/new/new-command.ts
function createNewContext(options, prompts) {
  return {
    options,
    prompts,
    isNonInteractive: !process.stdin.isTTY || process.env.CI === "true",
    cancelled: false
  };
}
async function newCommand(options) {
  const prompts = new PromptsManager;
  prompts.intro("\uD83D\uDE80 ClaudeKit - Create New Project");
  try {
    const validOptions = NewCommandOptionsSchema.parse(options);
    const downloadMethods = [
      validOptions.useGit && "--use-git",
      validOptions.archive && "--archive",
      validOptions.kitPath && "--kit-path"
    ].filter(Boolean);
    if (downloadMethods.length > 1) {
      throw new Error(`Options ${downloadMethods.join(", ")} are mutually exclusive.

Please use only one download method.`);
    }
    if (validOptions.useGit && !validOptions.release) {
      throw new Error(`--use-git requires --release <tag> to specify the version.

` + `Git clone mode cannot list versions without GitHub API access.
` + "Example: ck new --use-git --release v2.1.0");
    }
    let ctx = createNewContext(validOptions, prompts);
    ctx = await handleDirectorySetup(ctx);
    if (ctx.cancelled)
      return;
    ctx = await handleProjectCreation(ctx);
    if (ctx.cancelled)
      return;
    ctx = await handlePostSetup(ctx);
    if (ctx.cancelled)
      return;
    prompts.outro(` Project created successfully at ${ctx.resolvedDir}`);
    log.info(`${import_picocolors20.default.dim("Tip:")} To update later: ${import_picocolors20.default.cyan("ck update")} (CLI) + ${import_picocolors20.default.cyan("ck init")} (kit content)`);
  } catch (error) {
    logger.error(error instanceof Error ? error.message : "Unknown error occurred");
    process.exit(1);
  }
}
// src/commands/uninstall/uninstall-command.ts
init_logger();
init_path_resolver();
init_types2();
var import_picocolors22 = __toESM(require_picocolors(), 1);

// src/commands/uninstall/installation-detector.ts
init_path_resolver();
var import_fs_extra34 = __toESM(require_lib(), 1);
async function detectInstallations() {
  const installations = [];
  const setup = await getClaudeKitSetup(process.cwd());
  const isLocalSameAsGlobal = PathResolver.isLocalSameAsGlobal();
  if (setup.project.path && setup.project.metadata && !isLocalSameAsGlobal) {
    installations.push({
      type: "local",
      path: setup.project.path,
      exists: await import_fs_extra34.pathExists(setup.project.path)
    });
  }
  if (setup.global.path && setup.global.metadata) {
    installations.push({
      type: "global",
      path: setup.global.path,
      exists: await import_fs_extra34.pathExists(setup.global.path)
    });
  }
  return installations.filter((i) => i.exists);
}

// src/commands/uninstall/removal-handler.ts
import { readdirSync as readdirSync3, rmSync as rmSync4 } from "node:fs";
import { join as join76 } from "node:path";
init_logger();
var import_fs_extra35 = __toESM(require_lib(), 1);

// src/commands/uninstall/analysis-handler.ts
import { readdirSync as readdirSync2, rmSync as rmSync3 } from "node:fs";
import { dirname as dirname11, join as join75 } from "node:path";
init_logger();
var import_picocolors21 = __toESM(require_picocolors(), 1);
function classifyFileByOwnership(ownership, forceOverwrite, deleteReason) {
  if (ownership === "ck") {
    return { action: "delete", reason: deleteReason };
  }
  if (ownership === "ck-modified") {
    if (forceOverwrite) {
      return { action: "delete", reason: "force overwrite" };
    }
    return { action: "preserve", reason: "modified by user" };
  }
  return { action: "preserve", reason: "user-created" };
}
async function cleanupEmptyDirectories2(filePath, installationRoot) {
  let cleaned = 0;
  let currentDir = dirname11(filePath);
  while (currentDir !== installationRoot && currentDir.startsWith(installationRoot)) {
    try {
      const entries = readdirSync2(currentDir);
      if (entries.length === 0) {
        rmSync3(currentDir, { recursive: true });
        cleaned++;
        logger.debug(`Removed empty directory: ${currentDir}`);
        currentDir = dirname11(currentDir);
      } else {
        break;
      }
    } catch {
      break;
    }
  }
  return cleaned;
}
async function analyzeInstallation(installation, forceOverwrite, kit) {
  const result = {
    toDelete: [],
    toPreserve: [],
    remainingKits: []
  };
  const metadata = await ManifestWriter.readManifest(installation.path);
  const uninstallManifest = await ManifestWriter.getUninstallManifest(installation.path, kit);
  result.remainingKits = uninstallManifest.remainingKits;
  if (uninstallManifest.isMultiKit && kit && metadata?.kits?.[kit]) {
    const kitFiles = metadata.kits[kit].files || [];
    for (const trackedFile of kitFiles) {
      const filePath = join75(installation.path, trackedFile.path);
      if (uninstallManifest.filesToPreserve.includes(trackedFile.path)) {
        result.toPreserve.push({ path: trackedFile.path, reason: "shared with other kit" });
        continue;
      }
      const ownershipResult = await OwnershipChecker.checkOwnership(filePath, metadata, installation.path);
      if (!ownershipResult.exists)
        continue;
      const classification = classifyFileByOwnership(ownershipResult.ownership, forceOverwrite, `${kit} kit (pristine)`);
      if (classification.action === "delete") {
        result.toDelete.push({ path: trackedFile.path, reason: classification.reason });
      } else {
        result.toPreserve.push({ path: trackedFile.path, reason: classification.reason });
      }
    }
    if (result.remainingKits.length === 0) {
      result.toDelete.push({ path: "metadata.json", reason: "metadata file" });
    }
    return result;
  }
  const allTrackedFiles = metadata ? getAllTrackedFiles(metadata) : [];
  if (!metadata || allTrackedFiles.length === 0) {
    for (const item of uninstallManifest.filesToRemove) {
      if (!uninstallManifest.filesToPreserve.includes(item)) {
        result.toDelete.push({ path: item, reason: "legacy installation" });
      }
    }
    return result;
  }
  for (const trackedFile of allTrackedFiles) {
    const filePath = join75(installation.path, trackedFile.path);
    const ownershipResult = await OwnershipChecker.checkOwnership(filePath, metadata, installation.path);
    if (!ownershipResult.exists)
      continue;
    const classification = classifyFileByOwnership(ownershipResult.ownership, forceOverwrite, "CK-owned (pristine)");
    if (classification.action === "delete") {
      result.toDelete.push({ path: trackedFile.path, reason: classification.reason });
    } else {
      result.toPreserve.push({ path: trackedFile.path, reason: classification.reason });
    }
  }
  result.toDelete.push({ path: "metadata.json", reason: "metadata file" });
  return result;
}
function displayDryRunPreview(analysis, installationType) {
  console.log("");
  log.info(import_picocolors21.default.bold(`DRY RUN - Preview for ${installationType} installation:`));
  console.log("");
  if (analysis.toDelete.length > 0) {
    console.log(import_picocolors21.default.red(import_picocolors21.default.bold(`Files to DELETE (${analysis.toDelete.length}):`)));
    const showDelete = analysis.toDelete.slice(0, 10);
    for (const item of showDelete) {
      console.log(`  ${import_picocolors21.default.red("")} ${item.path}`);
    }
    if (analysis.toDelete.length > 10) {
      console.log(import_picocolors21.default.gray(`  ... and ${analysis.toDelete.length - 10} more`));
    }
    console.log("");
  }
  if (analysis.toPreserve.length > 0) {
    console.log(import_picocolors21.default.green(import_picocolors21.default.bold(`Files to PRESERVE (${analysis.toPreserve.length}):`)));
    const showPreserve = analysis.toPreserve.slice(0, 10);
    for (const item of showPreserve) {
      console.log(`  ${import_picocolors21.default.green("")} ${item.path} ${import_picocolors21.default.gray(`(${item.reason})`)}`);
    }
    if (analysis.toPreserve.length > 10) {
      console.log(import_picocolors21.default.gray(`  ... and ${analysis.toPreserve.length - 10} more`));
    }
    console.log("");
  }
}

// src/commands/uninstall/removal-handler.ts
async function removeInstallations(installations, options) {
  for (const installation of installations) {
    const analysis = await analyzeInstallation(installation, options.forceOverwrite, options.kit);
    if (options.dryRun) {
      const label = options.kit ? `${installation.type} (${options.kit} kit)` : installation.type;
      displayDryRunPreview(analysis, label);
      if (analysis.remainingKits.length > 0) {
        log.info(`Remaining kits after uninstall: ${analysis.remainingKits.join(", ")}`);
      }
      continue;
    }
    const kitLabel = options.kit ? ` ${options.kit} kit` : "";
    const spinner = createSpinner(`Removing ${installation.type}${kitLabel} ClaudeKit files...`).start();
    try {
      let removedCount = 0;
      let cleanedDirs = 0;
      for (const item of analysis.toDelete) {
        const filePath = join76(installation.path, item.path);
        if (await import_fs_extra35.pathExists(filePath)) {
          await import_fs_extra35.remove(filePath);
          removedCount++;
          logger.debug(`Removed: ${item.path}`);
          cleanedDirs += await cleanupEmptyDirectories2(filePath, installation.path);
        }
      }
      if (options.kit && analysis.remainingKits.length > 0) {
        await ManifestWriter.removeKitFromManifest(installation.path, options.kit);
      }
      try {
        const remaining = readdirSync3(installation.path);
        if (remaining.length === 0) {
          rmSync4(installation.path, { recursive: true });
          logger.debug(`Removed empty installation directory: ${installation.path}`);
        }
      } catch {}
      const kitsInfo = analysis.remainingKits.length > 0 ? `, ${analysis.remainingKits.join(", ")} kit(s) preserved` : "";
      spinner.succeed(`Removed ${removedCount} files${cleanedDirs > 0 ? `, cleaned ${cleanedDirs} empty directories` : ""}, preserved ${analysis.toPreserve.length} customizations${kitsInfo}`);
      if (analysis.toPreserve.length > 0) {
        log.info("Preserved customizations:");
        analysis.toPreserve.slice(0, 5).forEach((f3) => log.message(`  - ${f3.path} (${f3.reason})`));
        if (analysis.toPreserve.length > 5) {
          log.message(`  ... and ${analysis.toPreserve.length - 5} more`);
        }
      }
    } catch (error) {
      spinner.fail(`Failed to remove ${installation.type} installation`);
      throw new Error(`Failed to remove files from ${installation.path}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
}

// src/commands/uninstall/uninstall-command.ts
var prompts = new PromptsManager;
function displayInstallations(installations, scope) {
  prompts.intro("ClaudeKit Uninstaller");
  const scopeLabel = scope === "all" ? "all" : scope === "local" ? "local only" : "global only";
  prompts.note(installations.map((i) => `  ${i.type === "local" ? "Local " : "Global"}: ${i.path}`).join(`
`), `Detected ClaudeKit installations (${scopeLabel})`);
  log.warn("[!] This will permanently delete ClaudeKit files from the above paths.");
}
async function promptScope(installations) {
  const hasLocal = installations.some((i) => i.type === "local");
  const hasGlobal = installations.some((i) => i.type === "global");
  if (hasLocal && !hasGlobal)
    return "local";
  if (hasGlobal && !hasLocal)
    return "global";
  const options = [
    { value: "local", label: "Local only", hint: "Remove from current project (.claude/)" },
    { value: "global", label: "Global only", hint: "Remove from user directory (~/.claude/)" },
    { value: "all", label: "Both", hint: "Remove all ClaudeKit installations" }
  ];
  const selected = await ie({
    message: "Which installation(s) do you want to uninstall?",
    options
  });
  if (lD(selected)) {
    return null;
  }
  return selected;
}
async function confirmUninstall(scope, kitLabel = "") {
  const scopeText = scope === "all" ? "all ClaudeKit installations" : scope === "local" ? "local ClaudeKit installation" : "global ClaudeKit installation";
  const confirmed = await se({
    message: `Continue with uninstalling ${scopeText}${kitLabel}?`,
    initialValue: false
  });
  return confirmed === true;
}
async function uninstallCommand(options) {
  try {
    const validOptions = UninstallCommandOptionsSchema.parse(options);
    const allInstallations = await detectInstallations();
    if (allInstallations.length === 0) {
      logger.info("No ClaudeKit installations found.");
      return;
    }
    if (validOptions.kit) {
      let kitFound = false;
      for (const inst of allInstallations) {
        const metadata = await ManifestWriter.readManifest(inst.path);
        if (metadata) {
          const installedKits = getInstalledKits(metadata);
          if (installedKits.includes(validOptions.kit)) {
            kitFound = true;
            break;
          }
        }
      }
      if (!kitFound) {
        logger.info(`Kit "${validOptions.kit}" is not installed.`);
        return;
      }
    }
    const isAtHome = PathResolver.isLocalSameAsGlobal();
    if (validOptions.local && !validOptions.global && isAtHome) {
      log.warn(import_picocolors22.default.yellow("Cannot use --local at HOME directory (local path equals global path)."));
      log.info("Use -g/--global or run from a project directory.");
      return;
    }
    let scope;
    if (validOptions.all || validOptions.local && validOptions.global) {
      scope = "all";
    } else if (validOptions.local) {
      scope = "local";
    } else if (validOptions.global) {
      scope = "global";
    } else if (isAtHome) {
      log.info(import_picocolors22.default.cyan("Running at HOME directory - targeting global installation"));
      scope = "global";
    } else {
      const promptedScope = await promptScope(allInstallations);
      if (!promptedScope) {
        logger.info("Uninstall cancelled.");
        return;
      }
      scope = promptedScope;
    }
    const installations = allInstallations.filter((i) => {
      if (scope === "all")
        return true;
      return i.type === scope;
    });
    if (installations.length === 0) {
      const scopeLabel = scope === "local" ? "local" : "global";
      logger.info(`No ${scopeLabel} ClaudeKit installation found.`);
      return;
    }
    displayInstallations(installations, scope);
    if (validOptions.kit) {
      log.info(import_picocolors22.default.cyan(`Kit-scoped uninstall: ${validOptions.kit} kit only`));
    }
    if (validOptions.dryRun) {
      log.info(import_picocolors22.default.yellow("DRY RUN MODE - No files will be deleted"));
      await removeInstallations(installations, {
        dryRun: true,
        forceOverwrite: validOptions.forceOverwrite,
        kit: validOptions.kit
      });
      prompts.outro("Dry-run complete. No changes were made.");
      return;
    }
    if (validOptions.forceOverwrite) {
      log.warn(`${import_picocolors22.default.yellow(import_picocolors22.default.bold("FORCE MODE ENABLED"))}
${import_picocolors22.default.yellow("User modifications will be permanently deleted!")}`);
    }
    if (!validOptions.yes) {
      const kitLabel = validOptions.kit ? ` (${validOptions.kit} kit only)` : "";
      const confirmed = await confirmUninstall(scope, kitLabel);
      if (!confirmed) {
        logger.info("Uninstall cancelled.");
        return;
      }
    }
    await removeInstallations(installations, {
      dryRun: false,
      forceOverwrite: validOptions.forceOverwrite,
      kit: validOptions.kit
    });
    const kitMsg = validOptions.kit ? ` (${validOptions.kit} kit)` : "";
    prompts.outro(`ClaudeKit${kitMsg} uninstalled successfully!`);
  } catch (error) {
    logger.error(error instanceof Error ? error.message : "Unknown error");
    process.exit(1);
  }
}
// src/commands/update-cli.ts
import { exec as exec8 } from "node:child_process";
import { join as join77 } from "node:path";
import { promisify as promisify8 } from "node:util";

// src/domains/github/npm-registry.ts
init_logger();
var DEFAULT_REGISTRY_URL = "https://registry.npmjs.org";
var REQUEST_TIMEOUT = 5000;
async function fetchWithTimeout(url, options = {}, timeout = REQUEST_TIMEOUT) {
  const controller = new AbortController;
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal
    });
    return response;
  } finally {
    clearTimeout(timeoutId);
  }
}

class NpmRegistryClient {
  static async getPackageInfo(packageName, registryUrl) {
    if (!packageName || typeof packageName !== "string" || packageName.trim() === "") {
      throw new Error("Invalid package name: must be a non-empty string");
    }
    const registry = registryUrl || DEFAULT_REGISTRY_URL;
    const url = `${registry}/${encodeURIComponent(packageName)}`;
    logger.debug(`Fetching package info from: ${url}`);
    try {
      const response = await fetchWithTimeout(url, {
        headers: {
          Accept: "application/json"
        }
      });
      if (!response.ok) {
        if (response.status === 404) {
          logger.debug(`Package not found: ${packageName}`);
          return null;
        }
        throw new Error(`Registry returned ${response.status}: ${response.statusText}`);
      }
      const data = await response.json();
      logger.debug(`Package info fetched: ${packageName}@${data["dist-tags"]?.latest}`);
      return data;
    } catch (error) {
      if (error instanceof Error && error.name === "AbortError") {
        logger.debug(`Request timeout for ${packageName}`);
        throw new Error(`Request timeout fetching ${packageName} from npm registry`);
      }
      throw error;
    }
  }
  static async getLatestVersion(packageName, registryUrl) {
    try {
      const info = await NpmRegistryClient.getPackageInfo(packageName, registryUrl);
      if (!info)
        return null;
      const latestVersion = info["dist-tags"]?.latest;
      if (!latestVersion) {
        logger.debug(`No latest version found for ${packageName}`);
        return null;
      }
      return latestVersion;
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      logger.debug(`Failed to get latest version for ${packageName}: ${message}`);
      return null;
    }
  }
  static async getBetaVersion(packageName, registryUrl) {
    try {
      const info = await NpmRegistryClient.getPackageInfo(packageName, registryUrl);
      if (!info)
        return null;
      const betaVersion = info["dist-tags"]?.beta || info["dist-tags"]?.next;
      if (!betaVersion) {
        logger.debug(`No beta version found for ${packageName}`);
        return null;
      }
      return betaVersion;
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      logger.debug(`Failed to get beta version for ${packageName}: ${message}`);
      return null;
    }
  }
  static async versionExists(packageName, version, registryUrl) {
    try {
      const info = await NpmRegistryClient.getPackageInfo(packageName, registryUrl);
      if (!info)
        return false;
      const exists = version in (info.versions || {});
      logger.debug(`Version ${version} exists for ${packageName}: ${exists}`);
      return exists;
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      logger.debug(`Failed to check version ${version} for ${packageName}: ${message}`);
      return false;
    }
  }
  static async getVersionInfo(packageName, version, registryUrl) {
    try {
      const info = await NpmRegistryClient.getPackageInfo(packageName, registryUrl);
      if (!info)
        return null;
      const versionInfo = info.versions?.[version];
      if (!versionInfo) {
        logger.debug(`Version ${version} not found for ${packageName}`);
        return null;
      }
      return versionInfo;
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      logger.debug(`Failed to get version info for ${packageName}@${version}: ${message}`);
      return null;
    }
  }
  static async getAllVersions(packageName, registryUrl) {
    try {
      const info = await NpmRegistryClient.getPackageInfo(packageName, registryUrl);
      if (!info)
        return [];
      const versions = Object.keys(info.versions || {});
      versions.sort((a3, b3) => {
        const timeA = info.time?.[a3] ? new Date(info.time[a3]).getTime() : 0;
        const timeB = info.time?.[b3] ? new Date(info.time[b3]).getTime() : 0;
        return timeB - timeA;
      });
      return versions;
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      logger.debug(`Failed to get all versions for ${packageName}: ${message}`);
      return [];
    }
  }
}

// src/commands/update-cli.ts
init_logger();
init_types2();
init_types2();
var import_compare_versions3 = __toESM(require_umd(), 1);
var import_fs_extra36 = __toESM(require_lib(), 1);
// package.json
var package_default = {
  name: "claudekit-cli",
  version: "3.30.1",
  description: "CLI tool for bootstrapping and updating ClaudeKit projects",
  type: "module",
  repository: {
    type: "git",
    url: "git+https://github.com/mrgoonie/claudekit-cli.git"
  },
  publishConfig: {
    access: "public",
    registry: "https://registry.npmjs.org"
  },
  bin: {
    ck: "bin/ck.js"
  },
  files: [
    "bin/ck.js",
    "dist/index.js"
  ],
  scripts: {
    dev: "bun run src/index.ts",
    build: "bun build src/index.ts --outdir dist --target node --external @octokit/rest",
    compile: "bun build src/index.ts --compile --outfile ck",
    "compile:binary": "bun build src/index.ts --compile --outfile bin/ck",
    "compile:binaries": "node scripts/build-all-binaries.js",
    "check-version-sync": "node scripts/check-binary-version-sync.js",
    "build:platform-binaries": "bun run scripts/build-platform-binaries.js",
    test: "bun test",
    "test:watch": "bun test --watch",
    "test:quick": "./scripts/dev-quick-start.sh test",
    lint: "biome check .",
    "lint:fix": "biome check --fix .",
    "lint:fix-unsafe": "biome check --fix --unsafe .",
    format: "biome format --write .",
    typecheck: "tsc --noEmit",
    "dev:quick": "./scripts/dev-quick-start.sh",
    "dev:all": "./scripts/dev-quick-start.sh all",
    metrics: "bun run scripts/workflow-metrics.ts",
    "install:hooks": "./.githooks/install.sh"
  },
  keywords: [
    "cli",
    "claudekit",
    "boilerplate",
    "bootstrap",
    "template"
  ],
  author: "ClaudeKit",
  license: "MIT",
  engines: {
    bun: ">=1.3.2",
    node: ">=18.0.0"
  },
  dependencies: {
    "@clack/prompts": "^0.7.0",
    "@octokit/rest": "^22.0.0",
    cac: "^6.7.14",
    "cli-progress": "^3.12.0",
    "compare-versions": "^6.1.1",
    diff: "^8.0.2",
    "extract-zip": "^2.0.1",
    "fs-extra": "^11.2.0",
    ignore: "^5.3.2",
    minimatch: "^10.1.1",
    ora: "^8.0.0",
    "p-limit": "^7.2.0",
    picocolors: "^1.1.1",
    "proper-lockfile": "^4.1.2",
    semver: "^7.7.3",
    tar: "^7.4.3",
    tmp: "^0.2.3",
    zod: "^3.23.8"
  },
  devDependencies: {
    "@biomejs/biome": "^1.9.4",
    "@semantic-release/changelog": "^6.0.3",
    "@semantic-release/git": "^10.0.1",
    "@types/bun": "latest",
    "@types/cli-progress": "^3.11.6",
    "@types/diff": "^8.0.0",
    "@types/fs-extra": "^11.0.4",
    "@types/node": "^22.10.1",
    "@types/proper-lockfile": "^4.1.4",
    "@types/semver": "^7.7.1",
    "@types/tar": "^6.1.13",
    "@types/tmp": "^0.2.6",
    "semantic-release": "^24.2.0",
    typescript: "^5.7.2"
  }
};

// src/commands/update-cli.ts
var execAsync8 = promisify8(exec8);

class CliUpdateError extends ClaudeKitError {
  constructor(message) {
    super(message, "CLI_UPDATE_ERROR");
    this.name = "CliUpdateError";
  }
}
var PACKAGE_NAME = "claudekit-cli";
function buildInitCommand(isGlobal, kit, beta) {
  const parts = ["ck init"];
  if (isGlobal)
    parts.push("-g");
  if (kit)
    parts.push(`--kit ${kit}`);
  parts.push("--yes --install-skills");
  if (beta)
    parts.push("--beta");
  return parts.join(" ");
}
function isBetaVersion(version) {
  if (!version)
    return false;
  return /-(beta|alpha|rc)[.\d]/i.test(version);
}
function selectKitForUpdate(params) {
  const { hasLocal, hasGlobal, localKits, globalKits } = params;
  const hasLocalKit = localKits.length > 0 || hasLocal;
  const hasGlobalKit = globalKits.length > 0 || hasGlobal;
  if (!hasLocalKit && !hasGlobalKit) {
    return null;
  }
  if (hasGlobalKit && !hasLocalKit) {
    const kit2 = globalKits[0] || localKits[0];
    return {
      isGlobal: true,
      kit: kit2,
      promptMessage: `Update global ClaudeKit content${kit2 ? ` (${kit2})` : ""}?`
    };
  }
  if (hasLocalKit && !hasGlobalKit) {
    const kit2 = localKits[0] || globalKits[0];
    return {
      isGlobal: false,
      kit: kit2,
      promptMessage: `Update local project ClaudeKit content${kit2 ? ` (${kit2})` : ""}?`
    };
  }
  const kit = globalKits[0] || localKits[0];
  return {
    isGlobal: true,
    kit,
    promptMessage: `Update global ClaudeKit content${kit ? ` (${kit})` : ""}?`
  };
}
async function readMetadataFile(claudeDir) {
  const metadataPath = join77(claudeDir, "metadata.json");
  try {
    if (!await import_fs_extra36.pathExists(metadataPath)) {
      return null;
    }
    const content = await import_fs_extra36.readFile(metadataPath, "utf-8");
    const parsed = JSON.parse(content);
    const validated = MetadataSchema.safeParse(parsed);
    if (!validated.success) {
      logger.verbose(`Invalid metadata format: ${validated.error.message}`);
      return null;
    }
    return validated.data;
  } catch (error) {
    logger.verbose(`Failed to read metadata: ${error instanceof Error ? error.message : "unknown"}`);
    return null;
  }
}
async function promptKitUpdate(beta) {
  try {
    const setup = await getClaudeKitSetup();
    const hasLocal = !!setup.project.metadata;
    const hasGlobal = !!setup.global.metadata;
    const localMetadata = hasLocal ? await readMetadataFile(setup.project.path) : null;
    const globalMetadata = hasGlobal ? await readMetadataFile(setup.global.path) : null;
    const localKits = localMetadata ? getInstalledKits(localMetadata) : [];
    const globalKits = globalMetadata ? getInstalledKits(globalMetadata) : [];
    const selection = selectKitForUpdate({ hasLocal, hasGlobal, localKits, globalKits });
    if (!selection) {
      logger.verbose("No ClaudeKit installations detected, skipping kit update prompt");
      return;
    }
    const kitVersion = selection.kit ? selection.isGlobal ? globalMetadata?.kits?.[selection.kit]?.version : localMetadata?.kits?.[selection.kit]?.version : undefined;
    const isBetaInstalled = isBetaVersion(kitVersion);
    const initCmd = buildInitCommand(selection.isGlobal, selection.kit, beta || isBetaInstalled);
    const promptMessage = selection.promptMessage;
    logger.info("");
    const shouldUpdate = await se({
      message: promptMessage
    });
    if (lD(shouldUpdate) || !shouldUpdate) {
      log.info("Skipped kit content update");
      return;
    }
    logger.info(`Running: ${initCmd}`);
    const s = de();
    s.start("Updating ClaudeKit content...");
    try {
      await execAsync8(initCmd, {
        timeout: 300000
      });
      s.stop("Kit content updated");
    } catch (error) {
      s.stop("Kit update finished");
      const errorMsg = error instanceof Error ? error.message : "unknown";
      if (errorMsg.includes("exit code") && !errorMsg.includes("exit code 0")) {
        logger.warning("Kit content update may have encountered issues");
        logger.verbose(`Error: ${errorMsg}`);
      } else {
        logger.verbose(`Init command completed: ${errorMsg}`);
      }
    }
  } catch (error) {
    logger.verbose(`Failed to prompt for kit update: ${error instanceof Error ? error.message : "unknown error"}`);
  }
}
async function updateCliCommand(options) {
  const s = de();
  intro("[>] ClaudeKit CLI - Update");
  try {
    const opts = UpdateCliOptionsSchema.parse(options);
    const currentVersion = package_default.version;
    logger.info(`Current CLI version: ${currentVersion}`);
    s.start("Detecting package manager...");
    const pm = await PackageManagerDetector.detect();
    const pmVersion = await PackageManagerDetector.getVersion(pm);
    s.stop(`Using ${PackageManagerDetector.getDisplayName(pm)}${pmVersion ? ` v${pmVersion}` : ""}`);
    logger.verbose(`Detected package manager: ${pm}`);
    s.start("Checking for updates...");
    let targetVersion = null;
    if (opts.release && opts.release !== "latest") {
      const exists = await NpmRegistryClient.versionExists(PACKAGE_NAME, opts.release, opts.registry);
      if (!exists) {
        s.stop("Version not found");
        throw new CliUpdateError(`Version ${opts.release} does not exist on npm registry. Run 'ck versions' to see available versions.`);
      }
      targetVersion = opts.release;
      s.stop(`Target version: ${targetVersion}`);
    } else if (opts.beta) {
      targetVersion = await NpmRegistryClient.getBetaVersion(PACKAGE_NAME, opts.registry);
      if (!targetVersion) {
        s.stop("No beta version available");
        logger.warning("No beta version found. Using latest stable version instead.");
        targetVersion = await NpmRegistryClient.getLatestVersion(PACKAGE_NAME, opts.registry);
      } else {
        s.stop(`Latest beta version: ${targetVersion}`);
      }
    } else {
      targetVersion = await NpmRegistryClient.getLatestVersion(PACKAGE_NAME, opts.registry);
      s.stop(`Latest version: ${targetVersion || "unknown"}`);
    }
    if (!targetVersion) {
      throw new CliUpdateError(`Failed to fetch version information from npm registry. Check your internet connection and try again. Manual update: ${PackageManagerDetector.getUpdateCommand(pm, PACKAGE_NAME)}`);
    }
    const comparison = import_compare_versions3.compareVersions(currentVersion, targetVersion);
    if (comparison === 0) {
      outro(`[+] Already on the latest CLI version (${currentVersion})`);
      await promptKitUpdate(opts.beta);
      return;
    }
    if (comparison > 0 && !opts.release) {
      outro(`[+] Current version (${currentVersion}) is newer than latest (${targetVersion})`);
      return;
    }
    const isUpgrade = comparison < 0;
    const changeType = isUpgrade ? "upgrade" : "downgrade";
    logger.info(`${isUpgrade ? "[^]" : "[v]"}  ${changeType}: ${currentVersion} -> ${targetVersion}`);
    if (opts.check) {
      note(`CLI update available: ${currentVersion} -> ${targetVersion}

Run 'ck update' to install`, "Update Check");
      await promptKitUpdate(opts.beta);
      outro("Check complete");
      return;
    }
    if (!opts.yes) {
      const shouldUpdate = await se({
        message: `${isUpgrade ? "Update" : "Downgrade"} CLI from ${currentVersion} to ${targetVersion}?`
      });
      if (lD(shouldUpdate) || !shouldUpdate) {
        outro("Update cancelled");
        return;
      }
    }
    const updateCmd = PackageManagerDetector.getUpdateCommand(pm, PACKAGE_NAME, targetVersion);
    logger.info(`Running: ${updateCmd}`);
    s.start("Updating CLI...");
    try {
      await execAsync8(updateCmd, {
        timeout: 120000
      });
      s.stop("Update completed");
    } catch (error) {
      s.stop("Update failed");
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      if (errorMessage.includes("EACCES") || errorMessage.includes("EPERM") || errorMessage.includes("permission") || errorMessage.includes("Access is denied")) {
        throw new CliUpdateError(`Permission denied. Try: sudo ${updateCmd}

Or fix npm permissions: https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally`);
      }
      throw new CliUpdateError(`Update failed: ${errorMessage}

Manual update: ${updateCmd}`);
    }
    s.start("Verifying installation...");
    try {
      const { stdout: stdout2 } = await execAsync8("ck --version", { timeout: 5000 });
      const newVersionMatch = stdout2.match(/CLI Version:\s*(\S+)/);
      const newVersion = newVersionMatch ? newVersionMatch[1] : targetVersion;
      s.stop(`Installed version: ${newVersion}`);
      outro(`[+] Successfully updated ClaudeKit CLI to ${newVersion}`);
      await promptKitUpdate(opts.beta);
    } catch {
      s.stop("Verification completed");
      outro(`[+] Update completed. Please restart your terminal to use CLI ${targetVersion}`);
      await promptKitUpdate(opts.beta);
    }
  } catch (error) {
    if (error instanceof CliUpdateError) {
      logger.error(error.message);
      throw error;
    }
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    logger.error(`Update failed: ${errorMessage}`);
    throw new CliUpdateError(errorMessage);
  }
}

// src/commands/version.ts
init_github_client();
init_logger();
init_types2();
var import_picocolors23 = __toESM(require_picocolors(), 1);
function formatRelativeTime(dateString) {
  if (!dateString)
    return "Unknown";
  const date = new Date(dateString);
  const now = new Date;
  const diffMs = now.getTime() - date.getTime();
  const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
  if (diffDays === 0)
    return "Today";
  if (diffDays === 1)
    return "Yesterday";
  if (diffDays < 7)
    return `${diffDays} days ago`;
  if (diffDays < 30)
    return `${Math.floor(diffDays / 7)} weeks ago`;
  if (diffDays < 365)
    return `${Math.floor(diffDays / 30)} months ago`;
  return `${Math.floor(diffDays / 365)} years ago`;
}
function displayKitReleases(kitName, releases) {
  console.log(`
${import_picocolors23.default.bold(import_picocolors23.default.cyan(kitName))} - Available Versions:
`);
  if (releases.length === 0) {
    console.log(import_picocolors23.default.dim("  No releases found"));
    return;
  }
  for (const release of releases) {
    const version = import_picocolors23.default.green(release.tag_name);
    const name2 = release.name || "No title";
    const publishedAt = formatRelativeTime(release.published_at);
    const assetCount = release.assets.length;
    const badges = [];
    if (release.prerelease)
      badges.push(import_picocolors23.default.yellow("[prerelease]"));
    if (release.draft)
      badges.push(import_picocolors23.default.gray("[draft]"));
    const badgeStr = badges.length > 0 ? ` ${badges.join(" ")}` : "";
    const versionPart = version.padEnd(20);
    const namePart = name2.length > 40 ? `${name2.slice(0, 37)}...` : name2.padEnd(40);
    const timePart = import_picocolors23.default.dim(publishedAt.padEnd(20));
    const assetPart = import_picocolors23.default.dim(`(${assetCount} ${assetCount === 1 ? "asset" : "assets"})`);
    console.log(`  ${versionPart}  ${namePart}  ${timePart}  ${assetPart}${badgeStr}`);
  }
  console.log(import_picocolors23.default.dim(`
Showing ${releases.length} ${releases.length === 1 ? "release" : "releases"}`));
}
async function versionCommand(options) {
  const prompts2 = new PromptsManager;
  prompts2.intro("\uD83D\uDCE6 ClaudeKit - Available Versions");
  try {
    const validOptions = VersionCommandOptionsSchema.parse(options);
    const kitsToFetch = validOptions.kit ? [validOptions.kit] : Object.keys(AVAILABLE_KITS);
    const github = new GitHubClient;
    const limit = validOptions.limit || 30;
    const releasePromises = kitsToFetch.map(async (kitType) => {
      const kitConfig = AVAILABLE_KITS[kitType];
      try {
        const releases = await github.listReleases(kitConfig, limit);
        const filteredReleases = validOptions.all ? releases : releases.filter((r2) => !r2.draft && !r2.prerelease);
        return {
          kitType,
          kitConfig,
          releases: filteredReleases,
          error: null
        };
      } catch (error) {
        return {
          kitType,
          kitConfig,
          releases: [],
          error: error instanceof Error ? error.message : "Unknown error"
        };
      }
    });
    const results = await Promise.all(releasePromises);
    for (const result of results) {
      if (result.error) {
        console.log(`
${import_picocolors23.default.bold(import_picocolors23.default.cyan(result.kitConfig.name))} - ${import_picocolors23.default.red("Error")}`);
        console.log(import_picocolors23.default.dim(`  ${result.error}`));
      } else {
        displayKitReleases(result.kitConfig.name, result.releases);
      }
    }
    prompts2.outro(" Done");
  } catch (error) {
    logger.error(error instanceof Error ? error.message : "Unknown error occurred");
    process.exit(1);
  }
}

// src/cli/command-registry.ts
init_logger();
function registerCommands(cli) {
  cli.command("new", "Bootstrap a new ClaudeKit project (with interactive version selection)").option("--dir <dir>", "Target directory (default: .)").option("--kit <kit>", "Kit to use: engineer, marketing, all, or comma-separated").option("-r, --release <version>", "Skip version selection, use specific version (e.g., latest, v1.0.0)").option("--force", "Overwrite existing files without confirmation").option("--exclude <pattern>", "Exclude files matching glob pattern (can be used multiple times)").option("--opencode", "Install OpenCode CLI package (non-interactive mode)").option("--gemini", "Install Google Gemini CLI package (non-interactive mode)").option("--install-skills", "Install skills dependencies (non-interactive mode)").option("--with-sudo", "Include system packages requiring sudo (Linux: ffmpeg, imagemagick)").option("--prefix", "Add /ck: prefix to all slash commands by moving them to commands/ck/ subdirectory").option("--beta", "Show beta versions in selection prompt").option("--refresh", "Bypass release cache to fetch latest versions from GitHub").option("--docs-dir <name>", "Custom docs folder name (default: docs)").option("--plans-dir <name>", "Custom plans folder name (default: plans)").option("-y, --yes", "Non-interactive mode with sensible defaults (skip all prompts)").option("--use-git", "Use git clone instead of GitHub API (uses SSH/HTTPS credentials)").option("--archive <path>", "Use local archive file instead of downloading (zip/tar.gz)").option("--kit-path <path>", "Use local kit directory instead of downloading").action(async (options) => {
    if (options.exclude && !Array.isArray(options.exclude)) {
      options.exclude = [options.exclude];
    }
    await newCommand(options);
  });
  cli.command("init", "Initialize or update ClaudeKit project (with interactive version selection)").option("--dir <dir>", "Target directory (default: .)").option("--kit <kit>", "Kit to use: engineer, marketing, all, or comma-separated").option("-r, --release <version>", "Skip version selection, use specific version (e.g., latest, v1.0.0)").option("--exclude <pattern>", "Exclude files matching glob pattern (can be used multiple times)").option("--only <pattern>", "Include only files matching glob pattern (can be used multiple times)").option("-g, --global", "Use platform-specific user configuration directory").option("--fresh", "Completely remove .claude directory before downloading (requires confirmation)").option("--install-skills", "Install skills dependencies (non-interactive mode)").option("--with-sudo", "Include system packages requiring sudo (Linux: ffmpeg, imagemagick)").option("--prefix", "Add /ck: prefix to all slash commands by moving them to commands/ck/ subdirectory").option("--beta", "Show beta versions in selection prompt").option("--refresh", "Bypass release cache to fetch latest versions from GitHub").option("--dry-run", "Preview changes without applying them (requires --prefix)").option("--force-overwrite", "Override ownership protections and delete user-modified files (requires --prefix)").option("--force-overwrite-settings", "Fully replace settings.json instead of selective merge (destroys user customizations)").option("--skip-setup", "Skip interactive configuration wizard").option("--docs-dir <name>", "Custom docs folder name (default: docs)").option("--plans-dir <name>", "Custom plans folder name (default: plans)").option("-y, --yes", "Non-interactive mode with sensible defaults (skip all prompts)").option("--sync", "Sync config files from upstream with interactive hunk-by-hunk merge").option("--use-git", "Use git clone instead of GitHub API (uses SSH/HTTPS credentials)").option("--archive <path>", "Use local archive file instead of downloading (zip/tar.gz)").option("--kit-path <path>", "Use local kit directory instead of downloading").action(async (options) => {
    if (options.exclude && !Array.isArray(options.exclude)) {
      options.exclude = [options.exclude];
    }
    if (options.only && !Array.isArray(options.only)) {
      options.only = [options.only];
    }
    await initCommand(options);
  });
  cli.command("update", "Update ClaudeKit CLI to the latest version").option("-r, --release <version>", "Update to a specific version").option("--check", "Check for updates without installing").option("-y, --yes", "Non-interactive mode with sensible defaults (skip all prompts)").option("--beta", "Update to the latest beta version").option("--registry <url>", "Custom npm registry URL").option("--kit <kit>", "[DEPRECATED] Use 'ck init --kit <kit>' instead").option("-g, --global", "[DEPRECATED] Use 'ck init --global' instead").action(async (options) => {
    if (options.kit || options.global) {
      console.log();
      const deprecatedFlags = [options.kit && "--kit", options.global && "--global"].filter(Boolean).join(" and ");
      logger.warning(`The ${deprecatedFlags} option${options.kit && options.global ? "s are" : " is"} no longer supported with 'ck update'`);
      console.log();
      console.log("  'ck update' now only updates the ClaudeKit CLI itself.");
      console.log();
      console.log("  To update a kit installation, use:");
      const suggestedCmd = ["ck init"];
      if (options.kit)
        suggestedCmd.push(`--kit ${options.kit}`);
      if (options.global)
        suggestedCmd.push("--global");
      console.log(`    ${suggestedCmd.join(" ")}`);
      console.log();
      process.exit(0);
    }
    try {
      await updateCliCommand(options);
    } catch (error) {
      process.exit(1);
    }
  });
  cli.command("versions", "List available versions of ClaudeKit repositories").option("--kit <kit>", "Filter by specific kit (engineer, marketing)").option("--limit <limit>", "Number of releases to show (default: 30)").option("--all", "Show all releases including prereleases").action(async (options) => {
    await versionCommand(options);
  });
  cli.command("doctor", "Comprehensive health check for ClaudeKit").option("--report", "Generate shareable diagnostic report").option("--fix", "Auto-fix all fixable issues").option("--check-only", "CI mode: no prompts, exit 1 on failures").option("--json", "Output JSON format").option("--full", "Include extended priority checks (slower)").action(async (options) => {
    await doctorCommand(options);
  });
  cli.command("uninstall", "Remove ClaudeKit installations").option("-y, --yes", "Non-interactive mode with sensible defaults (skip all prompts)").option("-l, --local", "Uninstall only local installation (current project)").option("-g, --global", "Uninstall only global installation (~/.claude/)").option("-A, --all", "Uninstall from both local and global locations").option("-k, --kit <type>", "Uninstall specific kit only (engineer, marketing)").option("--dry-run", "Preview what would be removed without deleting").option("--force-overwrite", "Delete even user-modified files (requires confirmation)").action(async (options) => {
    await uninstallCommand(options);
  });
  cli.command("easter-egg", "\uD83E\uDD5A Roll for a random discount code (Code Hunt 2025)").action(async () => {
    await easterEggCommand();
  });
}

// src/cli/version-display.ts
import { existsSync as existsSync21, readFileSync as readFileSync7 } from "node:fs";
import { join as join79 } from "node:path";

// src/domains/versioning/checking/version-utils.ts
var import_compare_versions4 = __toESM(require_umd(), 1);
function isUpdateCheckDisabled() {
  return process.env.NO_UPDATE_NOTIFIER === "1" || process.env.NO_UPDATE_NOTIFIER === "true" || !process.stdout.isTTY;
}
function normalizeVersion(version) {
  return version.replace(/^v/, "");
}
function isNewerVersion(currentVersion, latestVersion) {
  try {
    const current = normalizeVersion(currentVersion);
    const latest = normalizeVersion(latestVersion);
    return import_compare_versions4.compareVersions(latest, current) > 0;
  } catch {
    return false;
  }
}
// src/domains/versioning/checking/kit-version-checker.ts
init_github_client();
init_logger();
init_types2();

// src/domains/versioning/version-cache.ts
init_logger();
init_path_resolver();
import { existsSync as existsSync20 } from "node:fs";
import { mkdir as mkdir22, readFile as readFile27, writeFile as writeFile23 } from "node:fs/promises";
import { join as join78 } from "node:path";

class VersionCacheManager {
  static CACHE_FILENAME = "version-check.json";
  static CACHE_TTL_MS = 7 * 24 * 60 * 60 * 1000;
  static getCacheFile() {
    const cacheDir = PathResolver.getCacheDir(false);
    return join78(cacheDir, VersionCacheManager.CACHE_FILENAME);
  }
  static async load() {
    const cacheFile = VersionCacheManager.getCacheFile();
    try {
      if (!existsSync20(cacheFile)) {
        logger.debug("Version check cache not found");
        return null;
      }
      const content = await readFile27(cacheFile, "utf-8");
      const cache2 = JSON.parse(content);
      if (!cache2.lastCheck || !cache2.currentVersion || !cache2.latestVersion) {
        logger.debug("Invalid cache structure, ignoring");
        return null;
      }
      logger.debug(`Version check cache loaded: ${JSON.stringify(cache2)}`);
      return cache2;
    } catch (error) {
      logger.debug(`Failed to load version check cache: ${error}`);
      return null;
    }
  }
  static async save(cache2) {
    const cacheFile = VersionCacheManager.getCacheFile();
    const cacheDir = PathResolver.getCacheDir(false);
    try {
      if (!existsSync20(cacheDir)) {
        await mkdir22(cacheDir, { recursive: true, mode: 448 });
      }
      await writeFile23(cacheFile, JSON.stringify(cache2, null, 2), "utf-8");
      logger.debug(`Version check cache saved to ${cacheFile}`);
    } catch (error) {
      logger.debug(`Failed to save version check cache: ${error}`);
    }
  }
  static isCacheValid(cache2) {
    if (!cache2)
      return false;
    const now = Date.now();
    const age = now - cache2.lastCheck;
    const isValid2 = age < VersionCacheManager.CACHE_TTL_MS;
    const ageDays = (age / 1000 / 60 / 60 / 24).toFixed(1);
    logger.debug(`Cache validity check: age=${ageDays} days, valid=${isValid2}`);
    return isValid2;
  }
  static async clear() {
    const cacheFile = VersionCacheManager.getCacheFile();
    try {
      if (existsSync20(cacheFile)) {
        const fs14 = await import("node:fs/promises");
        await fs14.unlink(cacheFile);
        logger.debug("Version check cache cleared");
      }
    } catch (error) {
      logger.debug(`Failed to clear version check cache: ${error}`);
    }
  }
}

// src/domains/versioning/checking/kit-version-checker.ts
async function fetchLatestRelease(currentVersion) {
  try {
    const githubClient = new GitHubClient;
    const kit = AVAILABLE_KITS.engineer;
    const timeoutPromise = new Promise((_3, reject) => setTimeout(() => reject(new Error("Timeout")), 5000));
    const releasePromise = githubClient.getLatestRelease(kit);
    const release = await Promise.race([releasePromise, timeoutPromise]);
    const latestVersion = release.tag_name;
    const updateAvailable = isNewerVersion(currentVersion, latestVersion);
    const releaseUrl = `https://github.com/${kit.owner}/${kit.repo}/releases/tag/${latestVersion}`;
    logger.debug(`Fetched latest release: current=${currentVersion}, latest=${latestVersion}, updateAvailable=${updateAvailable}`);
    return {
      currentVersion,
      latestVersion,
      updateAvailable,
      releaseUrl
    };
  } catch (error) {
    logger.debug(`Failed to fetch latest release: ${error}`);
    return null;
  }
}

class VersionChecker {
  static async check(currentVersion) {
    if (isUpdateCheckDisabled()) {
      logger.debug("Update check disabled by environment");
      return null;
    }
    const cache2 = await VersionCacheManager.load();
    if (cache2 && VersionCacheManager.isCacheValid(cache2) && cache2.currentVersion === currentVersion) {
      logger.debug("Using cached version check result");
      return {
        currentVersion: cache2.currentVersion,
        latestVersion: cache2.latestVersion,
        updateAvailable: cache2.updateAvailable,
        releaseUrl: cache2.latestUrl
      };
    }
    logger.debug("Cache expired or invalid, fetching latest release");
    const result = await fetchLatestRelease(currentVersion);
    if (result) {
      await VersionCacheManager.save({
        lastCheck: Date.now(),
        currentVersion: result.currentVersion,
        latestVersion: result.latestVersion,
        latestUrl: result.releaseUrl,
        updateAvailable: result.updateAvailable
      });
    }
    return result;
  }
}
// src/domains/versioning/checking/cli-version-checker.ts
init_logger();
var import_compare_versions5 = __toESM(require_umd(), 1);
var PACKAGE_NAME2 = "claudekit-cli";

class CliVersionChecker {
  static async check(currentVersion) {
    if (isUpdateCheckDisabled()) {
      logger.debug("CLI update check disabled by environment");
      return null;
    }
    try {
      const latestVersion = await NpmRegistryClient.getLatestVersion(PACKAGE_NAME2);
      if (!latestVersion) {
        logger.debug("Failed to fetch latest CLI version from npm");
        return null;
      }
      const current = normalizeVersion(currentVersion);
      const latest = normalizeVersion(latestVersion);
      const updateAvailable = import_compare_versions5.compareVersions(latest, current) > 0;
      logger.debug(`CLI version check: current=${current}, latest=${latest}, updateAvailable=${updateAvailable}`);
      return {
        currentVersion: current,
        latestVersion: latest,
        updateAvailable,
        releaseUrl: `https://www.npmjs.com/package/${PACKAGE_NAME2}`
      };
    } catch (error) {
      logger.debug(`CLI version check failed: ${error}`);
      return null;
    }
  }
}
// src/domains/versioning/checking/notification-display.ts
var import_picocolors24 = __toESM(require_picocolors(), 1);
function createNotificationBox2(borderColor, boxWidth) {
  const contentWidth = boxWidth - 2;
  const topBorder = borderColor(`${"".repeat(contentWidth)}`);
  const bottomBorder = borderColor(`${"".repeat(contentWidth)}`);
  const emptyLine = borderColor("") + " ".repeat(contentWidth) + borderColor("");
  const padLine = (text, visibleLen) => {
    const len = visibleLen ?? text.length;
    const displayText = len > contentWidth ? `${text.slice(0, contentWidth - 3)}...` : text;
    const actualLen = visibleLen ?? displayText.length;
    const totalPadding = contentWidth - actualLen;
    const leftPadding = Math.max(0, Math.floor(totalPadding / 2));
    const rightPadding = Math.max(0, totalPadding - leftPadding);
    return borderColor("") + " ".repeat(leftPadding) + displayText + " ".repeat(rightPadding) + borderColor("");
  };
  return { topBorder, bottomBorder, emptyLine, padLine };
}
function displayKitNotification(result, options = {}) {
  if (!result.updateAvailable)
    return;
  const { currentVersion, latestVersion } = result;
  const { isGlobal = false } = options;
  const displayCurrent = normalizeVersion(currentVersion);
  const displayLatest = normalizeVersion(latestVersion);
  const boxWidth = 52;
  const { topBorder, bottomBorder, emptyLine, padLine } = createNotificationBox2(import_picocolors24.default.cyan, boxWidth);
  const headerText = import_picocolors24.default.bold(import_picocolors24.default.yellow(" Kit Update Available"));
  const headerLen = " Kit Update Available".length;
  const versionText = `${import_picocolors24.default.dim(displayCurrent)} ${import_picocolors24.default.white("")} ${import_picocolors24.default.green(import_picocolors24.default.bold(displayLatest))}`;
  const versionLen = displayCurrent.length + 3 + displayLatest.length;
  const updateCmd = isGlobal ? "ck init -g" : "ck init";
  const commandText = `Run: ${import_picocolors24.default.cyan(import_picocolors24.default.bold(updateCmd))}`;
  const commandLen = `Run: ${updateCmd}`.length;
  console.log("");
  console.log(topBorder);
  console.log(emptyLine);
  console.log(padLine(headerText, headerLen));
  console.log(padLine(versionText, versionLen));
  console.log(emptyLine);
  console.log(padLine(commandText, commandLen));
  console.log(emptyLine);
  console.log(bottomBorder);
  console.log("");
}
function displayCliNotification(result) {
  if (!result.updateAvailable)
    return;
  const { currentVersion, latestVersion } = result;
  const boxWidth = 52;
  const { topBorder, bottomBorder, emptyLine, padLine } = createNotificationBox2(import_picocolors24.default.magenta, boxWidth);
  const headerText = import_picocolors24.default.bold(import_picocolors24.default.yellow(" CLI Update Available"));
  const headerLen = " CLI Update Available".length;
  const versionText = `${import_picocolors24.default.dim(currentVersion)} ${import_picocolors24.default.white("")} ${import_picocolors24.default.green(import_picocolors24.default.bold(latestVersion))}`;
  const versionLen = currentVersion.length + 3 + latestVersion.length;
  const commandText = `Run: ${import_picocolors24.default.magenta(import_picocolors24.default.bold("ck update"))}`;
  const commandLen = "Run: ck update".length;
  console.log("");
  console.log(topBorder);
  console.log(emptyLine);
  console.log(padLine(headerText, headerLen));
  console.log(padLine(versionText, versionLen));
  console.log(emptyLine);
  console.log(padLine(commandText, commandLen));
  console.log(emptyLine);
  console.log(bottomBorder);
  console.log("");
}
// src/domains/versioning/version-checker.ts
class VersionChecker2 {
  static async check(currentVersion) {
    return VersionChecker.check(currentVersion);
  }
  static displayNotification(result, options = {}) {
    displayKitNotification(result, options);
  }
}

class CliVersionChecker2 {
  static async check(currentVersion) {
    return CliVersionChecker.check(currentVersion);
  }
  static displayNotification(result) {
    displayCliNotification(result);
  }
}

// src/cli/version-display.ts
init_logger();
init_path_resolver();
init_types2();
var packageVersion = package_default.version;
function formatInstalledKits(metadata) {
  if (!metadata.kits || Object.keys(metadata.kits).length === 0) {
    if (metadata.version) {
      const kitName = metadata.name || "ClaudeKit";
      return `${metadata.version} (${kitName})`;
    }
    return null;
  }
  const kitVersions = Object.entries(metadata.kits).filter(([_3, meta]) => meta.version && meta.version.trim() !== "").map(([kit, meta]) => `${kit}@${meta.version}`).sort().join(", ");
  return kitVersions.length > 0 ? kitVersions : null;
}
function getInstalledKitTypes(metadata) {
  if (!metadata.kits)
    return [];
  return Object.keys(metadata.kits);
}
function getFirstKitVersion(metadata) {
  const kitTypes = getInstalledKitTypes(metadata);
  if (kitTypes.length === 0) {
    return metadata.version ?? null;
  }
  const firstKit = kitTypes[0];
  return metadata.kits?.[firstKit]?.version ?? null;
}
async function displayVersion() {
  console.log(`CLI Version: ${packageVersion}`);
  let foundAnyKit = false;
  let localKitVersion = null;
  let isGlobalOnlyKit = false;
  const globalKitDir = PathResolver.getGlobalKitDir();
  const globalMetadataPath = join79(globalKitDir, "metadata.json");
  const prefix = PathResolver.getPathPrefix(false);
  const localMetadataPath = prefix ? join79(process.cwd(), prefix, "metadata.json") : join79(process.cwd(), "metadata.json");
  const isLocalSameAsGlobal = localMetadataPath === globalMetadataPath;
  if (!isLocalSameAsGlobal && existsSync21(localMetadataPath)) {
    try {
      const rawMetadata = JSON.parse(readFileSync7(localMetadataPath, "utf-8"));
      const metadata = MetadataSchema.parse(rawMetadata);
      const kitsDisplay = formatInstalledKits(metadata);
      if (kitsDisplay) {
        console.log(`Local Kit Version: ${kitsDisplay}`);
        localKitVersion = getFirstKitVersion(metadata);
        foundAnyKit = true;
      }
    } catch (error) {
      logger.verbose("Failed to parse local metadata.json", { error });
    }
  }
  if (existsSync21(globalMetadataPath)) {
    try {
      const rawMetadata = JSON.parse(readFileSync7(globalMetadataPath, "utf-8"));
      const metadata = MetadataSchema.parse(rawMetadata);
      const kitsDisplay = formatInstalledKits(metadata);
      if (kitsDisplay) {
        console.log(`Global Kit Version: ${kitsDisplay}`);
        if (!localKitVersion) {
          localKitVersion = getFirstKitVersion(metadata);
          isGlobalOnlyKit = true;
        }
        foundAnyKit = true;
      }
    } catch (error) {
      logger.verbose("Failed to parse global metadata.json", { error });
    }
  }
  if (!foundAnyKit) {
    console.log("No ClaudeKit installation found");
    console.log(`
To get started: ck new (local project) or ck init -g (global)`);
  }
  try {
    const cliUpdateCheck = await CliVersionChecker2.check(packageVersion);
    if (cliUpdateCheck?.updateAvailable) {
      CliVersionChecker2.displayNotification(cliUpdateCheck);
    }
  } catch (error) {
    logger.debug(`CLI version check failed: ${error}`);
  }
  if (localKitVersion) {
    try {
      const updateCheck = await VersionChecker2.check(localKitVersion);
      if (updateCheck?.updateAvailable) {
        VersionChecker2.displayNotification(updateCheck, { isGlobal: isGlobalOnlyKit });
      }
    } catch (error) {
      logger.debug(`Kit version check failed: ${error}`);
    }
  }
}
function getPackageVersion2() {
  return packageVersion;
}

// src/shared/logger.ts
var import_picocolors25 = __toESM(require_picocolors(), 1);
init_output_manager();
import { createWriteStream as createWriteStream3 } from "node:fs";

class Logger2 {
  verboseEnabled = false;
  logFileStream;
  exitHandlerRegistered = false;
  info(message) {
    const symbols = output.getSymbols();
    console.log(import_picocolors25.default.blue(symbols.info), message);
  }
  success(message) {
    const symbols = output.getSymbols();
    console.log(import_picocolors25.default.green(symbols.success), message);
  }
  warning(message) {
    const symbols = output.getSymbols();
    console.log(import_picocolors25.default.yellow(symbols.warning), message);
  }
  error(message) {
    const symbols = output.getSymbols();
    console.error(import_picocolors25.default.red(symbols.error), message);
  }
  debug(message) {
    if (process.env.DEBUG) {
      console.log(import_picocolors25.default.gray("[DEBUG]"), message);
    }
  }
  verbose(message, context) {
    if (!this.verboseEnabled)
      return;
    const timestamp = this.getTimestamp();
    const sanitizedMessage = this.sanitize(message);
    const formattedContext = context ? this.formatContext(context) : "";
    const logLine = `${timestamp} ${import_picocolors25.default.gray("[VERBOSE]")} ${sanitizedMessage}${formattedContext}`;
    console.error(logLine);
    if (this.logFileStream) {
      const plainLogLine = `${timestamp} [VERBOSE] ${sanitizedMessage}${formattedContext}`;
      this.logFileStream.write(`${plainLogLine}
`);
    }
  }
  setVerbose(enabled) {
    this.verboseEnabled = enabled;
    if (enabled) {
      this.verbose("Verbose logging enabled");
    }
  }
  isVerbose() {
    return this.verboseEnabled;
  }
  setLogFile(path11) {
    if (this.logFileStream) {
      this.logFileStream.end();
      this.logFileStream = undefined;
    }
    if (path11) {
      this.logFileStream = createWriteStream3(path11, {
        flags: "a",
        mode: 384
      });
      this.registerExitHandler();
      this.verbose(`Logging to file: ${path11}`);
    }
  }
  close() {
    if (this.logFileStream) {
      this.logFileStream.end();
      this.logFileStream = undefined;
    }
  }
  registerExitHandler() {
    if (this.exitHandlerRegistered)
      return;
    this.exitHandlerRegistered = true;
    const cleanup = () => {
      if (this.logFileStream) {
        try {
          this.logFileStream.end();
        } catch {}
        this.logFileStream = undefined;
      }
    };
    process.on("exit", cleanup);
    process.on("SIGINT", () => {
      cleanup();
      process.exit(130);
    });
    process.on("SIGTERM", () => {
      cleanup();
      process.exit(143);
    });
    process.on("uncaughtException", (error) => {
      if (this.logFileStream) {
        const timestamp = new Date().toISOString();
        this.logFileStream.write(`${timestamp} [FATAL] Uncaught exception: ${error.message}
`);
        this.logFileStream.write(`${error.stack}
`);
      }
      cleanup();
      process.exit(1);
    });
  }
  sanitize(text) {
    return text.replace(/ghp_[a-zA-Z0-9]{36}/g, "ghp_***").replace(/github_pat_[a-zA-Z0-9_]{82}/g, "github_pat_***").replace(/gho_[a-zA-Z0-9]{36}/g, "gho_***").replace(/ghu_[a-zA-Z0-9]{36}/g, "ghu_***").replace(/ghs_[a-zA-Z0-9]{36}/g, "ghs_***").replace(/ghr_[a-zA-Z0-9]{36}/g, "ghr_***").replace(/Bearer [a-zA-Z0-9_-]+/g, "Bearer ***").replace(/token=[a-zA-Z0-9_-]+/g, "token=***");
  }
  getTimestamp() {
    return new Date().toISOString();
  }
  formatContext(context) {
    const sanitized = Object.entries(context).reduce((acc, [key, value]) => {
      if (typeof value === "string") {
        acc[key] = this.sanitize(value);
      } else if (value && typeof value === "object") {
        try {
          const stringified = JSON.stringify(value);
          const sanitizedStr = this.sanitize(stringified);
          acc[key] = JSON.parse(sanitizedStr);
        } catch {
          acc[key] = "[Object]";
        }
      } else {
        acc[key] = value;
      }
      return acc;
    }, {});
    return `
  ${JSON.stringify(sanitized, null, 2).split(`
`).join(`
  `)}`;
  }
}
var logger3 = new Logger2;

// src/shared/output-manager.ts
var import_picocolors26 = __toESM(require_picocolors(), 1);
init_terminal_utils();
var SYMBOLS2 = {
  unicode: {
    prompt: "",
    success: "",
    error: "",
    warning: "",
    info: "",
    line: "",
    selected: "",
    unselected: "",
    pointer: ">",
    pass: "",
    warn: "",
    fail: "",
    infoStatus: ""
  },
  ascii: {
    prompt: "?",
    success: "+",
    error: "x",
    warning: "!",
    info: "i",
    line: "|",
    selected: ">",
    unselected: " ",
    pointer: ">",
    pass: "[PASS]",
    warn: "[WARN]",
    fail: "[FAIL]",
    infoStatus: "[INFO]"
  }
};
class OutputManager2 {
  config = {
    verbose: false,
    json: false,
    quiet: false
  };
  jsonBuffer = [];
  unicodeSupported;
  flushPromise = null;
  flushQueued = false;
  constructor() {
    this.unicodeSupported = supportsUnicode();
  }
  configure(config) {
    this.config = { ...this.config, ...config };
  }
  getConfig() {
    return { ...this.config };
  }
  isVerbose() {
    return this.config.verbose;
  }
  isJson() {
    return this.config.json;
  }
  isQuiet() {
    return this.config.quiet;
  }
  getSymbols() {
    return this.unicodeSupported ? SYMBOLS2.unicode : SYMBOLS2.ascii;
  }
  shouldShowProgress() {
    if (this.config.json)
      return false;
    if (!isTTY())
      return false;
    return true;
  }
  success(message, data) {
    if (this.config.json) {
      this.addJsonEntry({ type: "success", message, data });
      return;
    }
    if (this.config.quiet)
      return;
    const symbol = this.getSymbols().success;
    console.log(import_picocolors26.default.green(`${symbol} ${message}`));
  }
  error(message, data) {
    if (this.config.json) {
      this.addJsonEntry({ type: "error", message, data });
      return;
    }
    const symbol = this.getSymbols().error;
    console.error(import_picocolors26.default.red(`${symbol} ${message}`));
  }
  warning(message, data) {
    if (this.config.json) {
      this.addJsonEntry({ type: "warning", message, data });
      return;
    }
    if (this.config.quiet)
      return;
    const symbol = this.getSymbols().warning;
    console.log(import_picocolors26.default.yellow(`${symbol} ${message}`));
  }
  info(message, data) {
    if (this.config.json) {
      this.addJsonEntry({ type: "info", message, data });
      return;
    }
    if (this.config.quiet)
      return;
    const symbol = this.getSymbols().info;
    console.log(import_picocolors26.default.blue(`${symbol} ${message}`));
  }
  verbose(message, data) {
    if (!this.config.verbose)
      return;
    if (this.config.json) {
      this.addJsonEntry({ type: "info", message, data });
      return;
    }
    console.log(import_picocolors26.default.dim(`  ${message}`));
  }
  indent(message) {
    if (this.config.json)
      return;
    if (this.config.quiet)
      return;
    console.log(`  ${message}`);
  }
  newline() {
    if (this.config.json)
      return;
    if (this.config.quiet)
      return;
    console.log();
  }
  section(title) {
    if (this.config.json) {
      this.addJsonEntry({ type: "info", message: `[Section] ${title}` });
      return;
    }
    if (this.config.quiet)
      return;
    const symbols = this.getSymbols();
    console.log();
    console.log(import_picocolors26.default.bold(import_picocolors26.default.cyan(`${symbols.line} ${title}`)));
  }
  addJsonEntry(entry) {
    this.jsonBuffer.push({
      ...entry,
      timestamp: new Date().toISOString()
    });
    if (this.jsonBuffer.length >= 1000 && !this.flushPromise && !this.flushQueued) {
      this.flushQueued = true;
      queueMicrotask(() => {
        this.flushQueued = false;
        this.flushJson();
      });
    }
  }
  addJsonResult(data) {
    this.addJsonEntry({ type: "result", data });
  }
  async flushJson() {
    if (this.jsonBuffer.length === 0)
      return;
    if (this.flushPromise)
      return this.flushPromise;
    this.flushPromise = (async () => {
      const bufferCopy = [...this.jsonBuffer];
      this.jsonBuffer = [];
      console.log(JSON.stringify(bufferCopy, null, 2));
    })().finally(() => {
      this.flushPromise = null;
    });
    return this.flushPromise;
  }
  getJsonBuffer() {
    return [...this.jsonBuffer];
  }
  clearJsonBuffer() {
    this.jsonBuffer = [];
  }
  reset() {
    this.config = { verbose: false, json: false, quiet: false };
    this.jsonBuffer = [];
    this.flushPromise = null;
    this.flushQueued = false;
    this.unicodeSupported = supportsUnicode();
  }
}
var output2 = new OutputManager2;

// src/index.ts
process.on("warning", (warning) => {
  if (warning.name === "DeprecationWarning" && warning.code === "DEP0005") {
    return;
  }
  console.error(warning.toString());
});
var isShuttingDown = false;
var shutdown = (signal) => {
  if (isShuttingDown)
    return;
  isShuttingDown = true;
  console.error(`
${signal} received, shutting down...`);
  process.exitCode = 130;
};
process.on("SIGINT", () => shutdown("SIGINT"));
process.on("SIGTERM", () => shutdown("SIGTERM"));
if (process.stdout.setEncoding) {
  process.stdout.setEncoding("utf8");
}
if (process.stderr.setEncoding) {
  process.stderr.setEncoding("utf8");
}
var cli = createCliInstance();
registerCommands(cli);
registerGlobalFlags(cli);
var parsed = cli.parse(process.argv, { run: false });
(async () => {
  try {
    if (parsed.options.version) {
      await displayVersion();
      process.exitCode = 0;
      return;
    }
    if (parsed.options.help || !cli.matchedCommand && parsed.args.length === 0) {
      const { handleHelp: handleHelp2 } = await Promise.resolve().then(() => (init_help_interceptor(), exports_help_interceptor));
      await handleHelp2(parsed.args);
      return;
    }
    const envVerbose = process.env.CLAUDEKIT_VERBOSE === "1" || process.env.CLAUDEKIT_VERBOSE === "true";
    const isVerbose = parsed.options.verbose || envVerbose;
    const isJson = parsed.options.json || false;
    output2.configure({
      verbose: isVerbose,
      json: isJson
    });
    if (isVerbose) {
      logger3.setVerbose(true);
    }
    if (parsed.options.logFile) {
      logger3.setLogFile(parsed.options.logFile);
    }
    logger3.verbose("ClaudeKit CLI starting", {
      version: getPackageVersion2(),
      command: parsed.args[0] || "none",
      options: parsed.options,
      cwd: process.cwd(),
      node: process.version
    });
    await cli.runMatchedCommand();
    if (output2.isJson()) {
      await output2.flushJson();
    }
  } catch (error) {
    console.error("CLI error:", error instanceof Error ? error.message : error);
    process.exitCode = 1;
    if (output2.isJson()) {
      await output2.flushJson();
    }
  }
})().catch(async (error) => {
  console.error("Unhandled error:", error instanceof Error ? error.message : error);
  process.exitCode = 1;
  if (output2.isJson()) {
    await output2.flushJson();
  }
});
